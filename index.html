<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; img-src 'self' data: https:; font-src 'self' https://cdnjs.cloudflare.com; connect-src 'self' https://*.tencentcos.com https://*.myqcloud.com https://*.dropboxapi.com https://api.dropboxapi.com https://api.mymemory.translated.net https://api.interpreter.caiyunai.com/;">
    <title>IIIStudio - PromptStudio提示词可视化编辑器</title>
    <meta name="keywords" content="AIGC,提示词,可视化编辑器,AI绘画,Stable Diffusion,Midjourney,ComfyUI,咒语,炼金,翻译" />
    <meta name="description" content="PromptStudio是AIGC提示词可视化编辑器纯前端网站，支持AI绘画提示词管理、分类、翻译和云端同步，兼容Stable Diffusion、Midjourney、ComfyUI等主流AI绘画工具。" />
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="dns-prefetch" href="https://cdnjs.cloudflare.com">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="./js/cos-js-sdk-v5.min.js"></script>
    <style>
        :root {
            --primary-color: #6c5ce7;
            --secondary-color: #a29bfe;
            --bg-color: #f8f9fa;
            --card-bg: #ffffff;
            --text-color: #2d3436;
            --border-color: #dfe6e9;
            --sidebar-width: 280px;
            --header-height: 60px;
            --success-color: #00b894;
            --warning-color: #fdcb6e;
            --danger-color: #e17055;
        }

        .dark-mode {
            --primary-color: #7c6ef5;
            --secondary-color: #9c8ef7;
            --bg-color: #1e2026;
            --card-bg: #2d3036;
            --text-color: #e1e5eb;
            --border-color: #3a3f4b;
            --success-color: #00d8a7;
            --warning-color: #ffd166;
            --danger-color: #ff7b54;
        }

        * {
            margin: 0;

            box-sizing: border-box;
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }

        body {
            font-family: 'Segoe UI', 'PingFang SC', 'Microsoft YaHei', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            overflow-x: hidden;
        }

        .container {
            display: flex;
            min-height: 100vh;
        }

        /* 侧边栏样式 */
        .sidebar {
            width: var(--sidebar-width);
            background-color: var(--card-bg);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            height: 100vh;
            position: fixed;
            overflow-y: auto;
            z-index: 100;
        }

        .logo {
            padding: 20px;
            display: flex;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--primary-color);
            color: white;
        }

        .logo h1 {
            font-size: 1.5rem;
            margin-left: 10px;
            font-weight: 600;
        }

        .logo-icon {
            font-size: 1.8rem;
        }

        .category-list {
            padding: 15px;
            flex-grow: 1;
        }

        .category-title {
            font-size: 1.1rem;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            color: var(--primary-color);
        }

        .category-title span {
            cursor: pointer;
        }

        .prompt-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 20px;
        }

        .prompt-card {
            background-color: var(--bg-color);
            border-radius: 10px;
            padding: 6px 10px 6px 15px;
            cursor: pointer;
            border: 1px solid var(--border-color);
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .prompt-card:hover {
            border-color: var(--primary-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .prompt-card.active {
            border-color: var(--primary-color);
            background-color: rgba(108, 92, 231, 0.05);
        }

        .prompt-card h3 {
            font-size: .91rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .prompt-card p {
            font-size: 0.85rem;
            color: #888;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        .tag {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            background-color: var(--secondary-color);
            color: white;
            margin-right: 5px;
        }

        /* 主内容区样式 */
        .main-content {
            flex: 1;
            margin-left: var(--sidebar-width);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .header h2 {
            font-size: 1.8rem;
            font-weight: 600;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header-actions {
            display: flex;
            gap: 15px;
        }

        .btn {
            padding: 5px 10px;
            border-radius: 5px;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            transition: all 0.2s ease;
            font-size: 0.9rem;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }

        .btn-outline {
            background-color: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-color);
        }

        .btn-success {
            background-color: var(--success-color);
            color: white;
        }
        .icon-plus::before {
            content: "\2b";
            font-family: "Font Awesome 6 Free";
            -webkit-font-smoothing: antialiased;
            display: var(--fa-display, inline-block);
            font-style: normal;
            font-variant: normal;
            line-height: 1;
            text-rendering: auto;
        }

        .editor-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .editor-card {
            background-color: var(--card-bg);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            border: 1px solid var(--border-color);
        }

        .editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .editor-title {
            font-size: 1.2rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .editor-title i {
            color: var(--primary-color);
        }

        .editor-actions {
            display: flex;
            gap: 10px;
        }

        .editor-textarea {
            width: 100%;
            min-height: 150px;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Courier New', monospace;
            resize: vertical;
            font-size: 0.95rem;
            line-height: 1.5;
        }

        .editor-textarea:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        /* 提示词标签样式 */
        .prompt-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 15px;
            min-height: 40px;
            padding: 10px;
            border-radius: 8px;
            background-color: var(--bg-color);
            border: 1px dashed var(--border-color);
        }

        .prompt-tag {
            position: relative;
            display: inline-flex;
            align-items: stretch;
            min-height: 28px;
            border-radius: 8px;
            box-shadow: 0 2px 2px rgba(51, 54, 67, .25);
            color: #fff;
            cursor: grab;
            transition: all .2s ease;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            overflow: hidden;
        }
        .prompt-tag .delete-tag {
            position: absolute;
            top: 5px;
            left: 5px;
            width: 18px;
            height: 18px;
            border-radius: 10px;
            background: rgba(0,0,0,.55);
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            line-height: 18px;
            color: #fff;
            cursor: pointer;
            transition: background-color .2s ease;
            z-index: 2;
        }
        .prompt-tag:hover .delete-tag {
            display: inline-flex;
        }
        .prompt-tag .delete-tag:hover {
            background: rgba(0,0,0,.75);
        }
        .prompt-tag .seg-en {
            display: inline-flex;
            align-items: center;
            padding: 0 10px;
            background: linear-gradient(#606060, #6c6c6c);
            font-size: 0.85rem;
            border-top-left-radius: 8px;
            border-bottom-left-radius: 8px;
        }
        .prompt-tag .seg-zh {
            display: inline-flex;
            align-items: center;
            padding: 0 10px;
            background: linear-gradient(#a0b181, #57b049);
            font-size: 0.85rem;
        }
        .prompt-tag.no-zh .seg-en {
            border-top-right-radius: 8px;
            border-bottom-right-radius: 8px;
        }
        .prompt-tag .weight-adjust {
            display: inline-flex;
            align-items: stretch;
            background: linear-gradient(#454545, #555);
            overflow: hidden;
        }
        .prompt-tag.weight-disabled .weight-adjust {
            display: none !important;
        }
        .prompt-tag .weight-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            border: none;
            background: transparent;
            color: #fff;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color .2s ease, color .2s ease;
        }
        .prompt-tag .weight-btn + .weight-btn {
            border-left: 1px solid rgba(255,255,255,0.12);
        }
        .prompt-tag .weight-btn:hover {
            background-color: rgba(255,255,255,0.12);
            color: #ffd166;
        }
        .prompt-tag .weight-value {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0 8px;
            font-size: 0.75rem;
            font-weight: 600;
            color: #ffdd7a;
            min-width: 40px;
            background: transparent;
        }
        .dark-mode .prompt-tag .weight-adjust {
            background: linear-gradient(#2e2e2e, #3a3a3a);
        }
        .dark-mode .prompt-tag .weight-btn:hover {
            background-color: rgba(255,255,255,0.1);
        }
        .dark-mode .prompt-tag .weight-value {
            color: #ffe0a3;
        }
        .dark-mode .prompt-tag .delete-tag {
            background: rgba(0,0,0,.6);
        }

        .prompt-tag:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(51, 54, 67, .25);
        }

        .prompt-tag.dragging {
            opacity: 0.5;
        }
        /* 拖拽占位指示条 */
        .tag-placeholder {
            width: 6px;
            height: 15px;
            background: var(--primary-color);
            border-radius: 3px;
            margin: 6px 4px;
            align-self: stretch;
        }

        /* 点击置灰 + 按键凹陷效果（保留中英分段配色，仅做整体淡化与凹陷） */
        .prompt-tag:active {
            transform: translateY(0);
            box-shadow: inset 0 2px 6px rgba(0,0,0,.25);
        }
        .prompt-tag.inactive {
            opacity: .55;                 /* 整体淡化 */
            filter: grayscale(35%);       /* 轻度灰度，仍保留配色差异 */
            transform: translateY(1px);   /* 轻微下压 */
            box-shadow: inset 0 2px 8px rgba(0,0,0,.28); /* 内凹阴影 */
            cursor: pointer;
        }
        .prompt-tag.inactive:hover {
            transform: translateY(1px);   /* 悬停也保持按下，不上浮 */
            box-shadow: inset 0 2px 10px rgba(0,0,0,.32);
        }

        /* 常用提示词区域样式 */
        .common-tags-section {
            margin-top: 16px;
        }
        .common-tags-title {
            font-size: 0.95rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .common-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 10px;
            border-radius: 8px;
            background-color: var(--bg-color);
            border: 1px dashed var(--border-color);
            min-height: 40px;
        }
        .common-tag {
            height: 28px;
            display: inline-flex;
            align-items: center;
            padding: 0 10px;
            border-radius: 8px;
            font-size: 0.85rem;
            background: linear-gradient(#406e6d, #749b98);
            color: #fff;
            cursor: pointer;
            user-select: none;
            box-shadow: 0 2px 2px rgba(51, 54, 67, .25);
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }
        .common-tag.pinned {
            background: linear-gradient(#8d79c0, #7a78dc);
        }
        .common-tag:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(51, 54, 67, .25);
        }

        .common-tag.dragging {
            opacity: 0.5;
        }

        /* 关联提示词悬浮框 */
        .related-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 8px 12px;
            margin-bottom: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            width: auto;
            max-width: 300px;
            display: none;
            white-space: normal;
            pointer-events: auto;
        }
        .related-tooltip.show {
            display: block;
        }
        .related-tooltip-title {
            font-size: 0.75rem;
            color: var(--text-color);
            opacity: 0.7;
            margin-bottom: 4px;
            white-space: nowrap;
        }
        .related-tooltip-item {
            display: inline-block;
            padding: 4px 8px;
            margin: 2px;
            border-radius: 4px;
            background: var(--primary-color);
            color: white;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }
        .related-tooltip-item:hover {
            background: var(--secondary-color);
            transform: scale(1.05);
        }
        .common-tag {
            position: relative;
        }

        /* 主题切换按钮 */
        .theme-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: var(--primary-color);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 100;
            transition: all 0.3s ease;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
        }

        /* 设置按钮（位于主题切换按钮之上） */
        .settings-toggle {
            position: fixed;
            bottom: 80px;
            right: 20px;
            width: 46px;
            height: 46px;
            border-radius: 50%;
            background-color: var(--card-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 100;
            transition: all 0.3s ease;
        }
        .settings-toggle:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(0,0,0,.2);
        }

        /* 置顶按钮（位于设置按钮之上） */
        .top-toggle {
            position: fixed;
            bottom: 134px;
            right: 20px;
            width: 46px;
            height: 46px;
            border-radius: 50%;
            background-color: var(--card-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 100;
            transition: all 0.3s ease;
        }
        .top-toggle:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(0,0,0,.2);
        }

        /* 响应式设计 */
        @media (max-width: 968px) {
            .sidebar {
                width: 250px;
            }
            
            .main-content {
                margin-left: 250px;
            }
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: auto;
                position: relative;
            }
            
            .main-content {
                margin-left: 0;
            }
            
            .header {
                flex-direction: column;
                gap: 15px;
                align-items: flex-start;
            }
            
            .header-actions {
                width: 100%;
                justify-content: space-between;
            }
        }

        /* 动画效果 */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .editor-card {
            animation: fadeIn 0.5s ease;
        }

        /* 滚动条样式 */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-color);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary-color);
        }

        /* Toast 提示样式 */
        .toast-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 14px 24px;
            border-radius: 12px;
            z-index: 10000;
            box-shadow: 0 8px 24px rgba(108, 92, 231, 0.3), 0 2px 8px rgba(0, 0, 0, 0.1);
            font-size: 0.95rem;
            font-weight: 500;
            max-width: 400px;
            opacity: 0;
            transform: translateX(120%);
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .toast-notification::before {
            content: '\f00c';
            font-family: 'Font Awesome 6 Free';
            font-weight: 900;
            font-size: 1.1rem;
            opacity: 0.9;
        }
        .toast-notification.show {
            opacity: 1;
            transform: translateX(0);
        }
        .toast-notification.hide {
            opacity: 0;
            transform: translateX(120%);
        }

        /* 居中模态框样式 */
        .modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.35);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .modal {
            width: min(92vw, 480px);
            background: var(--card-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        .modal-header {
            padding: 14px 16px;
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-body {
            padding: 16px;
            display: grid;
            gap: 12px;
        }
        .modal-row {
            display: grid;
            gap: 6px;
        }
        .modal-row label {
            font-size: 0.9rem;
            opacity: 0.85;
        }
        .modal-input {
            /* width: 100%; */
            padding: 8px 8px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background: var(--bg-color);
            color: var(--text-color);
            outline: none;
        }
        .modal-input:focus {
            border-color: var(--primary-color);
        }
        .modal-footer {
            padding: 12px 16px;
            border-top: 1px solid var(--border-color);
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        .hidden { display: none; }

        /* Toggle Switch 样式 */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--border-color);
            transition: 0.3s;
            border-radius: 24px;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }
        .toggle-switch input:checked + .toggle-slider {
            background-color: var(--primary-color);
        }
        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }

        /* 右键菜单 */
        .context-menu {
            position: fixed;
            z-index: 2000;
            min-width: 80px;
            background: var(--card-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,.2), 0 2px 8px rgba(0,0,0,.1);
            padding: 8px 0;
            display: none;
            backdrop-filter: blur(10px);
        }
        .context-menu .item {
            padding: 6px 11px;
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.15s ease;
            position: relative;
        }
        .context-menu .item i {
            width: 16px;
            text-align: center;
            opacity: 0.7;
            transition: opacity 0.15s ease;
        }
        .context-menu .item:hover {
            background: linear-gradient(90deg, rgba(108, 92, 231, 0.1), rgba(108, 92, 231, 0.05));
            color: var(--primary-color);
            padding-left: 20px;
        }
        .context-menu .item:hover i {
            opacity: 1;
            color: var(--primary-color);
        }
        .context-menu .item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 3px;
            height: 0;
            background: var(--primary-color);
            border-radius: 0 2px 2px 0;
            transition: height 0.15s ease;
        }
        .context-menu .item:hover::before {
            height: 60%;
        }
        /* 右键菜单分隔线 */
        .context-menu .divider {
            height: 1px;
            background: var(--border-color);
            margin: 6px 0;
            opacity: 0.6;
        }
        .context-menu .divider:hover {
            background: var(--border-color);
        }
        /* 让通用提示模态位于最上层（覆盖其他模态） */
        #modal-confirm {
            z-index: 5000;
        }
        /* 编辑标签模态框（需要覆盖搜索模态框） */
        #modal-tag {
            z-index: 4000;
        }
        /* S3 密码输入模态框（需要覆盖同步配置模态框） */
        #modal-s3-password {
            z-index: 6000;
        }
        /* 提示词历史模态宽度扩展 */
        #modal-history .modal {
            width: min(92vw, 720px);
        }
        /* 提示词历史模态主体在内容过多时可滚动 */
        #modal-history .modal-body {
            max-height: 60vh;
            overflow: auto;
        }
        /* 右键菜单设置模态：加宽并在内容过高时可滚动 */
        #modal-ctxmenu .modal {
            width: min(92vw, 720px);
        }
        #modal-ctxmenu .modal-body {
            max-height: 60vh;
            overflow: auto;
        }
        /* 类别按钮式选择的按压/选中态 */
        .btn-toggle.active {
            background-color: var(--primary-color);
            color: #fff;
            box-shadow: inset 0 2px 6px rgba(0,0,0,.25);
            border-color: var(--primary-color);
        }
        .btn-toggle:active {
            transform: translateY(0);
            box-shadow: inset 0 2px 6px rgba(0,0,0,.25);
        }
        /* S3 配置按钮样式 */
        .s3-config-btn {
            padding: 6px 12px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: var(--bg-color);
            color: var(--text-color);
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s ease;
        }
        .s3-config-btn:hover {
            border-color: var(--primary-color);
            background: rgba(108, 92, 231, 0.05);
        }
        .s3-config-btn.active {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
        .s3-config-btn .delete-btn {
            margin-left: 6px;
            opacity: 0.6;
            font-size: 0.75rem;
        }
        .s3-config-btn .delete-btn:hover {
            opacity: 1;
            color: var(--danger-color);
        }
        .token-counter {
            text-align: right;
            font-size: 12px;
            opacity: .75;
            margin-top: 6px;
        }

        /* 搜索弹窗独立样式 - 固定在顶部 */
        .modal-so {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: min(92vw, 640px);
            max-height: calc(100vh - 40px);
            background: var(--card-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .modal-so .modal-header {
            padding: 14px 16px;
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        .modal-so .modal-body {
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            flex: 1;
            overflow: hidden;
        }
        .modal-so .modal-row {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .modal-so .modal-row label {
            font-size: 0.9rem;
            opacity: 0.85;
        }
        .modal-so .modal-input {
            padding: 10px 12px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background: var(--bg-color);
            color: var(--text-color);
            outline: none;
        }
        .modal-so .modal-input:focus {
            border-color: var(--primary-color);
        }
        .modal-so #search-results {
            flex: 1;
            overflow-y: auto;
            max-height: calc(100vh - 200px);
        }
        .modal-so .modal-footer {
            padding: 12px 16px;
            border-top: 1px solid var(--border-color);
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            flex-shrink: 0;
        }
    /* 降低动画以满足系统减少动态偏好 */
    @media (prefers-reduced-motion: reduce) {
        * {
            animation-duration: 0.01ms !important;
            animation-iteration-count: 1 !important;
            transition-duration: 0.01ms !important;
            scroll-behavior: auto !important;
        }
    }

    /* 小屏幕时按钮只显示图标 */
    @media (max-width: 768px) {
        .editor-actions .btn span {
            display: none;
        }
        .editor-actions .btn {
            padding: 8px 12px;
        }
    }
    </style>
</head>
<body>
    <div class="container">
        <!-- 侧边栏 -->
        <div class="sidebar">
            <div class="logo">
                <a href="https://github.com/IIIStudio/PromptStudio" target="_blank" rel="noopener" style="display:flex;align-items:center;color:inherit;text-decoration:none;">
                    <i class="fab fa-github logo-icon"></i>
                    <h1>Prompt Studio</h1>
                </a>
            </div>
            
            <div class="category-list">
                <div class="category-title">
                    <span>提示词标签</span>
                    <button class="btn btn-outline icon-plus" id="add-category-btn" title="新建标签"></button>
                </div>
                <div class="prompt-list">
                    
                    
                </div>
            </div>
        </div>
        
        <!-- 主内容区 -->
        <div class="main-content" id="main-content">
            <div class="header">
                <h2 id="toggle-sidebar-btn" style="cursor:pointer;user-select:none;">提示词编辑器</h2>
                <div class="header-actions">
                    <button class="btn btn-outline" id="download-json-btn">
                        <i class="fas fa-save"></i> 下载JSON/上传
                    </button>
                    <button class="btn btn-primary" id="import-json-btn">
                        <i class="fas fa-file-import"></i> 导入JSON
                    </button>
                    <button class="btn btn-outline" id="sync-config-btn">
                        <i class="fas fa-sync"></i> 同步
                    </button>
                    <button class="btn btn-outline" id="reset-all-btn">
                        <i class="fas fa-trash"></i> 重置
                    </button>
                </div>
            </div>
            
            <div class="editor-container" id="editor-container">
                <div class="editor-card">
                    <div class="editor-header">
                        <div class="editor-title">
                            <i class="fas fa-edit"></i> 提示词内容
                        </div>
                        <div class="editor-actions">
                            <button class="btn btn-outline" id="search-tags-btn" title="搜索">
                                <i class="fas fa-search"></i> <span>搜索</span>
                            </button>
                            <button class="btn btn-outline" id="random-pick-btn" title="随机">
                                <i class="fas fa-dice"></i> <span>随机</span>
                            </button>
                            <button class="btn btn-outline" onclick="resetPrompt()" title="重置">
                                <i class="fas fa-redo"></i> <span>重置</span>
                            </button>
                            <button class="btn btn-outline" onclick="copyPrompt()" title="复制">
                                <i class="fas fa-copy"></i> <span>复制</span>
                            </button>
                            <button class="btn btn-outline" id="save-prompt-btn" title="存储">
                                <i class="fas fa-bookmark"></i> <span>存储</span>
                            </button>
                            <button class="btn btn-outline" id="view-history-btn" title="查看">
                                <i class="fas fa-list"></i> <span>查看</span>
                            </button>
                        </div>
                    </div>
                    <textarea class="editor-textarea" id="prompt-editor"></textarea>

                    
                    <div class="prompt-tags" id="prompt-tags-container">
                        <!-- 标签将通过JavaScript动态生成 -->
                    </div>

                    <div class="common-tags-section">
                        <div class="common-tags-title">常用提示词
                            <button class="btn btn-outline icon-plus" id="add-tag-btn" style="margin-left:8px" title="添加标签"></button>
                            <button class="btn btn-outline" id="export-tags-image-btn" style="margin-left:8px" title="生成提示词图片并下载">提示词图片</button>
                            <button class="btn btn-outline" id="compose-tags-image-btn" style="margin-left:8px" title="合成提示词图片到选择的图片">合成图片</button>
                        </div>
                        <div class="common-tags" id="common-tags">

                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 置顶按钮 -->
    <div class="top-toggle" id="top-toggle" title="回到顶部">
        <i class="fas fa-arrow-up"></i>
    </div>
    <!-- 设置按钮 -->
    <div class="settings-toggle" id="settings-toggle" title="设置">
        <i class="fas fa-cog"></i>
    </div>
    <!-- 主题切换按钮 -->
    <div class="theme-toggle" id="theme-toggle">
        <i class="fas fa-moon"></i>
    </div>
    <input type="file" id="json-file-input" accept="application/json" style="display:none" />
    <!-- 新建分类 模态框 -->
    <div class="modal-backdrop" id="modal-category">
        <div class="modal">
            <div class="modal-header">
                <span>新建提示词标签</span>
                <button class="btn btn-outline" id="modal-cat-close">关闭</button>
            </div>
            <div class="modal-body">
                <div class="modal-row">
                    <label for="modal-cat-name">分类名称</label>
                    <input class="modal-input" id="modal-cat-name" type="text" placeholder="例如：人脸标签" />
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-outline" id="modal-cat-cancel">取消</button>
                <button class="btn btn-primary" id="modal-cat-confirm">确定</button>
            </div>
        </div>
    </div>
    <!-- 添加标签 模态框 -->
    <div class="modal-backdrop" id="modal-tag">
        <div class="modal">
            <div class="modal-header">
                <span id="modal-tag-title">添加标签</span>
                <button class="btn btn-outline" id="modal-tag-close">关闭</button>
            </div>
            <div class="modal-body">
                <div class="modal-row">
                    <label for="modal-tag-zh">中文</label>
                    <input class="modal-input" id="modal-tag-zh" type="text" placeholder="例如：斗鸡眼;歪嘴;龅牙" />
                </div>
                <div class="modal-row">
                    <label for="modal-tag-en">英文</label>
                    <input class="modal-input" id="modal-tag-en" type="text" placeholder="例如：cross-eyed;crooked mouth;bucktooth" />
                </div>
                <div class="modal-row">
                    <label for="modal-tag-related">关联</label>
                    <input class="modal-input" id="modal-tag-related" type="text" placeholder="例如：smile,happy 或 黑色|印花， 多词以|分割"/>
                </div>
                <div class="modal-row">
                    <label>类别</label>
                    <div id="modal-subcat-buttons" style="display:flex;flex-wrap:wrap;gap:8px;">
                        <button class="btn btn-outline" id="modal-subcat-newbtn" type="button">新建类别</button>
                        <!-- 下面的现有类别按钮将由 openTagModal 动态生成 -->
                    </div>
                </div>

                <div class="modal-row">
                    <label>样式</label>
                    <div id="modal-style-buttons" style="display:flex;flex-wrap:wrap;gap:8px;">
                        <button class="btn btn-toggle btn-outline active" data-style="default" type="button">默认</button>
                        <button class="btn btn-toggle btn-outline" data-style="purple" type="button" style="background: linear-gradient(#8d79c0, #7a78dc);color:white;border:none;">紫色</button>
                        <button class="btn btn-toggle btn-outline" data-style="green" type="button" style="background: linear-gradient(#a0b181, #57b049);color:white;border:none;">绿色</button>
                        <button class="btn btn-toggle btn-outline" data-style="orange" type="button" style="background: linear-gradient(#cb9131, #b57e22);color:white;border:none;">橙色</button>
                        <button class="btn btn-toggle btn-outline" data-style="pink" type="button" style="background: linear-gradient(#fd79a8, #e84393);color:white;border:none;">粉色</button>
                        <button class="btn btn-toggle btn-outline" data-style="dark-purple" type="button" style="background: linear-gradient(#584589, #7774a0);color:white;border:none;">深紫</button>
                        <button class="btn btn-toggle btn-outline" data-style="blue" type="button" style="background: linear-gradient(#2c3e80, #344495);color:white;border:none;">深蓝</button>
                    </div>
                </div>

                <div class="modal-row">
                    <label for="modal-cy-token">彩云翻译 Token</label>
                    <input class="modal-input" id="modal-cy-token" type="password" placeholder="请输入你的彩云翻译 Token" />
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-outline" id="modal-tag-translate-mymemory" title="使用 Translated 翻译">Translated</button>
                <button class="btn btn-outline" id="modal-tag-translate" title="将中文翻译为英文">彩云翻译</button>
                <button class="btn btn-outline" id="modal-tag-cancel">取消</button>
                <button class="btn btn-primary" id="modal-tag-confirm">确定</button>
            </div>
        </div>
    </div>

    <!-- 右键菜单容器 -->
    <div id="context-menu" class="context-menu">
        <div id="context-menu-list"></div>
    </div>

    <!-- 通用确认模态框 -->
    <div class="modal-backdrop" id="modal-confirm">
        <div class="modal">
            <div class="modal-header">
                <span id="modal-confirm-title">确认操作</span>
                <button class="btn btn-outline" id="modal-confirm-close">关闭</button>
            </div>
            <div class="modal-body">
                <div class="modal-row">
                    <div id="modal-confirm-message"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-outline" id="modal-confirm-cancel">取消</button>
                <button class="btn btn-primary" id="modal-confirm-ok">确定</button>
            </div>
        </div>
    </div>

    <!-- 历史快照模态框 -->
    <div class="modal-backdrop" id="modal-history">
        <div class="modal">
            <div class="modal-header">
                <span>提示词历史</span>
                <button class="btn btn-outline" id="modal-history-close">关闭</button>
            </div>
            <div class="modal-body">
                <div id="history-list" style="display:flex;flex-direction:column;gap:8px;"></div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-outline" id="modal-history-clear">清空全部</button>
            </div>
        </div>
    </div>

    <!-- S3 密码输入模态框 -->
    <div class="modal-backdrop" id="modal-s3-password">
        <div class="modal" style="max-width:400px;">
            <div class="modal-header">
                <span>输入密码</span>
            </div>
            <div class="modal-body">
                <div class="modal-row">
                    <label>请输入解密密码以访问 S3 密钥</label>
                </div>
                <div class="modal-row">
                    <input class="modal-input" id="modal-password-input" type="password" placeholder="请输入密码" autofocus />
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-outline" id="modal-password-cancel">取消</button>
                <button class="btn btn-primary" id="modal-password-confirm">确定</button>
            </div>
        </div>
    </div>

    <!-- 右键菜单设置模态框 -->
    <div class="modal-backdrop" id="modal-ctxmenu">
        <div class="modal">
            <div class="modal-header">
                <span>设置</span>
                <button class="btn btn-outline" id="modal-ctx-close">关闭</button>
            </div>
            <div class="modal-body">
                <div class="modal-row" style="font-size:12px;opacity:.8;">
                    支持占位符：{{中文}}、{{英文}}（将自动进行 URL 编码）
                </div>
                <div class="modal-row">
                    <button class="btn btn-primary" id="ctx-add-btn" style="width:fit-content;">新增菜单项</button>
                </div>
                <div class="modal-row">
                    <div id="ctx-list" style="display:flex;flex-direction:column;gap:8px;"></div>
                </div>
                <div class="modal-row" style="margin-top:20px;border-top:1px solid var(--border-color);padding-top:16px;">
                    <label style="font-weight:600;margin-bottom:12px;display:block;">触发词设置</label>
                    <div style="display:flex;flex-direction:column;gap:12px;">
                        <div style="display:flex;align-items:center;gap:8px;">
                            <label style="width:60px;min-width:60px;">前缀</label>
                            <input class="modal-input" id="prefix-trigger-zh" type="text" placeholder="中文：打开|黑色" style="flex:1;padding:6px 8px;" />
                        </div>
                        <div style="display:flex;align-items:center;gap:8px;">
                            <label style="width:60px;min-width:60px;">后缀</label>
                            <input class="modal-input" id="suffix-trigger-zh" type="text" placeholder="中文：视角|角度" style="flex:1;padding:6px 8px;" />
                        </div>
                        <div style="font-size:12px;opacity:0.7;">
                            多个触发词用 | 分隔，英文自动从JSON中查找
                        </div>
                    </div>
                </div>
                <div class="modal-row" style="margin-top:20px;border-top:1px solid var(--border-color);padding-top:16px;">
                    <label style="font-weight:600;margin-bottom:12px;display:block;">快捷键设置</label>
                    <div style="display:grid;grid-template-columns:repeat(4,auto);gap:4px;">
                        <div style="display:flex;align-items:center;gap:2px;">
                            <label style="width:50px;font-size:0.9rem;opacity:0.8;">搜索</label>
                            <input class="modal-input" id="shortcut-search" type="text" placeholder="默认: /" style="width:70px;padding:6px 8px;font-family:monospace;text-align:center;" />
                        </div>
                        <div style="display:flex;align-items:center;gap:2px;">
                            <label style="width:50px;font-size:0.9rem;opacity:0.8;">重置</label>
                            <input class="modal-input" id="shortcut-reset" type="text" placeholder="留空则不设置" style="width:70px;padding:6px 8px;font-family:monospace;text-align:center;" />
                        </div>
                        <div style="display:flex;align-items:center;gap:2px;">
                            <label style="width:50px;font-size:0.9rem;opacity:0.8;">复制</label>
                            <input class="modal-input" id="shortcut-copy" type="text" placeholder="留空则不设置" style="width:70px;padding:6px 8px;font-family:monospace;text-align:center;" />
                        </div>
                        <div style="display:flex;align-items:center;gap:2px;">
                            <label style="width:50px;font-size:0.9rem;opacity:0.8;">存储</label>
                            <input class="modal-input" id="shortcut-save" type="text" placeholder="留空则不设置" style="width:70px;padding:6px 8px;font-family:monospace;text-align:center;" />
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" id="modal-ctx-save">保存</button>
            </div>
        </div>
    </div>

    <!-- 搜索提示词模态框 -->
    <div class="modal-backdrop" id="modal-search-tags">
        <div class="modal-so">
            <div class="modal-header">
                <span>搜索提示词</span>
                <button class="btn btn-outline" id="modal-search-close">关闭</button>
            </div>
            <div class="modal-body">
                <div class="modal-row">
                    <label>数据源</label>
                    <div id="search-source-buttons" style="display:flex;flex-wrap:wrap;gap:8px;">
                        <button class="btn btn-toggle btn-outline active" data-source="default" id="btn-source-default">默认</button>
                        <button class="btn btn-toggle btn-outline" data-source="ielts" id="btn-source-ielts">IELTS</button>
                    </div>
                </div>
                <div class="modal-row">
                    <input class="modal-input" id="search-input" type="text" placeholder="输入中文或英文关键词搜索..." />
                </div>
                <div class="modal-row" style="flex:1;overflow:hidden;">
                    <div id="search-results" style="display:flex;flex-direction:column;gap:8px;"><div style="opacity:0.6;font-size:0.9rem;">输入关键词后，下方将显示匹配的提示词</div></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" id="modal-search-clear">清空搜索</button>
            </div>
        </div>
    </div>

    <!-- 编辑分类模态框 -->
    <div class="modal-backdrop" id="modal-edit-category">
        <div class="modal">
            <div class="modal-header">
                <span>编辑分类</span>
                <button class="btn btn-outline" id="modal-edit-cat-close">关闭</button>
            </div>
            <div class="modal-body">
                <div class="modal-row">
                    <label for="modal-edit-cat-name">分类名称</label>
                    <input class="modal-input" id="modal-edit-cat-name" type="text" placeholder="例如：人脸标签" />
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-outline" id="modal-edit-cat-cancel">取消</button>
                <button class="btn btn-primary" id="modal-edit-cat-confirm">确定</button>
            </div>
        </div>
    </div>

    <!-- 同步配置模态框 -->
    <div class="modal-backdrop" id="modal-sync">
        <div class="modal">
            <div class="modal-header">
                <span>同步配置</span>
                <div style="display:flex;align-items:center;gap:8px;">
                    <label style="font-size:14px;">启用云端</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="modal-cloud-enabled" />
                        <span class="toggle-slider"></span>
                    </label>
                    <button class="btn btn-outline" id="modal-sync-close">关闭</button>
                </div>
            </div>
            <div class="modal-body">
                <div class="modal-row">
                    <label>同步方式</label>
                    <div id="sync-provider-buttons" style="display:flex;flex-wrap:wrap;gap:8px;">
                        <button class="btn btn-toggle btn-outline" data-provider="dropbox" id="btn-provider-dropbox">Dropbox</button>
                        <button class="btn btn-toggle btn-outline" data-provider="s3" id="btn-provider-s3">S3 (腾讯云 COS)</button>
                    </div>
                </div>

                <!-- Dropbox 配置区域 -->
                <div id="sync-dropbox-config">
                    <div class="modal-row">
                        <label for="modal-db-key">App Key</label>
                        <input class="modal-input" id="modal-db-key" type="password" placeholder="Dropbox App Key" />
                    </div>
                    <div class="modal-row">
                        <label for="modal-db-secret">App Secret</label>
                        <input class="modal-input" id="modal-db-secret" type="password" placeholder="Dropbox App Secret" />
                    </div>
                    <div class="modal-row">
                        <label for="modal-db-refresh">Refresh Token / 授权码或回调URL</label>
                        <input class="modal-input" id="modal-db-refresh" type="password" placeholder="可粘贴 Refresh Token，或直接粘贴回调后的整条URL" />
                    </div>
                    <div class="modal-row" style="font-size:12px;opacity:.75;"><p></p>
                        <p style="color:var(--danger-color);margin-bottom:8px;">
                            ⚠️ 使用说明：点击"授权"在弹窗中登录并同意授权。授权完成后若拿到 https://localhost/?code=...，可直接将整条地址或 code部分 粘贴到上方输入框并点"登录"，系统会自动先兑换 Refresh Token；若已拿到 Refresh Token，直接粘贴后点"登录"即可获取临时 Access Token。
                        </p>
                    </div>
                </div>

                <!-- S3 配置区域 -->
                <div id="sync-s3-config" style="display:none;">
                    <!-- 文件名称管理区域 -->
                    <div class="modal-row" style="border-bottom:1px solid var(--border-color);padding-bottom:12px;margin-bottom:12px;">
                        <label style="font-weight:600;color:var(--primary-color);margin-bottom:8px;">文件名称管理</label>
                        <div style="display:flex;gap:8px;flex-wrap:wrap;">
                            <button class="btn btn-outline" id="modal-s3-btn-default">默认</button>
                            <button class="btn btn-success" id="modal-s3-btn-fetch">获取</button>
                        </div>
                        <div id="modal-s3-config-list" style="display:flex;flex-wrap:wrap;gap:8px;margin-top:10px;"></div>
                    </div>
                    <div class="modal-row">
                        <label for="modal-s3-secret-id">Secret ID</label>
                        <input class="modal-input" id="modal-s3-secret-id" type="password" placeholder="腾讯云 API 密钥 SecretId" />
                    </div>
                    <div class="modal-row">
                        <label for="modal-s3-secret-key">Secret Key</label>
                        <input class="modal-input" id="modal-s3-secret-key" type="password" placeholder="腾讯云 API 密钥 SecretKey" />
                    </div>
                    <div class="modal-row">
                        <label for="modal-s3-region">Region</label>
                        <input class="modal-input" id="modal-s3-region" type="password" placeholder="存储桶所在区域，例如 ap-beijing" />
                    </div>
                    <div class="modal-row">
                        <label for="modal-s3-bucket">Bucket Name</label>
                        <input class="modal-input" id="modal-s3-bucket" type="password" placeholder="存储桶名称，例如 examplebucket-1250000000" />
                    </div>
                    <div class="modal-row" id="modal-s3-encrypt-row">
                        <label for="modal-s3-encrypt-password">加密密码</label>
                        <input class="modal-input" id="modal-s3-encrypt-password" type="password" placeholder="输入密码用于加密密钥(至少8位)" />
                    </div>
                    <div class="modal-row" style="font-size:12px;opacity:.75;">
                      <p style="color:var(--danger-color);margin-bottom:8px;">⚠️ 重要：必须配置 CORS 才能使用！如何开启 <a href="https://cnb.cool/IIIStudio/Code/HTML/PromptStudio#s3-%E8%85%BE%E8%AE%AF%E4%BA%91-cos%E5%8F%AF%E9%80%89" target="_blank">CORS 配置</a>文件会在
Prompt Studio目录下</p>
                    </div>
                </div>
            </div>
            <div class="modal-footer" id="sync-footer-dropbox">
                <button class="btn btn-outline" id="modal-db-clear" style="margin-right:auto;">清除密钥</button>
                <button class="btn btn-outline" id="modal-db-cancel">取消</button>
                <button class="btn btn-outline" id="modal-db-authorize">授权</button>
                <button class="btn btn-success" id="modal-db-login">登录</button>
                <button class="btn btn-primary" id="modal-db-save">保存</button>
            </div>
            <div class="modal-footer hidden" id="sync-footer-s3">
                <div style="margin-right:auto;display:flex;gap:8px;">
                    <button class="btn btn-outline" id="modal-s3-clear">清除密钥</button>
                    <button class="btn btn-outline" id="modal-s3-export">导出</button>
                    <button class="btn btn-outline" id="modal-s3-import">导入</button>
                </div>
                <button class="btn btn-outline" id="modal-s3-cancel">取消</button>
                <button class="btn btn-primary" id="modal-s3-save">保存</button>
            </div>
        </div>
    </div>

    <script>
        'use strict';

        // ==================== PromptStudio 提示词可视化编辑器 ====================
        // 功能说明：
        // 1. 提示词管理和分类：支持提示词的创建、编辑、删除、分组管理
        // 2. 中英文翻译：支持自动翻译中英文提示词
        // 3. 权重调整：支持提示词权重调整
        // 4. 云端同步：支持 Dropbox 和 S3 (腾讯云 COS) 云端同步
        // 5. 历史记录：支持提示词历史快照存储和查看
        // 6. 搜索功能：支持快速搜索提示词
        // 7. 导出导入：支持 JSON 格式的数据导出和导入
        // 8. 提示词图片：支持生成提示词图片和合成图片
        // ==============================================================================

        // ==================== 全局配置 ====================
        const DEFAULT_JSON_FILENAME = 'OHAO AI Prompt Studio.json';

        // 权重配置常量
        const TAG_WEIGHT_MIN = 0.5;
        const TAG_WEIGHT_MAX = 2;
        const TAG_WEIGHT_STEP_TICKS = 1; // 单步对应 0.1
        const TAG_WEIGHT_MIN_TICKS = Math.round(TAG_WEIGHT_MIN * 10);
        const TAG_WEIGHT_MAX_TICKS = Math.round(TAG_WEIGHT_MAX * 10);

        // LocalStorage 键名常量
        const THEME_KEY = 'ops_theme';
        const MENU_KEY = 'ops_ctx_menu_items';
        const STORAGE_KEY = 'ops_common_data';
        const HISTORY_KEY = 'ops_prompt_history';
        const ONBOARD_KEY = 'ops_onboard_done';
        const WEIGHT_PREF_KEY = 'ops_weight_controls_enabled';
        const S3_CONFIGS_KEY = 'ops_s3_configs';
        const S3_SELECTED_CONFIG_KEY = 'ops_s3_selected_config';

        // ==================== 主题切换功能 ====================
        const themeToggle = document.getElementById('theme-toggle');

        /**
         * 应用主题（亮色/暗色）
         * @param {string} mode - 'light' 或 'dark'
         */
        function applyTheme(mode) {
            const isDark = mode === 'dark';
            document.body.classList.toggle('dark-mode', isDark);
            const icon = themeToggle?.querySelector('i');
            if (icon) {
                if (isDark) {
                    icon.classList.remove('fa-moon');
                    icon.classList.add('fa-sun');
                } else {
                    icon.classList.remove('fa-sun');
                    icon.classList.add('fa-moon');
                }
            }
        }

        // 首次加载：优先使用本地保存，其次使用系统偏好
        (function initTheme() {
            try {
                const saved = localStorage.getItem(THEME_KEY);
                const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                const mode = saved === 'dark' || saved === 'light' ? saved : (prefersDark ? 'dark' : 'light');
                applyTheme(mode);
            } catch(e) {
                applyTheme('light');
            }
        })();

        themeToggle?.addEventListener('click', () => {
            const next = document.body.classList.contains('dark-mode') ? 'light' : 'dark';
            applyTheme(next);
            try { localStorage.setItem(THEME_KEY, next); } catch(e) {}
        });

        // 置顶按钮功能
        const topToggle = document.getElementById('top-toggle');
        topToggle?.addEventListener('click', () => {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // ==================== 提示词编辑器 ====================
        const promptEditor = document.getElementById('prompt-editor');

        /**
         * 解析带权重的标签
         * @param {string} raw - 原始标签文本
         * @returns {Object} { base, weight, hasWeight }
         */
        function parseWeightedTag(raw) {
            const text = (raw || '').trim();
            if (!text) {
                return { base: '', weight: 1, hasWeight: false };
            }
            if (text.startsWith('(') && text.endsWith(')')) {
                const inner = text.slice(1, -1);
                const colonIndex = inner.lastIndexOf(':');
                if (colonIndex > 0) {
                    const base = inner.slice(0, colonIndex).trim();
                    const weightStr = inner.slice(colonIndex + 1).trim();
                    const weightNum = parseFloat(weightStr);
                    if (base && !Number.isNaN(weightNum)) {
                        return { base, weight: weightNum, hasWeight: true };
                    }
                }
            }
            return { base: text, weight: 1, hasWeight: false };
        }

        /**
         * 限制权重刻度在有效范围内
         * @param {number} ticks - 权重刻度
         * @returns {number} 限制后的刻度
         */
        function clampWeightTicks(ticks) {
            if (!Number.isFinite(ticks)) return Math.round(1 * 10);
            if (ticks < TAG_WEIGHT_MIN_TICKS) return TAG_WEIGHT_MIN_TICKS;
            if (ticks > TAG_WEIGHT_MAX_TICKS) return TAG_WEIGHT_MAX_TICKS;
            return ticks;
        }

        /**
         * 刻度转权重值
         * @param {number} ticks - 权重刻度
         * @returns {number} 权重值
         */
        /**
         * 将刻度值转换为权重值
         * @param {number} ticks - 刻度值
         * @returns {number} 权重值
         */
        function ticksToWeight(ticks) {
            return clampWeightTicks(Math.round(ticks)) / 10;
        }

        /**
         * 将权重值转换为刻度值
         * @param {number} weight - 权重值
         * @returns {number} 刻度值
         */
        function weightToTicks(weight) {
            const safeWeight = Number.isFinite(weight) ? weight : 1;
            return clampWeightTicks(Math.round(safeWeight * 10));
        }

        /**
         * 格式化带权重的标签
         * @param {string} baseText - 标签文本
         * @param {number} weightValue - 权重值
         * @returns {string} 格式化后的标签，如 "(tag:1.5)"
         */
        function formatWeightedTag(baseText, weightValue) {
            const base = (baseText || '').trim();
            if (!base) return '';
            const ticks = weightToTicks(weightValue);
            if (ticks === Math.round(1 * 10)) {
                return base;
            }
            const normalizedWeight = ticks / 10;
            const weightStr = (Math.round(normalizedWeight * 100) / 100).toFixed(2).replace(/\. ?0+$/, '');
            return `(${base}:${weightStr})`;
        }

        /**
         * 计算下一个权重值
         * @param {number} currentWeight - 当前权重值
         * @param {number} deltaSteps - 变化的步数（正数为增加，负数为减少）
         * @returns {number} 计算后的权重值
         */
        /**
         * 计算下一个权重值
         * @param {number} currentWeight - 当前权重值
         * @param {number} deltaSteps - 变化的步数（正数为增加，负数为减少）
         * @returns {number} 计算后的权重值
         */
        function computeNextWeight(currentWeight, deltaSteps) {
            const currentTicks = weightToTicks(currentWeight);
            const nextTicks = clampWeightTicks(currentTicks + (deltaSteps * TAG_WEIGHT_STEP_TICKS));
            return nextTicks / 10;
        }

        /**
         * 调整标签权重
         * @param {string} currentTag - 当前标签
         * @param {number} deltaSteps - 变化的步数（正数为增加，负数为减少）
         */
        function adjustTagWeightBySteps(currentTag, deltaSteps) {
            if (!currentTag) return;
            const parsed = parseWeightedTag(currentTag);
            const base = parsed.base;
            const baseKey = base.toLowerCase();
            const curW = Number.isFinite(parsed.weight) ? parsed.weight : 1;
            const nextW = computeNextWeight(curW, deltaSteps);
            const formatted = formatWeightedTag(base, nextW);

            weightStateMap.set(baseKey, nextW);

            if (Array.isArray(window.__lastRenderList)) {
                const pos = window.__lastRenderList.indexOf(currentTag);
                if (pos >= 0) window.__lastRenderList.splice(pos, 1, formatted);
            }
            if (window.__disabledTagSet.has(currentTag)) {
                window.__disabledTagSet.delete(currentTag);
                window.__disabledTagSet.add(formatted);
            }
            let parts = (promptEditor.value || '').split(/[,，]/)
                .map(s => formatWeightedTag(parseWeightedTag(s).base, parseWeightedTag(s).weight))
                .filter(Boolean);
            const idx = parts.indexOf(currentTag);
            if (idx >= 0) {
                parts[idx] = formatted;
                promptEditor.value = parts.join(', ');
            }
            normalizePromptInput();
            updateTags();
        }


        // ==================== 右键菜单配置存取 ====================

        /**
         * 获取右键菜单配置
         * @returns {Array} 菜单项数组
         */
        function getCtxMenus() {
            try {
                const raw = localStorage.getItem(MENU_KEY);
                const arr = raw ? JSON.parse(raw) : [];
                return Array.isArray(arr) ? arr.filter(x => x && typeof x === 'object') : [];
            } catch(e) { return []; }
        }

        /**
         * 保存右键菜单配置
         * @param {Array} arr - 菜单项数组
         */
        function setCtxMenus(arr) {
            try { localStorage.setItem(MENU_KEY, JSON.stringify(Array.isArray(arr) ? arr : [])); } catch(e) {}
        }

        /**
         * 从 URL 模板构建 URL
         * 支持 {{中文}} / {{英文}} 占位符，自动 URL 编码
         * @param {string} tpl - URL 模板
         * @param {string} en - 英文内容
         * @param {string} zh - 中文内容
         * @returns {string} 构建后的 URL
         */
        function buildUrlFromTemplate(tpl, en, zh) {
            const rep = s => encodeURIComponent(s || '');
            return String(tpl || '')
                .replace(/{{\s*英文\s*}}/g, rep(en || ''))
                .replace(/{{\s*中文\s*}}/g, rep(zh || ''));
        }

        /**
         * 打开右键菜单设置弹窗
         */
        function openCtxMenuModal() {
            const wrap = document.getElementById('modal-ctxmenu');
            const closeBtn = document.getElementById('modal-ctx-close');
            const saveBtn = document.getElementById('modal-ctx-save');
            const list = document.getElementById('ctx-list');
            const addBtn = document.getElementById('ctx-add-btn');

            let data = getCtxMenus().slice();

            // 加载触发词设置
            try {
                const prefixTriggerZh = localStorage.getItem('ops_prefix_trigger_zh') || '';
                const suffixTriggerZh = localStorage.getItem('ops_suffix_trigger_zh') || '';
                const prefixInput = document.getElementById('prefix-trigger-zh');
                const suffixInput = document.getElementById('suffix-trigger-zh');
                if (prefixInput) prefixInput.value = prefixTriggerZh;
                if (suffixInput) suffixInput.value = suffixTriggerZh;
            } catch(e) {}

            function renderList() {
                list.innerHTML = '';
                if (!data.length) {
                    const empty = document.createElement('div');
                    empty.style.opacity = '.7';
                    empty.style.fontSize = '0.9rem';
                    empty.textContent = '暂无菜单项，点击"新增菜单项"进行添加';
                    list.appendChild(empty);
                    return;
                }
                data.forEach((m, i) => {
                    const row = document.createElement('div');
                    row.style.border = '1px solid var(--border-color)';
                    row.style.borderRadius = '8px';
                    row.style.padding = '8px';
                    row.style.display = 'grid';
                    row.style.gap = '6px';

                    const head = document.createElement('div');
                    head.style.display = 'flex';
                    head.style.justifyContent = 'space-between';
                    head.style.alignItems = 'center';

                    const title = document.createElement('div');
                    title.style.display = 'flex';
                    title.style.alignItems = 'center';
                    title.style.gap = '8px';

                    const iconEl = document.createElement('i');
                    iconEl.className = (m.icon || 'fas fa-globe');
                    const nameEl = document.createElement('span');
                    nameEl.textContent = m.name || '(未命名)';
                    nameEl.style.fontWeight = '600';

                    title.appendChild(iconEl);
                    title.appendChild(nameEl);

                    const ops = document.createElement('div');
                    ops.style.display = 'flex';
                    ops.style.gap = '8px';

                    const btnEdit = document.createElement('button');
                    btnEdit.className = 'btn btn-outline';
                    btnEdit.textContent = '编辑';
                    btnEdit.addEventListener('click', async () => {
                        const icon = await showIconPicker(m.icon || 'fas fa-globe');
                        if (icon === null) return;
                        const name = await showInputModal('名称', '谷歌翻译', m.name || '');
                        if (name === null) return;
                        const url = await showInputModal('链接模板', '例如：https://translate.google.com/?source=osdd&sl=auto&tl=zh-CN&text={{英文}}', m.url || '');
                        if (url === null) return;
                        data[i] = { icon: (icon || 'fas fa-globe').trim(), name: (name || '').trim(), url: (url || '').trim() };
                        renderList();
                    });

                    const btnDel = document.createElement('button');
                    btnDel.className = 'btn btn-outline';
                    btnDel.textContent = '删除';
                    btnDel.addEventListener('click', async () => {
                        const ok = await showConfirm('确认删除该菜单项？', '删除菜单项');
                        if (!ok) return;
                        data.splice(i, 1);
                        renderList();
                    });

                    const btnUp = document.createElement('button');
                    btnUp.className = 'btn btn-outline';
                    btnUp.textContent = '上移';
                    btnUp.addEventListener('click', () => {
                        if (i <= 0) return;
                        const tmp = data[i - 1];
                        data[i - 1] = data[i];
                        data[i] = tmp;
                        renderList();
                    });

                    const btnDown = document.createElement('button');
                    btnDown.className = 'btn btn-outline';
                    btnDown.textContent = '下移';
                    btnDown.addEventListener('click', () => {
                        if (i >= data.length - 1) return;
                        const tmp = data[i + 1];
                        data[i + 1] = data[i];
                        data[i] = tmp;
                        renderList();
                    });

                    ops.appendChild(btnEdit);
                    ops.appendChild(btnUp);
                    ops.appendChild(btnDown);
                    ops.appendChild(btnDel);

                    head.appendChild(title);
                    head.appendChild(ops);

                    const urlPreview = document.createElement('div');
                    urlPreview.style.fontSize = '0.85rem';
                    urlPreview.style.opacity = '.75';
                    urlPreview.textContent = m.url || '';

                    row.appendChild(head);
                    row.appendChild(urlPreview);
                    list.appendChild(row);
                });
            }

            addBtn.onclick = async () => {
                const icon = await showIconPicker('fas fa-globe');
                if (icon === null) return;
                const name = await showInputModal('名称', '菜单名字，例如：谷歌翻译', '');
                if (name === null) return;
                const url = await showInputModal('链接模板', '例如：https://translate.google.com/?source=osdd&sl=auto&tl=zh-CN&text={{英文}}', '');
                if (url === null) return;
                data.push({ icon: (icon || 'fas fa-globe').trim(), name: (name || '').trim(), url: (url || '').trim() });
                renderList();
            };

            function onSave() {
                const cleaned = data.filter(m => (m && (m.url || '').trim() && (m.name || '').trim()))
                    .map(m => ({ icon: (m.icon || 'fas fa-globe').trim(), name: m.name.trim(), url: m.url.trim() }));
                setCtxMenus(cleaned);
                
                // 保存触发词设置
                try {
                    const prefixTriggerZh = document.getElementById('prefix-trigger-zh')?.value || '';
                    const suffixTriggerZh = document.getElementById('suffix-trigger-zh')?.value || '';
                    localStorage.setItem('ops_prefix_trigger_zh', prefixTriggerZh.trim());
                    localStorage.setItem('ops_suffix_trigger_zh', suffixTriggerZh.trim());
                } catch(e) {}
                
                hide(wrap);
            }
            function onClose() { hide(wrap); }

            function onKey(e) {
                if (e.key === 'Escape') onClose();
            }

            saveBtn.onclick = onSave;
            closeBtn.onclick = onClose;
            document.addEventListener('keydown', onKey);

            renderList();
            show(wrap);
        }

        // 绑定设置按钮
        document.getElementById('settings-toggle')?.addEventListener('click', openCtxMenuModal);

        const tagsContainer = document.getElementById('prompt-tags-container');
        const commonTagsContainer = document.getElementById('common-tags');
        const weightStateMap = new Map();
        const weightPrefKey = 'ops_weight_controls_enabled';
        const savedWeightPref = localStorage.getItem(weightPrefKey);
        if (savedWeightPref === null) {
            window.__weightControlsEnabled = false;
        } else {
            window.__weightControlsEnabled = savedWeightPref === 'true';
        }
        // 中英文模式标志: true = 中文模式(不自动转英文), false = 英文模式(自动转英文)
        window.__chineseMode = false;
        function updateWeightControlVisibility() {
            const enabled = window.__weightControlsEnabled;
            if (!tagsContainer) return;
            tagsContainer.querySelectorAll('.prompt-tag').forEach(tagEl => {
                tagEl.classList.toggle('weight-disabled', !enabled);
                const panel = tagEl.querySelector('[data-role="weight-panel"]');
                if (panel) panel.style.display = enabled ? 'inline-flex' : 'none';
            });
        }
        // 确保 Token 计数器存在，并添加权重开关
        (function ensureTokenCounter() {
            try {
                let wrap = document.getElementById('token-counter-wrap');
                if (!wrap) {
                    wrap = document.createElement('div');
                    wrap.id = 'token-counter-wrap';
                    wrap.style.display = 'flex';
                    wrap.style.justifyContent = 'space-between';
                    wrap.style.alignItems = 'center';
                    wrap.style.gap = '12px';

                    const toggleLabel = document.createElement('label');
                    toggleLabel.className = 'toggle-switch';
                    const initialEnabled = window.__weightControlsEnabled;
                    toggleLabel.innerHTML = `
                        <input type="checkbox" id="weight-visibility-toggle"${initialEnabled ? ' checked' : ''}>
                        <span class="toggle-slider"></span>
                    `;

                    const labelText = document.createElement('span');
                    labelText.textContent = '显示权重控制';
                    labelText.style.fontSize = '14px';

                    const toggleWrap = document.createElement('div');
                    toggleWrap.style.display = 'flex';
                    toggleWrap.style.alignItems = 'center';
                    toggleWrap.style.gap = '12px';
                    toggleWrap.appendChild(labelText);
                    toggleWrap.appendChild(toggleLabel);

                    // 中英文切换按钮
                    const langToggleBtn = document.createElement('button');
                    langToggleBtn.id = 'lang-toggle-btn';
                    langToggleBtn.className = 'btn btn-outline';
                    langToggleBtn.textContent = '中文';
                    langToggleBtn.title = '点击切换中英文显示';
                    langToggleBtn.style.fontSize = '12px';
                    langToggleBtn.style.padding = '4px 10px';
                    langToggleBtn.style.marginRight = '8px';

                    const finalToggleWrap = document.createElement('div');
                    finalToggleWrap.style.display = 'flex';
                    finalToggleWrap.style.alignItems = 'center';
                    finalToggleWrap.appendChild(langToggleBtn);
                    finalToggleWrap.appendChild(toggleWrap);

                    const counter = document.createElement('div');
                    counter.id = 'token-counter';
                    counter.className = 'token-counter';
                    counter.textContent = 'Tokens: 0/75';

                    wrap.appendChild(finalToggleWrap);
                    wrap.appendChild(counter);

                    if (promptEditor && promptEditor.parentNode) {
                        promptEditor.parentNode.insertBefore(wrap, promptEditor.nextSibling);
                    }

                    const toggle = wrap.querySelector('#weight-visibility-toggle');
                    if (toggle) {
                        toggle.checked = window.__weightControlsEnabled;
                        updateWeightControlVisibility();
                        toggle.addEventListener('change', (e) => {
                            const enabled = !!e.target.checked;
                            window.__weightControlsEnabled = enabled;
                            try {
                                localStorage.setItem(weightPrefKey, String(enabled));
                            } catch (_) {}
                            updateWeightControlVisibility();
                        });
                    }

                    // 中英文切换功能
                    langToggleBtn.addEventListener('click', () => {
                        const currentText = promptEditor.value || '';
                        if (!currentText.trim()) return;

                        const parts = currentText.split(/[,，]/).map(s => s.trim()).filter(Boolean);
                        const convertedParts = [];

                        let isChineseMode = langToggleBtn.textContent === '中文';

                        // 确保 findZh 和 findEn 函数已定义
                        if (typeof findZh !== 'function' || typeof findEn !== 'function') {
                            showInfo('翻译函数未就绪,请稍后再试', '错误');
                            return;
                        }

                        // 切换中文模式标志
                        window.__chineseMode = isChineseMode;

                        parts.forEach(part => {
                            const parsed = parseWeightedTag(part);
                            const baseText = parsed.base;
                            const weight = parsed.weight;

                            if (isChineseMode) {
                                // 按钮显示"中文" -> 当前是英文模式,点击后转为中文
                                let zh = findZh(baseText);
                                if (!zh) zh = baseText; // 找不到则保持原样
                                const converted = formatWeightedTag(zh, weight);
                                convertedParts.push(converted);
                            } else {
                                // 按钮显示"English" -> 当前是中文模式,点击后转为英文
                                let en = findEn(baseText);
                                if (!en) en = baseText; // 找不到则保持原样
                                const converted = formatWeightedTag(en, weight);
                                convertedParts.push(converted);
                            }
                        });

                        promptEditor.value = convertedParts.join(', ');
                        normalizePromptInput();
                        updateTags();

                        // 切换按钮文本
                        if (isChineseMode) {
                            langToggleBtn.textContent = 'English';
                        } else {
                            langToggleBtn.textContent = '中文';
                        }
                    });
                } else {
                    const counter = document.getElementById('token-counter');
                    if (counter) counter.textContent = 'Tokens: 0/75';
                }
            } catch(_) {}
        })();

        // 本地存储常用提示词（顶层为分类名，值为数组 {text, lang_zh}）
        // ==================== 中英文转换与数据管理 ====================
        let commonData = {};
        let zhToEnMap = null;
        const sidebarList = document.querySelector('.prompt-list');

        function normalizeZhKey(text) {
            if (typeof text !== 'string') return '';
            return text.trim().replace(/\s+/g, '');
        }

        function extractZhVariants(raw) {
            const base = typeof raw === 'string' ? raw.trim() : '';
            if (!base) return [];
            const variants = new Set([base]);
            base.split(/[\|｜/、，,;；]+/).forEach(part => {
                const trimmed = part.trim();
                if (trimmed) variants.add(trimmed);
            });
            return Array.from(variants);
        }

        function refreshZhToEnCache() {
            const map = new Map();
            const addPair = (variant, enText) => {
                const key = normalizeZhKey(variant);
                if (!key || map.has(key)) return;
                map.set(key, enText);
            };
            const collectFromArray = (arr) => {
                arr.forEach(item => {
                    const enText = (item?.text || '').trim();
                    const zhRaw = (item?.lang_zh || '').trim();
                    if (!enText || !zhRaw) return;
                    extractZhVariants(zhRaw).forEach(variant => addPair(variant, enText));
                });
            };
            try {
                Object.keys(commonData || {}).forEach(cat => {
                    const value = commonData[cat];
                    if (Array.isArray(value)) {
                        collectFromArray(value);
                    } else if (isGroupedCategory(value)) {
                        const groups = value.groups || {};
                        Object.keys(groups).forEach(groupKey => {
                            const arr = groups[groupKey];
                            if (Array.isArray(arr)) collectFromArray(arr);
                        });
                    }
                });
            } catch (_) {}
            zhToEnMap = map;
        }

        function findEn(zhText) {
            const key = normalizeZhKey(zhText);
            if (!key) return '';
            if (!zhToEnMap) refreshZhToEnCache();
            return zhToEnMap?.get(key) || '';
        }

        // 分组工具函数
        function isGroupedCategory(v) {
            return v && typeof v === 'object' && !Array.isArray(v) && v.groups && typeof v.groups === 'object';
        }
        function getGroups(cat) {
            const v = commonData?.[cat];
            if (isGroupedCategory(v)) return v.groups;
            return null;
        }
        function ensureGrouped(cat) {
            const v = commonData?.[cat];
            if (isGroupedCategory(v)) return; // 已是分组
            const arr = Array.isArray(v) ? v : [];
            if (arr.length > 0) {
                // 旧有条目迁移到"未分组"
                commonData[cat] = { groups: { '未分组': arr } };
            } else {
                // 空分类：不自动创建"未分组"
                commonData[cat] = { groups: {}, groupsOrder: [] };
            }
        }
        function normalizeItem(x) {
            return {
                text: (x?.text || '').trim(),
                lang_zh: (x?.lang_zh || '').trim() || (x?.text || '').trim(),
                pinned: !!x?.pinned
            };
        }
        // 类别折叠状态（默认展开）
        function getSubcatOpen(cat, subcat) {
            try { return localStorage.getItem('ops_open_' + cat + '::' + subcat) !== '0'; } catch(e) { return true; }
        }
        function setSubcatOpen(cat, subcat, open) {
            try { localStorage.setItem('ops_open_' + cat + '::' + subcat, open ? '1' : '0'); } catch(e) {}
        }

        function saveCommonData() {
            try { localStorage.setItem(STORAGE_KEY, JSON.stringify(commonData)); } catch(e) { console.error('保存失败', e); }
            refreshZhToEnCache();
        }

        function loadCommonTagsFromStorage() {
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                commonData = raw ? JSON.parse(raw) : {};
            } catch (e) {
                commonData = {};
            }
            refreshZhToEnCache();
            renderSidebar();
        }

        function renderSidebar() {
            if (!sidebarList) return;
            sidebarList.innerHTML = '';
            const keys = Object.keys(commonData);
            const active = getActiveCategory();
            keys.forEach((key) => {
                const card = document.createElement('div');
                card.className = 'prompt-card' + (key === active ? ' active' : '');
                card.setAttribute('data-cat', key);
                const h3 = document.createElement('h3');
                h3.innerHTML = '<i class="fas fa-tag"></i> ';
                const textSpan = document.createElement('span');
                textSpan.textContent = key;
                h3.appendChild(textSpan);
                card.appendChild(h3);
                card.addEventListener('click', () => {
                    document.querySelectorAll('.prompt-card').forEach(c => c.classList.remove('active'));
                    card.classList.add('active');
                    setActiveCategory(key);
                    renderCommonTagsByCategory(key);
                });
                // 启用侧栏分类拖拽
                card.draggable = true;
                card.addEventListener('dragstart', handleCatDragStart);
                card.addEventListener('dragend', handleCatDragEnd);
                // 子元素也监听 dragover/drop，确保在卡片上释放也能触发
                card.addEventListener('dragover', onSidebarDragOver);
                card.addEventListener('drop', onSidebarDrop);
                // 右键菜单支持
                card.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    showCategoryContextMenu(e, key);
                });
                sidebarList.appendChild(card);
            });
            if (keys.length > 0) {
                const current = active && commonData[active] ? active : keys[0];
                setActiveCategory(current);
                renderCommonTagsByCategory(current);
                // 确保侧栏高亮
                document.querySelectorAll('.prompt-card').forEach(c => {
                    if (c.textContent.trim() === current) c.classList.add('active');
                });
            } else {
                const commonTagsContainer = document.getElementById('common-tags');
                if (commonTagsContainer) commonTagsContainer.innerHTML = '';
                setActiveCategory('');
            }
        }

        // 分类顺序调整：上移/下移
        function moveCategory(cat, direction) {
            if (!cat || !commonData) return;
            const keys = Object.keys(commonData);
            const idx = keys.indexOf(cat);
            if (idx === -1) return;
            const target = direction === 'up' ? idx - 1 : idx + 1;
            if (target < 0) { showInfo('已经是第一个了', '提示'); return; }
            if (target >= keys.length) { showInfo('已经是最后一个了', '提示'); return; }
            const newKeys = keys.slice();
            newKeys.splice(idx, 1);
            newKeys.splice(target, 0, cat);
            const reordered = {};
            newKeys.forEach(k => { reordered[k] = commonData[k]; });
            commonData = reordered;
            saveCommonData();
            setActiveCategory(cat);
            renderSidebar();
        }
        function moveCategoryUp(cat) { moveCategory(cat, 'up'); }
        function moveCategoryDown(cat) { moveCategory(cat, 'down'); }

        // 侧栏分类右键菜单
        let currentContextCategory = null;
        const categoryContextMenu = document.createElement('div');
        categoryContextMenu.className = 'context-menu';
        categoryContextMenu.innerHTML = `
            <div class="item" id="ctx-cat-edit"><i class="fas fa-edit"></i> 编辑名称</div>
            <div class="item" id="ctx-cat-delete" style="color:var(--danger-color);"><i class="fas fa-trash"></i> 删除分类</div>
            <div class="item" id="ctx-cat-move-up"><i class="fas fa-arrow-up"></i> 上移</div>
            <div class="item" id="ctx-cat-move-down"><i class="fas fa-arrow-down"></i> 下移</div>
        `;
        document.body.appendChild(categoryContextMenu);

        function showCategoryContextMenu(e, catKey) {
            currentContextCategory = catKey;
            const menu = categoryContextMenu;
            menu.style.display = 'block';
            menu.style.left = e.clientX + 'px';
            menu.style.top = e.clientY + 'px';

            // 绑定菜单项事件
            const editItem = document.getElementById('ctx-cat-edit');
            const deleteItem = document.getElementById('ctx-cat-delete');
            const upItem = document.getElementById('ctx-cat-move-up');
            const downItem = document.getElementById('ctx-cat-move-down');

            editItem.onclick = () => {
                hideCategoryContextMenu();
                openEditCategoryModal(catKey);
            };

            deleteItem.onclick = async () => {
                hideCategoryContextMenu();
                const ok = await showConfirm(`确定要删除分类"${catKey}"吗？分类下的所有标签也将被删除。`, '删除确认');
                if (ok) {
                    delete commonData[catKey];
                    saveCommonData();
                    renderSidebar();
                }
            };

            upItem.onclick = () => {
                hideCategoryContextMenu();
                moveCategoryUp(catKey);
            };

            downItem.onclick = () => {
                hideCategoryContextMenu();
                moveCategoryDown(catKey);
            };
        }

        function hideCategoryContextMenu() {
            categoryContextMenu.style.display = 'none';
            currentContextCategory = null;
        }

        // 点击其他地方关闭右键菜单
        document.addEventListener('click', (e) => {
            if (!categoryContextMenu.contains(e.target)) {
                hideCategoryContextMenu();
            }
        });

        // 编辑分类模态框
        function openEditCategoryModal(oldName) {
            const wrap = document.getElementById('modal-edit-category');
            const input = document.getElementById('modal-edit-cat-name');
            const confirmBtn = document.getElementById('modal-edit-cat-confirm');
            const cancelBtn = document.getElementById('modal-edit-cat-cancel');
            const closeBtn = document.getElementById('modal-edit-cat-close');
            input.value = oldName || '';
            show(wrap);
            setTimeout(() => input.focus(), 0);

            const onConfirm = () => {
                const newName = (input.value || '').trim();
                if (!newName) { input.focus(); return; }
                if (newName !== oldName) {
                    if (commonData[newName]) {
                        showInfo('已存在同名分类', '提示');
                        return;
                    }
                    const items = commonData[oldName] || [];
                    delete commonData[oldName];
                    commonData[newName] = items;
                    saveCommonData();
                    setActiveCategory(newName);
                    renderSidebar();
                }
                cleanup();
            };
            const onCancel = () => cleanup();

            function cleanup() {
                confirmBtn.removeEventListener('click', onConfirm);
                cancelBtn.removeEventListener('click', onCancel);
                closeBtn.removeEventListener('click', onCancel);
                input.removeEventListener('keydown', onKey);
                hide(wrap);
            }
            function onKey(e) {
                if (e.key === 'Enter') onConfirm();
                if (e.key === 'Escape') onCancel();
            }

            confirmBtn.addEventListener('click', onConfirm);
            cancelBtn.addEventListener('click', onCancel);
            closeBtn.addEventListener('click', onCancel);
            input.addEventListener('keydown', onKey);
        }

        // 侧栏分类拖拽排序逻辑
        let catDraggedKey = null;
        let catPlaceholderEl = null;

        function handleCatDragStart(e) {
            const key = this.getAttribute('data-cat') || '';
            catDraggedKey = key || null;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', key);
        }

        function handleCatDragEnd(e) {
            this.classList.remove('dragging');
            document.querySelectorAll('.prompt-card').forEach(card => card.classList.remove('dragging'));
            if (catPlaceholderEl && catPlaceholderEl.parentNode) {
                catPlaceholderEl.parentNode.removeChild(catPlaceholderEl);
            }
            catPlaceholderEl = null;
            catDraggedKey = null;
        }

        function getCatInsertIndexByPoint(y) {
            const items = Array.from(sidebarList.querySelectorAll('.prompt-card'));
            if (!items.length) return 0;
            // 找到垂直位置最近的卡片
            let anchor = items[items.length - 1];
            let minDist = Infinity;
            items.forEach(el => {
                const r = el.getBoundingClientRect();
                const cy = r.top + r.height / 2;
                const d = Math.abs(y - cy);
                if (d < minDist) { minDist = d; anchor = el; }
            });
            const r = anchor.getBoundingClientRect();
            const mid = r.top + r.height / 2;
            const baseIdx = items.indexOf(anchor);
            return y < mid ? baseIdx : baseIdx + 1;
        }

        function onSidebarDragOver(e) {
            if (!catDraggedKey) return false;
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            if (!catPlaceholderEl) {
                catPlaceholderEl = document.createElement('div');
                catPlaceholderEl.style.height = '10px';
                catPlaceholderEl.style.margin = '6px 12px';
                catPlaceholderEl.style.borderRadius = '4px';
                catPlaceholderEl.style.background = 'var(--primary-color)';
            }
            const idx = getCatInsertIndexByPoint(e.clientY);
            const cards = Array.from(sidebarList.querySelectorAll('.prompt-card'));
            if (idx >= cards.length) {
                if (catPlaceholderEl.parentNode !== sidebarList || catPlaceholderEl.nextElementSibling !== null) {
                    sidebarList.appendChild(catPlaceholderEl);
                }
            } else {
                const ref = cards[idx];
                if (ref.previousSibling !== catPlaceholderEl) {
                    sidebarList.insertBefore(catPlaceholderEl, ref);
                }
            }
            return false;
        }

        function onSidebarDrop(e) {
            if (!catDraggedKey) return false;
            e.preventDefault();
            e.stopPropagation();

            const keys = Object.keys(commonData);
            const fromIndex = keys.indexOf(catDraggedKey);

            // 优先使用占位条位置确定目标索引
            let toIndex = -1;
            if (catPlaceholderEl && sidebarList.contains(catPlaceholderEl)) {
                const cards = Array.from(sidebarList.querySelectorAll('.prompt-card'));
                let countBefore = 0;
                for (const node of sidebarList.children) {
                    if (node === catPlaceholderEl) break;
                    if (node.classList && node.classList.contains('prompt-card')) countBefore++;
                }
                toIndex = countBefore;
            } else {
                // 回退：用坐标估算
                toIndex = getCatInsertIndexByPoint(e.clientY);
            }

            if (fromIndex >= 0 && toIndex >= 0 && fromIndex !== toIndex) {
                // 拖起位置在目标之前时，移除后目标索引左移一位
                if (fromIndex < toIndex) toIndex -= 1;
                const newKeys = keys.slice();
                newKeys.splice(fromIndex, 1);
                newKeys.splice(Math.max(0, Math.min(toIndex, newKeys.length)), 0, catDraggedKey);

                const reordered = {};
                newKeys.forEach(k => { reordered[k] = commonData[k]; });
                commonData = reordered;
                saveCommonData();
                renderSidebar();
            }

            if (catPlaceholderEl && catPlaceholderEl.parentNode) {
                catPlaceholderEl.parentNode.removeChild(catPlaceholderEl);
            }
            catPlaceholderEl = null;
            catDraggedKey = null;

            return false;
        }

        function getActiveCategory() {
            try { return localStorage.getItem('ops_active_cat') || ''; } catch(e) { return ''; }
        }
        function setActiveCategory(key) {
            try { localStorage.setItem('ops_active_cat', key || ''); } catch(e) {}
        }

        // 已废弃：不再使用 | 分隔输入
        // function parseTagInput() {}

        function addCategory() {
            openCategoryModal();
        }

        function addTagToCurrent() {
            const cat = getActiveCategory();
            if (!cat) return showInfo('请先创建或选择一个分类', '提示');
            openTagModal(cat);
        }

        function getDropboxToken() {
            try { return localStorage.getItem('ops_dbx_token') || ''; } catch(e) { return ''; }
        }
        // 固定 Dropbox 应用参数
        const DBX_APP_KEY = '5rf7xfl3li2j3tw';
        const DBX_APP_SECRET = 'kjmbl4fcp68gqz9';
        function getDropboxConfig() {
            try {
                return {
                    key: DBX_APP_KEY,
                    secret: DBX_APP_SECRET,
                    token: localStorage.getItem('ops_dbx_token') || '',
                    refresh: localStorage.getItem('ops_dbx_refresh') || ''
                };
            } catch(e) { return { key: DBX_APP_KEY, secret: DBX_APP_SECRET, token:'', refresh:'' }; }
        }
        function getDropboxSelectedFilename() {
            try {
                const v = localStorage.getItem('ops_dbx_filename');
                return v && v.trim() ? v.trim() : '/' + DEFAULT_JSON_FILENAME;
            } catch(e) { return '/' + DEFAULT_JSON_FILENAME; }
        }
        function isDropboxEnabled() {
            try { return localStorage.getItem('ops_cloud_enabled') === '1'; } catch(e) { return false; }
        }

        // ========== S3 密钥加密/解密功能 ==========
        // 生成加密密钥（基于固定盐值和用户设备特征）
        async function getEncryptionKey(userPassword) {
            if (!userPassword) {
                throw new Error('需要输入密码');
            }
            // 使用用户输入的密码派生密钥
            const salt = new TextEncoder().encode('PromptStudio_S3_Encryption_Salt_2024');
            const keyMaterial = await window.crypto.subtle.importKey(
                'raw',
                new TextEncoder().encode(userPassword),
                'PBKDF2',
                false,
                ['deriveKey']
            );
            return window.crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: 100000,
                    hash: 'SHA-256'
                },
                keyMaterial,
                { name: 'AES-GCM', length: 256 },
                false,
                ['encrypt', 'decrypt']
            );
        }

        // 加密数据
        async function encryptData(plaintext, userPassword) {
            try {
                const key = await getEncryptionKey(userPassword);
                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                const encoded = new TextEncoder().encode(plaintext);
                const encrypted = await window.crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    encoded
                );
                // 将 IV 和加密数据合并并转换为 Base64
                const combined = new Uint8Array(iv.length + encrypted.byteLength);
                combined.set(iv);
                combined.set(new Uint8Array(encrypted), iv.length);
                return btoa(String.fromCharCode.apply(null, combined));
            } catch(e) {
                console.error('加密失败:', e);
                throw e;
            }
        }

        // 解密数据
        async function decryptData(ciphertext, userPassword) {
            try {
                const key = await getEncryptionKey(userPassword);
                const combined = Uint8Array.from(atob(ciphertext), c => c.charCodeAt(0));
                const iv = combined.slice(0, 12);
                const encrypted = combined.slice(12);
                const decrypted = await window.crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    encrypted
                );
                return new TextDecoder().decode(decrypted);
            } catch(e) {
                throw new Error('密码错误或数据已损坏');
            }
        }

        // S3 (腾讯云 COS) 配置(获取加密数据)
        async function getS3Config() {
            return {
                secretId: localStorage.getItem('ops_s3_secret_id') || '',
                secretKey: localStorage.getItem('ops_s3_secret_key') || '',
                region: localStorage.getItem('ops_s3_region') || '',
                bucket: localStorage.getItem('ops_s3_bucket') || ''
            };
        }

        // 解密 S3 配置
        async function decryptS3Config(encryptedConfig, password) {
            try {
                let secretId = '';
                let secretKey = '';
                let region = encryptedConfig.region || '';
                let bucket = encryptedConfig.bucket || '';

                if (encryptedConfig.secretId) {
                    secretId = await decryptData(encryptedConfig.secretId, password);
                }
                if (encryptedConfig.secretKey) {
                    secretKey = await decryptData(encryptedConfig.secretKey, password);
                }
                if (encryptedConfig.region) {
                    region = await decryptData(encryptedConfig.region, password);
                }
                if (encryptedConfig.bucket) {
                    bucket = await decryptData(encryptedConfig.bucket, password);
                }

                return {
                    secretId: secretId,
                    secretKey: secretKey,
                    region: region,
                    bucket: bucket
                };
            } catch(e) {
                console.error('解密 S3 配置失败:', e);
                throw new Error('密码错误或数据已损坏');
            }
        }

        // 显示密码输入框并返回密码
        function showPasswordModal() {
            return new Promise((resolve) => {
                const modal = document.getElementById('modal-s3-password');
                const input = document.getElementById('modal-password-input');
                const confirmBtn = document.getElementById('modal-password-confirm');
                const cancelBtn = document.getElementById('modal-password-cancel');

                // 清空输入框
                input.value = '';

                // 显示模态框
                modal.style.display = 'flex';

                // 自动聚焦
                setTimeout(() => input.focus(), 100);

                // 确定按钮
                const onConfirm = () => {
                    const password = input.value.trim();
                    modal.style.display = 'none';
                    cleanup();
                    resolve(password || null);
                };

                // 取消按钮
                const onCancel = () => {
                    modal.style.display = 'none';
                    cleanup();
                    resolve(null);
                };

                // 回车键确认，ESC键取消
                const onEnter = (e) => {
                    if (e.key === 'Enter') {
                        onConfirm();
                    } else if (e.key === 'Escape') {
                        onCancel();
                    }
                };

                // 清理事件监听
                const cleanup = () => {
                    confirmBtn.removeEventListener('click', onConfirm);
                    cancelBtn.removeEventListener('click', onCancel);
                    input.removeEventListener('keydown', onEnter);
                };

                confirmBtn.addEventListener('click', onConfirm);
                cancelBtn.addEventListener('click', onCancel);
                input.addEventListener('keydown', onEnter);
            });
        }

        // ==================== S3 文件配置管理 ====================

        function getS3Configs() {
            try {
                const raw = localStorage.getItem(S3_CONFIGS_KEY);
                const configs = raw ? JSON.parse(raw) : [];
                // 确保默认配置存在
                const hasDefault = configs.some(c => c.name === '默认');
                if (!hasDefault) {
                    configs.unshift({ name: '默认', filename: DEFAULT_JSON_FILENAME });
                    localStorage.setItem(S3_CONFIGS_KEY, JSON.stringify(configs));
                }
                return Array.isArray(configs) ? configs : [{ name: '默认', filename: DEFAULT_JSON_FILENAME }];
            } catch(e) {
                return [{ name: '默认', filename: DEFAULT_JSON_FILENAME }];
            }
        }

        function saveS3Configs(configs) {
            try {
                localStorage.setItem(S3_CONFIGS_KEY, JSON.stringify(configs));
            } catch(e) {}
        }

        function getSelectedS3Config() {
            try {
                const selected = localStorage.getItem(S3_SELECTED_CONFIG_KEY);
                if (selected) return selected;
                return '默认';
            } catch(e) {
                return '默认';
            }
        }

        function setSelectedS3Config(name) {
            try {
                localStorage.setItem(S3_SELECTED_CONFIG_KEY, name);
            } catch(e) {}
        }

        function getS3SelectedFilename() {
            try {
                const selectedName = getSelectedS3Config();
                const configs = getS3Configs();
                const config = configs.find(c => c.name === selectedName);
                if (config && config.filename) {
                    return config.filename;
                }
                return DEFAULT_JSON_FILENAME;
            } catch(e) { return DEFAULT_JSON_FILENAME; }
        }

        function isS3Enabled() {
            try { return localStorage.getItem('ops_cloud_enabled') === '1'; } catch(e) { return false; }
        }
        function isCloudEnabled() {
            try { return localStorage.getItem('ops_cloud_enabled') === '1'; } catch(e) { return false; }
        }

        // 同步配置
        function getSyncProvider() {
            try { return localStorage.getItem('sync_provider') || 'dropbox'; } catch(e) { return 'dropbox'; }
        }
        function setSyncProvider(provider) {
            try { localStorage.setItem('sync_provider', provider || 'dropbox'); } catch(e) {}
        }
        function getCloudSelectedFilename() {
            const provider = getSyncProvider();
            if (provider === 's3') return getS3SelectedFilename();
            return getDropboxSelectedFilename();
        }
        async function uploadToDropbox(filename, contentStr) {
            const { token } = getDropboxConfig();
            if (!token) throw new Error('未配置 Dropbox Access Token');
            const isAscii = (s) => { try { return /^[\x00-\x7F]+$/.test(s); } catch(_) { return true; } };
            const target = filename.startsWith('/') ? filename : '/' + filename;

            // ASCII 文件名：直接上传（请求头可用）
            if (isAscii(target)) {
                const res = await fetch('https://content.dropboxapi.com/2/files/upload', {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Bearer ' + token,
                        'Content-Type': 'application/octet-stream',
                        'Dropbox-API-Arg': JSON.stringify({
                            path: target,
                            mode: 'overwrite',
                            mute: true,
                            autorename: false
                        })
                    },
                    body: new TextEncoder().encode(contentStr)
                });
                if (!res.ok) throw new Error('上传失败 HTTP ' + res.status);
                return res.json();
            }

            // 非 ASCII 文件名：两步法
            const tempPath = '/OHAOAI.upload.tmp.json'; // ASCII 临时文件名
            // 1) 先上传到临时路径
            const upRes = await fetch('https://content.dropboxapi.com/2/files/upload', {
                method: 'POST',
                headers: {
                    'Authorization': 'Bearer ' + token,
                    'Content-Type': 'application/octet-stream',
                    'Dropbox-API-Arg': JSON.stringify({
                        path: tempPath,
                        mode: 'overwrite',
                        mute: true,
                        autorename: false
                    })
                },
                body: new TextEncoder().encode(contentStr)
            });
            if (!upRes.ok) throw new Error('上传临时文件失败 HTTP ' + upRes.status);

            // 2) 若目标已存在，先删除（避免 move 冲突）
            try {
                await fetch('https://api.dropboxapi.com/2/files/delete_v2', {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Bearer ' + token,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ path: target })
                });
            } catch (_) { /* 忽略删除失败 */ }

            // 3) 将临时文件移动到目标路径（JSON 请求体可含非 ASCII）
            const mvRes = await fetch('https://api.dropboxapi.com/2/files/move_v2', {
                method: 'POST',
                headers: {
                    'Authorization': 'Bearer ' + token,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ from_path: tempPath, to_path: target, autorename: false })
            });
            if (!mvRes.ok) {
                let msg = 'HTTP ' + mvRes.status;
                try { const j = await mvRes.json(); msg += ' ' + (j.error_summary || JSON.stringify(j)); } catch(_) {}
                throw new Error('移动到目标文件失败：' + msg);
            }
            return mvRes.json();
        }
        async function downloadFromDropbox(filename) {
            const { token } = getDropboxConfig();
            if (!token) throw new Error('未配置 Dropbox Access Token');
            const isAscii = (s) => { try { return /^[\x00-\x7F]+$/.test(s); } catch(_) { return true; } };
            if (!isAscii(filename)) {
                // 非 ASCII：改用临时链接方式获取文件
                const metaRes = await fetch('https://api.dropboxapi.com/2/files/get_temporary_link', {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Bearer ' + token,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ path: filename.startsWith('/') ? filename : '/' + filename })
                });
                if (!metaRes.ok) {
                    let msg = 'HTTP ' + metaRes.status;
                    try { const j = await metaRes.json(); msg += ' ' + (j.error_summary || JSON.stringify(j)); } catch(_) {}
                    throw new Error('获取临时链接失败：' + msg);
                }
                const j = await metaRes.json();
                const link = j && j.link;
                if (!link) throw new Error('未获取到临时下载链接');
                const fileRes = await fetch(link);
                if (!fileRes.ok) throw new Error('下载失败 HTTP ' + fileRes.status);
                return fileRes.text();
            }
            // ASCII：走标准 content 下载接口
            const res = await fetch('https://content.dropboxapi.com/2/files/download', {
                method: 'POST',
                headers: {
                    'Authorization': 'Bearer ' + token,
                    'Dropbox-API-Arg': JSON.stringify({
                        path: filename.startsWith('/') ? filename : '/' + filename
                    })
                }
            });
            if (!res.ok) throw new Error('下载失败 HTTP ' + res.status);
            return res.text();
        }

        // S3 (腾讯云 COS) 上传函数 - 使用官方 SDK
        async function uploadToS3(filename, contentStr) {
            const encryptedConfig = await getS3Config();
            if (!encryptedConfig.secretId || !encryptedConfig.secretKey || !encryptedConfig.region || !encryptedConfig.bucket) {
                throw new Error('未配置 S3 信息');
            }

            // 提示用户输入密码
            const password = await showPasswordModal();
            if (!password) {
                throw new Error('需要密码');
            }

            const { secretId, secretKey, region, bucket } = await decryptS3Config(encryptedConfig, password);

            // 初始化 COS 客户端 - 使用永久密钥方式
            const cos = new COS({
                SecretId: secretId,
                SecretKey: secretKey
            });

            // 构造上传路径：Prompt Studio/filename
            const key = `Prompt Studio/${filename}`;

            return new Promise((resolve, reject) => {
                cos.putObject({
                    Bucket: bucket,
                    Region: region,
                    Key: key,
                    Body: contentStr,
                    ContentType: 'application/json'
                }, function (err, data) {
                    if (err) {
                        reject(new Error(`S3 上传失败：${err.message || err}`));
                    } else {
                        resolve(data);
                    }
                });
            });
        }



        // S3 (腾讯云 COS) 下载函数 - 使用官方 SDK
        async function downloadFromS3(filename) {
            const encryptedConfig = await getS3Config();
            if (!encryptedConfig.secretId || !encryptedConfig.secretKey || !encryptedConfig.region || !encryptedConfig.bucket) {
                throw new Error('未配置 S3 信息');
            }

            // 提示用户输入密码
            const password = await showPasswordModal();
            if (!password) {
                throw new Error('需要密码');
            }

            const { secretId, secretKey, region, bucket } = await decryptS3Config(encryptedConfig, password);

            // 初始化 COS 客户端 - 使用永久密钥方式
            const cos = new COS({
                SecretId: secretId,
                SecretKey: secretKey
            });

            // 构造下载路径：Prompt Studio/filename
            const key = `Prompt Studio/${filename}`;

            return new Promise((resolve, reject) => {
                cos.getObject({
                    Bucket: bucket,
                    Region: region,
                    Key: key
                }, function (err, data) {
                    if (err) {
                        reject(new Error(`S3 下载失败：${err.message || err}`));
                    } else {
                        resolve(data.Body);
                    }
                });
            });
        }

        // 内部上传函数 - 使用已解密的配置（不弹出密码输入框）
        async function uploadToS3Internal(filename, contentStr, secretId, secretKey, region, bucket) {
            // 初始化 COS 客户端 - 使用永久密钥方式
            const cos = new COS({
                SecretId: secretId,
                SecretKey: secretKey
            });

            // 构造上传路径：Prompt Studio/filename
            const key = `Prompt Studio/${filename}`;

            return new Promise((resolve, reject) => {
                cos.putObject({
                    Bucket: bucket,
                    Region: region,
                    Key: key,
                    Body: contentStr,
                    ContentType: 'application/json'
                }, function (err, data) {
                    if (err) {
                        reject(new Error(`S3 上传失败：${err.message || err}`));
                    } else {
                        resolve(data);
                    }
                });
            });
        }

        // 内部下载函数 - 使用已解密的配置（不弹出密码输入框）
        async function downloadFromS3Internal(filename, secretId, secretKey, region, bucket) {
            // 初始化 COS 客户端 - 使用永久密钥方式
            const cos = new COS({
                SecretId: secretId,
                SecretKey: secretKey
            });

            // 构造下载路径：Prompt Studio/filename
            const key = `Prompt Studio/${filename}`;

            return new Promise((resolve, reject) => {
                cos.getObject({
                    Bucket: bucket,
                    Region: region,
                    Key: key
                }, function (err, data) {
                    if (err) {
                        reject(new Error(`S3 下载失败：${err.message || err}`));
                    } else {
                        resolve(data.Body);
                    }
                });
            });
        }

        // ========== 统一的数据导出/导入管理 ==========

        // 导出完整数据对象（包含常用提示词、历史记录、菜单、触发词）
        function exportFullDataObject() {
            return {
                common: commonData || {},
                history: (function(){ try { const raw = localStorage.getItem('ops_prompt_history'); const arr = raw ? JSON.parse(raw) : []; return Array.isArray(arr) ? arr : []; } catch(e){ return []; } })(),
                menus: (function(){ try { const raw = localStorage.getItem('ops_ctx_menu_items'); const arr = raw ? JSON.parse(raw) : []; return Array.isArray(arr) ? arr : []; } catch(e){ return []; } })(),
                triggerWords: {
                    prefix: localStorage.getItem('ops_prefix_trigger_zh') || '',
                    suffix: localStorage.getItem('ops_suffix_trigger_zh') || ''
                }
            };
        }

        // 统一上传函数 - 根据provider选择对应的云存储
        async function uploadToCloud(filename, dataStr, provider) {
            if (provider === 's3') {
                return await uploadToS3(filename, dataStr);
            } else {
                return await uploadToDropbox(filename, dataStr);
            }
        }

        // 统一下载函数 - 根据provider选择对应的云存储
        async function downloadFromCloud(filename, provider) {
            if (provider === 's3') {
                return await downloadFromS3(filename);
            } else {
                return await downloadFromDropbox(filename);
            }
        }

        // 下载JSON - 支持本地下载或云端上传
        async function downloadJson() {
            const exportObj = exportFullDataObject();
            const dataStr = JSON.stringify(exportObj, null, 2);
            const useCloud = isCloudEnabled();
            const provider = getSyncProvider();

            if (useCloud) {
                const filename = getCloudSelectedFilename();
                if (provider === 's3') {
                    const s3Config = await getS3Config();
                    if (!s3Config.secretId || !s3Config.secretKey || !s3Config.region || !s3Config.bucket) {
                        showInfo('未配置 S3 信息，请在同步配置中填写。', '提示');
                        return;
                    }
                    uploadToCloud(filename, dataStr, provider)
                        .then(() => showInfo('已上传到 S3: ' + filename, '上传成功'))
                        .catch(err => showInfo('S3 上传失败：' + (err?.message || err), '上传失败'));
                } else {
                    const { token } = getDropboxConfig();
                    if (!token) { showInfo('未登录 Dropbox，请先在同步配置中完成登录。', '提示'); return; }
                    uploadToCloud(filename, dataStr, provider)
                        .then(() => showInfo('已上传到 Dropbox: ' + filename, '上传成功'))
                        .catch(err => showInfo('Dropbox 上传失败：' + (err?.message || err), '上传失败'));
                }
                return;
            }
            // 本地下载
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = DEFAULT_JSON_FILENAME;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // 统一导入函数 - 支持合并或替换模式
        async function importJsonText(text, showNotification = true, clearExisting = false) {
            const data = JSON.parse(text);
            if (!data || typeof data !== 'object') throw new Error('无效JSON');

            // 兼容三种结构：
            // 1) 纯旧版：{ 分类: [数组] }
            // 2) 新版封装：{ common: {...}, history: [...] }
            // 3) 分组版：{ 分类: { groups: { 子类: [数组] } } }
            let nextCommon = {};
            let nextHistory = [];
            let nextMenus = Array.isArray(data?.menus) ? data.menus : null;
            let nextTriggerWords = data?.triggerWords || null;

            function importCategoryValue(val) {
                if (Array.isArray(val)) {
                    return val.map(x => ({
                        text: (x?.text || '').trim(),
                        lang_zh: (x?.lang_zh || '').trim() || (x?.text || '').trim(),
                        pinned: !!x?.pinned,
                        related: (x?.related || '').trim(),
                        style: x?.style || 'default'
                    })).filter(x => x.text);
                }
                if (isGroupedCategory(val)) {
                    const out = { groups: {} };
                    const g = val.groups || {};
                    Object.keys(g).forEach(sub => {
                        out.groups[sub] = (Array.isArray(g[sub]) ? g[sub] : []).map(x => ({
                            text: (x?.text || '').trim(),
                            lang_zh: (x?.lang_zh || '').trim() || (x?.text || '').trim(),
                            pinned: !!x?.pinned,
                            related: (x?.related || '').trim(),
                            style: x?.style || 'default'
                        })).filter(x => x.text);
                    });
                    return out;
                }
                return [];
            }

            if (data.common && typeof data.common === 'object') {
                const src = data.common || {};
                Object.keys(src).forEach(k => {
                    nextCommon[k] = importCategoryValue(src[k]);
                });
                if (Array.isArray(data.history)) {
                    nextHistory = data.history
                        .map(x => ({ ts: Number(x?.ts) || Date.now(), text: String(x?.text || '').trim() }))
                        .filter(x => x.text);
                }
            } else {
                Object.keys(data).forEach(k => {
                    nextCommon[k] = importCategoryValue(data[k]);
                });
            }

            // 如果是替换模式，清空现有数据
            if (clearExisting) {
                commonData = nextCommon;
                try { localStorage.setItem('ops_prompt_history', JSON.stringify(nextHistory)); } catch(e) {}
                if (Array.isArray(nextMenus)) {
                    try { localStorage.setItem('ops_ctx_menu_items', JSON.stringify(nextMenus)); } catch(e) {}
                }
            } else {
                // 合并模式：合并common、history、menus
                Object.keys(nextCommon).forEach(k => {
                    commonData[k] = nextCommon[k];
                });
                if (nextHistory.length) {
                    const existing = (function(){ try { const raw = localStorage.getItem('ops_prompt_history'); const arr = raw ? JSON.parse(raw) : []; return Array.isArray(arr) ? arr : []; } catch(e){ return []; } })();
                    const merged = [...nextHistory, ...existing];
                    try { localStorage.setItem('ops_prompt_history', JSON.stringify(merged)); } catch(e) {}
                }
                if (Array.isArray(nextMenus)) {
                    try { localStorage.setItem('ops_ctx_menu_items', JSON.stringify(nextMenus)); } catch(e) {}
                }
            }

            // 导入触发词设置
            if (nextTriggerWords && typeof nextTriggerWords === 'object') {
                try {
                    if (nextTriggerWords.prefix !== undefined) {
                        localStorage.setItem('ops_prefix_trigger_zh', String(nextTriggerWords.prefix));
                    }
                    if (nextTriggerWords.suffix !== undefined) {
                        localStorage.setItem('ops_suffix_trigger_zh', String(nextTriggerWords.suffix));
                    }
                } catch(e) {}
            }
            saveCommonData();
            renderSidebar();
            if (showNotification) {
                const modeText = clearExisting ? '（替换模式）' : '（合并模式）';
                showInfo('JSON 导入完成' + modeText + (nextHistory.length ? '，含历史' : ''), '导入成功');
            }
        }

        async function importJsonFile(file) {
            try {
                const text = await file.text();
                await importJsonText(text);
                // 提示成功可选
            } catch (e) {
                showInfo('导入失败：' + (e?.message || e), '导入失败');
            }
        }

        async function importFromDropbox() {
            try {
                const filename = getDropboxSelectedFilename();
                const text = await downloadFromCloud(filename, 'dropbox');
                await importJsonText(text, false, false); // 使用默认的合并模式
                showInfo('已从 Dropbox 导入 ' + filename, '导入成功');
            } catch (e) {
                showInfo('从 Dropbox 下载失败：' + (e?.message || e), '下载失败');
            }
        }

        async function importFromS3() {
            try {
                const filename = getS3SelectedFilename();
                const text = await downloadFromCloud(filename, 's3');
                await importJsonText(text, false, false); // 使用默认的合并模式
                showInfo('已从 S3 导入 ' + filename, '导入成功');
            } catch (e) {
                showInfo('从 S3 下载失败：' + (e?.message || e), '下载失败');
            }
        }

        async function importFromCloud() {
            const provider = getSyncProvider();
            if (provider === 's3') {
                const s3Config = await getS3Config();
                if (!s3Config.secretId || !s3Config.secretKey || !s3Config.region || !s3Config.bucket) {
                    showInfo('未配置 S3 信息，请在同步配置中填写。', '提示');
                    return;
                }
                await importFromS3();
            } else {
                const { token } = getDropboxConfig();
                if (!token) {
                    showInfo('未登录 Dropbox，请先在同步配置中完成登录。', '提示');
                    return;
                }
                await importFromDropbox();
            }
        }

        // ==================== 首次打开提示 ====================
        async function maybePromptDefaultImport() {
            try {
                const done = localStorage.getItem(ONBOARD_KEY) === '1';
                const hasData = commonData && Object.keys(commonData).length > 0;
                if (done || hasData) return;
            } catch (_) {
                // 若 localStorage 不可用，直接跳过
                return;
            }
            try {
                const ok = await showConfirm(
                    `是否导入默认测试数据？`,
                    '导入默认数据'
                );
                // 无论选择与否，都写入一次性标记，下次不再提醒
                try { localStorage.setItem(ONBOARD_KEY, '1'); } catch(_) {}
                if (!ok) return;

                // 从同目录读取默认测试数据
                const res = await fetch(DEFAULT_JSON_FILENAME);
                if (!res.ok) throw new Error('HTTP ' + res.status);
                const text = await res.text();
                await importJsonText(text);
            } catch (err) {
                showInfo('导入默认数据失败：' + (err?.message || err), '导入失败');
            }
        }

        // 导出 #prompt-tags-container 为图片并下载
        async function ensureHtml2Canvas() {
            if (window.html2canvas) return window.html2canvas;
            await new Promise((resolve, reject) => {
                const s = document.createElement('script');
                s.src = 'https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js';
                s.onload = () => resolve();
                s.onerror = () => reject(new Error('加载 html2canvas 失败'));
                document.head.appendChild(s);
            });
            return window.html2canvas;
        }
        async function renderPromptTagsToCanvas() {
            const el = document.getElementById('prompt-tags-container');
            if (!el) throw new Error('未找到提示词区域');
            const html2canvas = await ensureHtml2Canvas();
            const prev = {
                background: el.style.background,
                backgroundColor: el.style.backgroundColor,
                border: el.style.border,
                boxShadow: el.style.boxShadow
            };
            el.style.background = 'transparent';
            el.style.backgroundColor = 'transparent';
            el.style.border = 'none';
            el.style.boxShadow = 'none';
            const scale = Math.max(2, (window.devicePixelRatio || 1) * 2);
            try {
                return await html2canvas(el, {
                    backgroundColor: null,
                    scale,
                    useCORS: true
                });
            } finally {
                el.style.background = prev.background;
                el.style.backgroundColor = prev.backgroundColor;
                el.style.border = prev.border;
                el.style.boxShadow = prev.boxShadow;
            }
        }

        async function exportPromptTagsImage() {
            try {
                const canvas = await renderPromptTagsToCanvas();
                const dataUrl = canvas.toDataURL('image/png');
                const a = document.createElement('a');
                a.href = dataUrl;
                a.download = "Prompt Studio.png";
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            } catch (e) {
                showInfo('生成图片失败：' + (e?.message || e), '失败');
            }
        }

        async function composeTagsImageOntoSelectedImage() {
            try {
                const canvas = await renderPromptTagsToCanvas();
                const tagsBlob = await new Promise((resolve) => canvas.toBlob(resolve, 'image/png'));
                if (!tagsBlob) throw new Error('生成提示词图片失败');
                const baseFile = await pickBaseImageFile();
                if (!baseFile) return;
                const composedBlob = await composeImages(baseFile, tagsBlob);
                await offerComposedImageDownload(composedBlob);
            } catch (e) {
                showInfo('合成失败：' + (e?.message || e), '失败');
            }
        }

        async function pickBaseImageFile() {
            return new Promise((resolve) => {
                let input = document.getElementById('compose-image-file-input');
                if (!input) {
                    input = document.createElement('input');
                    input.type = 'file';
                    input.id = 'compose-image-file-input';
                    input.accept = 'image/*';
                    input.style.display = 'none';
                    document.body.appendChild(input);
                }
                const handler = () => {
                    input.removeEventListener('change', handler);
                    const file = input.files && input.files[0];
                    input.value = '';
                    resolve(file || null);
                };
                input.addEventListener('change', handler);
                input.click();
            });
        }

        async function composeImages(baseFile, overlayBlob) {
            const [baseImage, overlayImage] = await Promise.all([
                loadImageFromFile(baseFile),
                loadImageFromBlob(overlayBlob)
            ]);

            const composedCanvas = document.createElement('canvas');
            composedCanvas.width = baseImage.width;
            composedCanvas.height = baseImage.height;
            const ctx = composedCanvas.getContext('2d');
            if (!ctx) throw new Error('无法创建画布');
            ctx.drawImage(baseImage, 0, 0);

            const overlaySize = calculateOverlaySizeAndPosition(baseImage, overlayImage);
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(
                overlayImage,
                overlaySize.x,
                overlaySize.y,
                overlaySize.width,
                overlaySize.height
            );

            return await new Promise((resolve, reject) => {
                composedCanvas.toBlob((blob) => {
                    if (!blob) reject(new Error('导出合成图片失败'));
                    else resolve(blob);
                }, 'image/png');
            });
        }

        function calculateOverlaySizeAndPosition(baseImage, overlayImage) {
            const MIN_OVERLAY_WIDTH = 512;
            const isLandscape = baseImage.width > baseImage.height;
            const maxWidth = baseImage.width;
            const maxHeight = baseImage.height;

            let targetWidth;
            if (isLandscape) {
                const halfWidth = baseImage.width / 2;
                const preferredWidth = Math.min(MIN_OVERLAY_WIDTH, maxWidth);
                targetWidth = Math.max(halfWidth, preferredWidth);
            } else {
                targetWidth = maxWidth;
            }

            let scale = targetWidth / overlayImage.width;
            let targetHeight = overlayImage.height * scale;

            if (targetHeight > maxHeight) {
                const heightScale = maxHeight / targetHeight;
                targetHeight = maxHeight;
                targetWidth = targetWidth * heightScale;
                scale *= heightScale;
            }

            return {
                width: targetWidth,
                height: targetHeight,
                x: 0,
                y: maxHeight - targetHeight
            };
        }

        function loadImageFromFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    if (typeof reader.result !== 'string') {
                        reject(new Error('读取图片失败'));
                        return;
                    }
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = () => reject(new Error('载入图片失败'));
                    img.src = reader.result;
                };
                reader.onerror = () => reject(new Error('读取图片失败'));
                reader.readAsDataURL(file);
            });
        }

        function loadImageFromBlob(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    if (typeof reader.result !== 'string') {
                        reject(new Error('读取图片失败'));
                        return;
                    }
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = () => reject(new Error('载入图片失败'));
                    img.src = reader.result;
                };
                reader.onerror = () => reject(new Error('读取图片失败'));
                reader.readAsDataURL(blob);
            });
        }

        async function offerComposedImageDownload(blob) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'Prompt Studio 合成图.png';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function setupUIEvents() {
            document.getElementById('add-category-btn')?.addEventListener('click', addCategory);
            document.getElementById('add-tag-btn')?.addEventListener('click', addTagToCurrent);
            document.getElementById('export-tags-image-btn')?.addEventListener('click', exportPromptTagsImage);
            document.getElementById('compose-tags-image-btn')?.addEventListener('click', composeTagsImageOntoSelectedImage);
            document.getElementById('download-json-btn')?.addEventListener('click', async () => await downloadJson());
            document.getElementById('reset-all-btn')?.addEventListener('click', resetAll);
            document.getElementById('random-pick-btn')?.addEventListener('click', randomPickAll);
            document.getElementById('import-json-btn')?.addEventListener('click', async () => {
                const useCloud = isCloudEnabled();
                if (useCloud) {
                    await importFromCloud();
                } else {
                    document.getElementById('json-file-input')?.click();
                }
            });
            document.getElementById('sync-config-btn')?.addEventListener('click', openSyncModal);
            document.getElementById('json-file-input')?.addEventListener('change', (e) => {
                const file = e.target.files && e.target.files[0];
                if (file) importJsonFile(file);
                e.target.value = '';
            });

            // 新增：存储与查看
            document.getElementById('save-prompt-btn')?.addEventListener('click', savePromptSnapshot);
            document.getElementById('view-history-btn')?.addEventListener('click', openHistoryModal);
        }

        function openSyncModal() {
            const wrap = document.getElementById('modal-sync');
            const providerBtns = document.querySelectorAll('#sync-provider-buttons .btn-toggle');
            const dropboxConfig = document.getElementById('sync-dropbox-config');
            const s3Config = document.getElementById('sync-s3-config');
            const dropboxFooter = document.getElementById('sync-footer-dropbox');
            const s3Footer = document.getElementById('sync-footer-s3');
            const closeBtn = document.getElementById('modal-sync-close');
            const cloudEnabledEl = document.getElementById('modal-cloud-enabled');

            // Dropbox 元素
            const keyEl = document.getElementById('modal-db-key');
            const secEl = document.getElementById('modal-db-secret');
            const refreshEl = document.getElementById('modal-db-refresh');
            const dbSaveBtn = document.getElementById('modal-db-save');
            const dbCancelBtn = document.getElementById('modal-db-cancel');
            const dbAuthBtn = document.getElementById('modal-db-authorize');
            const dbLoginBtn = document.getElementById('modal-db-login');

            // S3 元素
            const s3SecretIdEl = document.getElementById('modal-s3-secret-id');
            const s3SecretKeyEl = document.getElementById('modal-s3-secret-key');
            const s3RegionEl = document.getElementById('modal-s3-region');
            const s3BucketEl = document.getElementById('modal-s3-bucket');
            const s3PasswordEl = document.getElementById('modal-s3-password');
            const s3SaveBtn = document.getElementById('modal-s3-save');
            const s3CancelBtn = document.getElementById('modal-s3-cancel');

            // S3 文件配置管理元素
            const s3BtnDefault = document.getElementById('modal-s3-btn-default');
            const s3BtnFetch = document.getElementById('modal-s3-btn-fetch');
            const s3ConfigListEl = document.getElementById('modal-s3-config-list');

            // 保存原始选中的配置名称
            const originalSelectedConfig = getSelectedS3Config();
            localStorage.setItem('ops_s3_selected_config_original', originalSelectedConfig);

            // 渲染S3配置列表
            function renderS3ConfigList() {
                const configs = getS3Configs();
                const selectedName = getSelectedS3Config();
                s3ConfigListEl.innerHTML = '';
                configs.forEach(config => {
                    const btn = document.createElement('button');
                    btn.className = 's3-config-btn' + (config.name === selectedName ? ' active' : '');
                    // 如果配置名称与文件名（去掉.json后）相同，则不显示文件名；默认配置始终显示文件名
                    const filenameWithoutExt = config.filename.replace('.json', '');
                    const showFilename = config.name === '默认' || config.name !== filenameWithoutExt;
                    if (showFilename) {
                        btn.innerHTML = `${config.name} <span style="opacity:0.6;font-size:0.75rem;">(${config.filename})</span>`;
                    } else {
                        btn.innerHTML = config.name;
                    }
                    btn.onclick = () => {
                        // 只更新选中状态，不执行上传下载
                        setSelectedS3Config(config.name);
                        renderS3ConfigList();
                    };
                    s3ConfigListEl.appendChild(btn);
                });
            }

            // 默认按钮 - 选择默认配置
            s3BtnDefault.onclick = () => {
                setSelectedS3Config('默认');
                renderS3ConfigList();
                showInfo('已选择默认配置', '提示');
            };

            // 获取按钮 - 从云端获取配置列表
            s3BtnFetch.onclick = async () => {
                try {
                    const s3Cfg = await getS3Config();
                    if (!s3Cfg.secretId || !s3Cfg.secretKey || !s3Cfg.region || !s3Cfg.bucket) {
                        showInfo('请先配置S3密钥信息', '提示');
                        return;
                    }
                    const password = await showPasswordModal();
                    if (!password) {
                        showInfo('需要密码才能访问S3', '提示');
                        return;
                    }
                    const { secretId, secretKey, region, bucket } = await decryptS3Config(s3Cfg, password);
                    const cos = new COS({ SecretId: secretId, SecretKey: secretKey });

                    // 列出Prompt Studio目录下的所有文件
                    return new Promise((resolve, reject) => {
                        cos.getBucket({
                            Bucket: bucket,
                            Region: region,
                            Prefix: 'Prompt Studio/',
                            MaxKeys: 100
                        }, (err, data) => {
                            if (err) {
                                reject(err);
                                return;
                            }
                            // 保留默认配置，其他配置从云端获取
                            const configs = [{ name: '默认', filename: DEFAULT_JSON_FILENAME }];
                            const existingNames = new Set(['默认']);
                            const defaultFilename = DEFAULT_JSON_FILENAME;
                            let addedCount = 0;

                            if (data.Contents && data.Contents.length > 0) {
                                data.Contents.forEach(item => {
                                    if (item.Key && item.Key.endsWith('.json')) {
                                        const filename = item.Key.replace('Prompt Studio/', '');
                                        // 跳过与默认配置文件名相同的文件
                                        if (filename === defaultFilename) {
                                            return;
                                        }
                                        // 从文件名提取名称（去掉.json扩展名）
                                        const name = filename.replace('.json', '');
                                        // 添加所有云端配置（覆盖原先的）
                                        if (!existingNames.has(name)) {
                                            configs.push({ name, filename });
                                            existingNames.add(name);
                                            addedCount++;
                                        }
                                    }
                                });
                                saveS3Configs(configs);
                                renderS3ConfigList();
                                showInfo('已从云端获取 ' + addedCount + ' 个配置', '提示');
                            } else {
                                showInfo('云端没有找到配置文件', '提示');
                            }
                            resolve();
                        });
                    });
                } catch (e) {
                    console.error('获取配置失败:', e);
                    showInfo('获取配置失败: ' + (e?.message || e), '错误');
                }
            };

            // 初始化S3配置列表
            renderS3ConfigList();

            // 当前选中的服务
            let currentProvider = getSyncProvider();

            function switchProvider(provider) {
                currentProvider = provider;
                setSyncProvider(provider);
                providerBtns.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.provider === provider);
                });
                const fileRowLabel = document.querySelector('#modal-db-file-row-label');
                const fileRowContent = document.querySelector('#modal-db-file-row-content');
                if (provider === 'dropbox') {
                    dropboxConfig.style.display = 'block';
                    s3Config.style.display = 'none';
                    dropboxFooter.classList.remove('hidden');
                    s3Footer.classList.add('hidden');
                    if (fileRowLabel) fileRowLabel.style.display = 'flex';
                    if (fileRowContent) fileRowContent.style.display = 'flex';
                } else {
                    dropboxConfig.style.display = 'none';
                    s3Config.style.display = 'block';
                    dropboxFooter.classList.add('hidden');
                    s3Footer.classList.remove('hidden');
                    if (fileRowLabel) fileRowLabel.style.display = 'none';
                    if (fileRowContent) fileRowContent.style.display = 'none';
                }
            }

            // 初始化全局云端开关
            if (cloudEnabledEl) {
                const enabled = localStorage.getItem('ops_cloud_enabled') === '1';
                cloudEnabledEl.checked = enabled;
            }

            // 初始化 Dropbox 数据
            const dbCfg = getDropboxConfig();
            if (keyEl && keyEl.closest('.modal-row')) keyEl.closest('.modal-row').style.display = 'none';
            if (secEl && secEl.closest('.modal-row')) secEl.closest('.modal-row').style.display = 'none';
            refreshEl.value = dbCfg.refresh || '';

            // 初始化 S3 数据（异步解密）
            (async () => {
                const s3Cfg = await getS3Config();
                // 检查是否已经加密（通过检查localStorage中是否有加密数据）
                const hasEncryptedData = localStorage.getItem('ops_s3_secret_id') || 
                                       localStorage.getItem('ops_s3_secret_key') ||
                                       localStorage.getItem('ops_s3_region') ||
                                       localStorage.getItem('ops_s3_bucket');

                // 如果已经加密，隐藏所有密钥输入框和加密密码输入框
                if (hasEncryptedData) {
                    // 隐藏密钥输入框
                    if (s3SecretIdEl && s3SecretIdEl.closest('.modal-row')) {
                        s3SecretIdEl.closest('.modal-row').style.display = 'none';
                    }
                    if (s3SecretKeyEl && s3SecretKeyEl.closest('.modal-row')) {
                        s3SecretKeyEl.closest('.modal-row').style.display = 'none';
                    }
                    if (s3RegionEl && s3RegionEl.closest('.modal-row')) {
                        s3RegionEl.closest('.modal-row').style.display = 'none';
                    }
                    if (s3BucketEl && s3BucketEl.closest('.modal-row')) {
                        s3BucketEl.closest('.modal-row').style.display = 'none';
                    }
                    // 隐藏加密密码输入框
                    const encryptRow = document.getElementById('modal-s3-encrypt-row');
                    if (encryptRow) {
                        encryptRow.style.display = 'none';
                    }
                } else {
                    // 如果没有加密，显示原始数据
                    if (s3SecretIdEl) s3SecretIdEl.value = s3Cfg.secretId || '';
                    if (s3SecretKeyEl) s3SecretKeyEl.value = s3Cfg.secretKey || '';
                    if (s3RegionEl) s3RegionEl.value = s3Cfg.region || '';
                    if (s3BucketEl) s3BucketEl.value = s3Cfg.bucket || '';
                }
            })();

            // 切换到当前 provider
            switchProvider(currentProvider);

            show(wrap);

            // 动态插入 Dropbox 的"选择JSON文件"与"刷新列表"
            const bodyEl = wrap.querySelector('.modal-body');
            let fileRowLabel = wrap.querySelector('#modal-db-file-row-label');
            let fileRowContent = wrap.querySelector('#modal-db-file-row-content');
            let fileSel = wrap.querySelector('#modal-db-file');
            let fileRefreshBtn = wrap.querySelector('#modal-db-refresh-list');
            if (!fileRowLabel && !fileRowContent && bodyEl) {
                // 标签行
                fileRowLabel = document.createElement('div');
                fileRowLabel.className = 'modal-row';
                fileRowLabel.id = 'modal-db-file-row-label';
                const label = document.createElement('label');
                label.textContent = '选择JSON文件（Dropbox 应用目录）';
                fileRowLabel.appendChild(label);
                bodyEl.appendChild(fileRowLabel);

                // 内容行
                fileRowContent = document.createElement('div');
                fileRowContent.className = 'modal-row';
                fileRowContent.id = 'modal-db-file-row-content';
                const rowInner = document.createElement('div');
                rowInner.style.display = 'flex';
                rowInner.style.gap = '8px';
                rowInner.style.width = '100%';
                fileSel = document.createElement('select');
                fileSel.className = 'modal-input';
                fileSel.id = 'modal-db-file';
                fileSel.style.flex = '1';
                fileRefreshBtn = document.createElement('button');
                fileRefreshBtn.className = 'btn btn-outline';
                fileRefreshBtn.id = 'modal-db-refresh-list';
                fileRefreshBtn.textContent = '刷新';
                rowInner.appendChild(fileSel);
                rowInner.appendChild(fileRefreshBtn);
                fileRowContent.appendChild(rowInner);
                bodyEl.appendChild(fileRowContent);
            }
            // 根据当前 provider 设置文件选择行的显示状态
            if (fileRowLabel) {
                fileRowLabel.style.display = currentProvider === 'dropbox' ? 'flex' : 'none';
            }
            if (fileRowContent) {
                fileRowContent.style.display = currentProvider === 'dropbox' ? 'flex' : 'none';
            }
            // 预填文件选择
            if (fileSel) {
                let preSel = getDropboxSelectedFilename();
                // 清理可能的错误前缀
                if (preSel.includes('/Prompt Studio/')) {
                    const parts = preSel.split('/Prompt Studio/');
                    preSel = parts[parts.length - 1];
                }
                // 移除多余的路径分隔符
                preSel = preSel.replace(/^\/+/, '').replace(/\/+$/, '');
                // 确保有 / 前缀
                preSel = '/' + preSel;
                fileSel.innerHTML = '';
                const opt = document.createElement('option');
                opt.value = preSel;
                opt.textContent = preSel;
                fileSel.appendChild(opt);
                fileSel.value = preSel;
            }

            async function listDropboxJsonFiles(token) {
                const res = await fetch('https://api.dropboxapi.com/2/files/list_folder', {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Bearer ' + token,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ path: '', recursive: false })
                });
                if (!res.ok) {
                    let msg = 'HTTP ' + res.status;
                    try { const j = await res.json(); msg += ' ' + (j.error_summary || JSON.stringify(j)); } catch(_) {}
                    throw new Error(msg);
                }
                const j = await res.json();
                const entries = Array.isArray(j?.entries) ? j.entries : [];
                const files = entries
                    .filter(e => e['.tag'] === 'file' && typeof e.name === 'string' && e.name.toLowerCase().endsWith('.json'))
                    .map(e => '/' + e.name);
                return files;
            }

            async function exchangeAccessTokenWithRefresh(key, secret, refreshToken) {
                const basic = btoa(`${key}:${secret}`);
                const body = new URLSearchParams({
                    grant_type: 'refresh_token',
                    refresh_token: refreshToken
                }).toString();
                const res = await fetch('https://api.dropboxapi.com/oauth2/token', {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Basic ' + basic,
                        'Content-Type': 'application/x-www-form-urlencoded'
                    },
                    body
                });
                if (!res.ok) {
                    let msg = 'HTTP ' + res.status;
                    try { const j = await res.json(); msg += ' ' + (j.error_description || JSON.stringify(j)); } catch(_) {}
                    throw new Error(msg);
                }
                return res.json();
            }

            const onAuthorize = () => {
                const key = getDropboxConfig().key;
                const redirect = encodeURIComponent('https://localhost/');
                // 生成 state 以便后端校验（此处仅传递，不在前端校验）
                const state = Math.random().toString(36).slice(2);
                const url = `https://www.dropbox.com/oauth2/authorize?response_type=code&client_id=${encodeURIComponent(key)}&redirect_uri=${redirect}&token_access_type=offline&state=${encodeURIComponent(state)}`;
                // 以居中小窗打开授权页
                const w = 600, h = 700;
                const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;
                const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;
                const width = window.innerWidth || document.documentElement.clientWidth || screen.width;
                const height = window.innerHeight || document.documentElement.clientHeight || screen.height;
                const left = dualScreenLeft + (width - w) / 2;
                const top = dualScreenTop + (height - h) / 2;
                const features = `scrollbars=yes,resizable=yes,width=${w},height=${h},top=${Math.max(0, top)},left=${Math.max(0, left)}`;
                const win = window.open(url, 'dropbox_auth_popup', features);
                if (!win) {
                    showInfo('弹窗被浏览器拦截，请允许弹窗或改用新标签页方式。', '提示');
                    window.open(url, '_blank', 'noopener,noreferrer');
                    return;
                }
            };

            const onLogin = async () => {
                const key = getDropboxConfig().key;
                const sec = getDropboxConfig().secret;
                let inputVal = refreshEl.value.trim();
                if (!inputVal) { showInfo('请粘贴 Refresh Token 或 回调URL/code', '提示'); refreshEl.focus(); return; }

                // 工具：从可能的完整URL或query片段中提取 code
                function extractCode(str) {
                    try {
                        if (/^https?:\/\//i.test(str)) {
                            const u = new URL(str);
                            return u.searchParams.get('code') || '';
                        }
                        // 若是 query 片段或包含 code= 的字符串
                        const m = str.match(/[?&]code=([^&]+)/);
                        if (m) return decodeURIComponent(m[1]);
                        // 若是纯 code（无特殊字符且长度较短），简单判断
                        if (/^[A-Za-z0-9_-]+$/.test(str) && str.length <= 200) return str;
                    } catch (_) {}
                    return '';
                }

                async function exchangeCodeForTokens(key, secret, code) {
                    const basic = btoa(`${key}:${secret}`);
                    const body = new URLSearchParams({
                        grant_type: 'authorization_code',
                        code,
                        redirect_uri: 'https://localhost/'
                    }).toString();
                    const res = await fetch('https://api.dropboxapi.com/oauth2/token', {
                        method: 'POST',
                        headers: {
                            'Authorization': 'Basic ' + basic,
                            'Content-Type': 'application/x-www-form-urlencoded'
                        },
                        body
                    });
                    if (!res.ok) {
                        let msg = 'HTTP ' + res.status;
                        try { const j = await res.json(); msg += ' ' + (j.error_description || JSON.stringify(j)); } catch(_) {}
                        throw new Error(msg);
                    }
                    return res.json(); // 期望返回 access_token、refresh_token 等
                }

                try {
                    const maybeCode = extractCode(inputVal);
                    let refreshToken = '';
                    let accessToken = '';

                    if (maybeCode) {
                        // 先用授权码兑换 refresh_token 和 access_token
                        const data = await exchangeCodeForTokens(key, sec, maybeCode);
                        refreshToken = data.refresh_token || '';
                        accessToken = data.access_token || '';
                        if (!refreshToken) {
                            throw new Error('未返回 refresh_token，请确认授权时已请求离线权限（token_access_type=offline）且重定向URI完全一致。');
                        }
                    } else {
                        // 直接认为是 refresh_token，走 refresh 换取 access_token
                        refreshToken = inputVal;
                        const data = await exchangeAccessTokenWithRefresh(key, sec, refreshToken);
                        accessToken = data.access_token || '';
                    }

                    if (!accessToken) {
                        // 用 refresh 再换一次 access 保险
                        const data2 = await exchangeAccessTokenWithRefresh(key, sec, refreshToken);
                        accessToken = data2.access_token || '';
                    }
                    if (!accessToken) throw new Error('未获取到 access_token');

                    // 保存
                    try {
                        localStorage.setItem('ops_dbx_key', key);
                        localStorage.setItem('ops_dbx_secret', sec);
                        localStorage.setItem('ops_dbx_refresh', refreshToken);
                        localStorage.setItem('ops_dbx_token', accessToken);
                        showInfo('登录成功：已保存 Refresh Token 并获取 Access Token，可立即进行 Dropbox 上传/下载。', '登录成功');
                    } catch(e) {}
                } catch (err) {
                    showInfo('登录失败：' + (err?.message || err), '登录失败');
                }
            };

            const onDbSave = () => {
                try {
                    // 保存全局云端开关
                    if (cloudEnabledEl) {
                        localStorage.setItem('ops_cloud_enabled', cloudEnabledEl.checked ? '1' : '0');
                    }
                    localStorage.setItem('ops_dbx_refresh', refreshEl.value.trim());
                    const sel = wrap.querySelector('#modal-db-file');
                    let v = sel && (sel.value || '').trim();
                    // 清理路径，只保留纯文件名
                    if (v) {
                        // 移除 Prompt Studio/ 前缀
                        if (v.includes('/Prompt Studio/')) {
                            const parts = v.split('/Prompt Studio/');
                            v = parts[parts.length - 1];
                        }
                        // 移除多余的路径分隔符
                        v = v.replace(/^\/+/, '').replace(/\/+$/, '');
                        // 确保有 / 前缀
                        v = '/' + v;
                        localStorage.setItem('ops_dbx_filename', v);
                    }
                } catch(e) {}
                cleanup();
            };

            const onS3Save = async () => {
                try {
                    // 检查是否已经加密（通过检查localStorage中是否有加密数据）
                    const hasEncryptedData = localStorage.getItem('ops_s3_secret_id') ||
                                           localStorage.getItem('ops_s3_secret_key') ||
                                           localStorage.getItem('ops_s3_region') ||
                                           localStorage.getItem('ops_s3_bucket');

                    // 保存全局云端开关
                    if (cloudEnabledEl) {
                        localStorage.setItem('ops_cloud_enabled', cloudEnabledEl.checked ? '1' : '0');
                    }

                    // 如果已经加密，检查配置是否发生变化
                    if (hasEncryptedData) {
                        // 检查配置是否发生变化
                        const currentSelectedName = getSelectedS3Config();
                        const originalSelectedName = localStorage.getItem('ops_s3_selected_config_original');

                        if (originalSelectedName && currentSelectedName !== originalSelectedName) {
                            // 配置发生变化，需要上传当前文件并下载新选择的文件
                            try {
                                // 只输入一次密码
                                const password = await showPasswordModal();
                                if (!password) {
                                    showInfo('需要密码才能切换配置', '提示');
                                    return;
                                }

                                // 解密配置
                                const encryptedConfig = await getS3Config();
                                const { secretId, secretKey, region, bucket } = await decryptS3Config(encryptedConfig, password);

                                const configs = getS3Configs();
                                const currentConfig = configs.find(c => c.name === currentSelectedName);
                                const originalConfig = configs.find(c => c.name === originalSelectedName);

                                if (currentConfig && originalConfig) {
                                    // 使用统一的导出函数
                                    const exportObj = exportFullDataObject();
                                    const dataStr = JSON.stringify(exportObj, null, 2);

                                    // 先上传当前文件（使用原配置的文件名）
                                    await uploadToS3Internal(originalConfig.filename, dataStr, secretId, secretKey, region, bucket);
                                    showInfo('已上传到 S3: ' + originalConfig.filename, '上传成功');

                                    // 下载新选择的文件（使用替换模式清空原先数据）
                                    const text = await downloadFromS3Internal(currentConfig.filename, secretId, secretKey, region, bucket);
                                    await importJsonText(text, false, true);
                                    showInfo('已从 S3 导入 ' + currentConfig.filename, '导入成功');
                                }
                            } catch (e) {
                                console.error('切换配置失败:', e);
                                showInfo('切换配置失败: ' + (e?.message || e), '错误');
                                return;
                            }
                        }

                        cleanup();
                        return;
                    }

                    // 如果没有加密，需要密码进行加密
                    const passwordInput = document.getElementById('modal-s3-encrypt-password');
                    const password = passwordInput?.value?.trim() || '';

                    // 验证密码长度
                    if (!password || password.length < 8) {
                        showInfo('密码至少需要8位', '错误');
                        return;
                    }

                    // 加密并保存密钥
                    const secretId = s3SecretIdEl?.value?.trim() || '';
                    const secretKey = s3SecretKeyEl?.value?.trim() || '';
                    const region = s3RegionEl?.value?.trim() || '';
                    const bucket = s3BucketEl?.value?.trim() || '';

                    if (secretId) {
                        const encryptedSecretId = await encryptData(secretId, password);
                        localStorage.setItem('ops_s3_secret_id', encryptedSecretId);
                    }
                    if (secretKey) {
                        const encryptedSecretKey = await encryptData(secretKey, password);
                        localStorage.setItem('ops_s3_secret_key', encryptedSecretKey);
                    }
                    if (region) {
                        const encryptedRegion = await encryptData(region, password);
                        localStorage.setItem('ops_s3_region', encryptedRegion);
                    }
                    if (bucket) {
                        const encryptedBucket = await encryptData(bucket, password);
                        localStorage.setItem('ops_s3_bucket', encryptedBucket);
                    }
                    // 不再硬编码设置文件名，使用配置管理中的选择

                    // 清空密码输入框并隐藏
                    if (passwordInput) {
                        passwordInput.value = '';
                        const encryptRow = document.getElementById('modal-s3-encrypt-row');
                        if (encryptRow) {
                            encryptRow.style.display = 'none';
                        }
                    }

                    showInfo('S3 密钥已加密保存', '提示');
                } catch(e) {
                    console.error('保存失败:', e);
                    showInfo('密钥保存失败: ' + (e.message || ''), '错误');
                }
                cleanup();
            };

            const onCancel = () => cleanup();

            // 清除密钥函数
            const onClearCredentials = (provider) => {
                showConfirm('确定要清除所有保存的密钥吗？清除后需要重新输入才能使用云同步功能。', '清除确认')
                    .then((ok) => {
                        if (!ok) return;

                        if (provider === 'dropbox') {
                            localStorage.removeItem('ops_dbx_key');
                            localStorage.removeItem('ops_dbx_secret');
                            localStorage.removeItem('ops_dbx_refresh');
                            localStorage.removeItem('ops_dbx_token');
                            if (refreshEl) refreshEl.value = '';
                            showInfo('Dropbox 密钥已清除', '提示');
                        } else if (provider === 's3') {
                            localStorage.removeItem('ops_s3_secret_id');
                            localStorage.removeItem('ops_s3_secret_key');
                            localStorage.removeItem('ops_s3_region');
                            localStorage.removeItem('ops_s3_bucket');
                            // 重置配置列表为只包含默认配置
                            localStorage.setItem('ops_s3_configs', JSON.stringify([{ name: '默认', filename: DEFAULT_JSON_FILENAME }]));
                            localStorage.removeItem('ops_s3_selected_config');
                            if (s3SecretIdEl) s3SecretIdEl.value = '';
                            if (s3SecretKeyEl) s3SecretKeyEl.value = '';
                            if (s3RegionEl) s3RegionEl.value = '';
                            if (s3BucketEl) s3BucketEl.value = '';
                            // 清除密钥后显示所有密钥输入框和加密密码输入框
                            if (s3SecretIdEl && s3SecretIdEl.closest('.modal-row')) {
                                s3SecretIdEl.closest('.modal-row').style.display = 'grid';
                            }
                            if (s3SecretKeyEl && s3SecretKeyEl.closest('.modal-row')) {
                                s3SecretKeyEl.closest('.modal-row').style.display = 'grid';
                            }
                            if (s3RegionEl && s3RegionEl.closest('.modal-row')) {
                                s3RegionEl.closest('.modal-row').style.display = 'grid';
                            }
                            if (s3BucketEl && s3BucketEl.closest('.modal-row')) {
                                s3BucketEl.closest('.modal-row').style.display = 'grid';
                            }
                            const encryptRow = document.getElementById('modal-s3-encrypt-row');
                            if (encryptRow) {
                                encryptRow.style.display = 'grid';
                            }
                            // 重新渲染S3配置列表（恢复默认配置）
                            if (typeof renderS3ConfigList === 'function') {
                                renderS3ConfigList();
                            }
                            showInfo('S3 密钥和文件名称管理已清除', '提示');
                        }
                    });
            };

            // 导出 S3 配置
            const onExportS3Config = async () => {
                const s3Config = await getS3Config();
                
                if (!s3Config.secretId || !s3Config.secretKey) {
                    showInfo('没有保存的 S3 配置可导出', '提示');
                    return;
                }

                // 检查是否有配置密码
                const password = await showPasswordModal();
                if (!password) {
                    showInfo('需要密码才能导出配置', '提示');
                    return;
                }

                try {
                    // 创建包含加密配置的对象
                    const exportData = {
                        version: '1.0',
                        timestamp: new Date().toISOString(),
                        secretId: s3Config.secretId,
                        secretKey: s3Config.secretKey,
                        region: s3Config.region,
                        bucket: s3Config.bucket
                    };

                    // 创建并下载 JSON 文件
                    const dataStr = JSON.stringify(exportData, null, 2);
                    const blob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'key.json';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    showInfo('S3 配置已导出到 key.json', '成功');
                } catch (e) {
                    console.error('导出失败:', e);
                    showInfo('导出失败: ' + (e.message || ''), '错误');
                }
            };

            // 导入 S3 配置
            const onImportS3Config = async () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    if (file.name !== 'key.json') {
                        showInfo('请选择 key.json 文件', '提示');
                        return;
                    }

                    try {
                        const text = await file.text();
                        const importData = JSON.parse(text);

                        // 验证导入的数据格式
                        if (!importData.secretId || !importData.secretKey || 
                            !importData.region || !importData.bucket) {
                            showInfo('导入的配置文件格式不正确', '错误');
                            return;
                        }

                        // 检查是否有配置密码
                        const password = await showPasswordModal();
                        if (!password) {
                            showInfo('需要密码才能导入配置', '提示');
                            return;
                        }

                        // 保存导入的配置到 localStorage
                        localStorage.setItem('ops_s3_secret_id', importData.secretId);
                        localStorage.setItem('ops_s3_secret_key', importData.secretKey);
                        localStorage.setItem('ops_s3_region', importData.region);
                        localStorage.setItem('ops_s3_bucket', importData.bucket);

                        // 更新界面显示
                        if (s3SecretIdEl) s3SecretIdEl.value = importData.secretId;
                        if (s3SecretKeyEl) s3SecretKeyEl.value = importData.secretKey;
                        if (s3RegionEl) s3RegionEl.value = importData.region;
                        if (s3BucketEl) s3BucketEl.value = importData.bucket;

                        // 隐藏密钥输入框
                        if (s3SecretIdEl && s3SecretIdEl.closest('.modal-row')) {
                            s3SecretIdEl.closest('.modal-row').style.display = 'none';
                        }
                        if (s3SecretKeyEl && s3SecretKeyEl.closest('.modal-row')) {
                            s3SecretKeyEl.closest('.modal-row').style.display = 'none';
                        }
                        if (s3RegionEl && s3RegionEl.closest('.modal-row')) {
                            s3RegionEl.closest('.modal-row').style.display = 'none';
                        }
                        if (s3BucketEl && s3BucketEl.closest('.modal-row')) {
                            s3BucketEl.closest('.modal-row').style.display = 'none';
                        }

                        showInfo('S3 配置已导入成功', '成功');
                    } catch (e) {
                        console.error('导入失败:', e);
                        showInfo('导入失败: ' + (e.message || ''), '错误');
                    }
                };

                input.click();
            };

            function cleanup() {
                // 清除临时保存的原始配置名称
                localStorage.removeItem('ops_s3_selected_config_original');
                closeBtn.removeEventListener('click', onCancel);
                dbCancelBtn.removeEventListener('click', onCancel);
                s3CancelBtn.removeEventListener('click', onCancel);
                dbSaveBtn.removeEventListener('click', onDbSave);
                s3SaveBtn.removeEventListener('click', onS3Save);
                dbAuthBtn.removeEventListener('click', onAuthorize);
                dbLoginBtn.removeEventListener('click', onLogin);
                providerBtns.forEach(btn => btn.removeEventListener('click', onProviderClick));
                document.removeEventListener('keydown', onKey);
                const exportBtn = wrap.querySelector('#modal-s3-export');
                const importBtn = wrap.querySelector('#modal-s3-import');
                if (exportBtn) {
                    exportBtn.removeEventListener('click', onExportS3Config);
                }
                if (importBtn) {
                    importBtn.removeEventListener('click', onImportS3Config);
                }
                hide(wrap);
            }

            function onKey(e) {
                if (e.key === 'Escape') onCancel();
            }

            const onProviderClick = (e) => {
                const provider = e.target.dataset.provider;
                if (provider) switchProvider(provider);
            };

            closeBtn.addEventListener('click', onCancel);
            dbCancelBtn.addEventListener('click', onCancel);
            s3CancelBtn.addEventListener('click', onCancel);
            dbSaveBtn.addEventListener('click', onDbSave);
            s3SaveBtn.addEventListener('click', onS3Save);
            dbAuthBtn.addEventListener('click', onAuthorize);
            dbLoginBtn.addEventListener('click', onLogin);
            providerBtns.forEach(btn => btn.addEventListener('click', onProviderClick));
            document.addEventListener('keydown', onKey);

            // 清除密钥按钮事件
            const dbClearBtn = wrap.querySelector('#modal-db-clear');
            const s3ClearBtn = wrap.querySelector('#modal-s3-clear');
            if (dbClearBtn) {
                dbClearBtn.addEventListener('click', () => onClearCredentials('dropbox'));
            }
            if (s3ClearBtn) {
                s3ClearBtn.addEventListener('click', () => onClearCredentials('s3'));
            }

            // S3 导出和导入按钮事件
            const s3ExportBtn = wrap.querySelector('#modal-s3-export');
            const s3ImportBtn = wrap.querySelector('#modal-s3-import');
            if (s3ExportBtn) {
                s3ExportBtn.addEventListener('click', onExportS3Config);
            }
            if (s3ImportBtn) {
                s3ImportBtn.addEventListener('click', onImportS3Config);
            }

            // 刷新文件列表按钮
            const fileRefreshBtn2 = wrap.querySelector('#modal-db-refresh-list');
            const fileSel2 = wrap.querySelector('#modal-db-file');
            if (fileRefreshBtn2) {
                fileRefreshBtn2.onclick = async () => {
                    try {
                        const { token } = getDropboxConfig();
                        if (!token) { showInfo('请先登录 Dropbox', '提示'); return; }
                        const files = await listDropboxJsonFiles(token);
                        const def = getDropboxSelectedFilename();
                        if (fileSel2) {
                            fileSel2.innerHTML = '';
                            const list = files.length ? files : [def];
                            list.forEach(name => {
                                const opt = document.createElement('option');
                                opt.value = name;
                                opt.textContent = name;
                                fileSel2.appendChild(opt);
                            });
                            fileSel2.value = def;
                        }
                    } catch (err) {
                        showInfo('获取文件列表失败：' + (err?.message || err), '失败');
                    }
                };
            }
        }

        // 全局样式映射配置
        const GLOBAL_STYLE_MAP = {
            'default': '',
            'purple': 'linear-gradient(#8d79c0, #7a78dc)',
            'green': 'linear-gradient(#a0b181, #57b049)',
            'orange': 'linear-gradient(#cb9131, #b57e22)',
            'pink': 'linear-gradient(#fd79a8, #e84393)',
            'blue': 'linear-gradient(#2c3e80, #344495)',
            'dark-purple': 'linear-gradient(#584589, #7774a0)'
        };

        function renderCommonTagsByCategory(catKey) {
            if (!commonTagsContainer) return;
            commonTagsContainer.innerHTML = '';

            const data = commonData?.[catKey];

            // 旧版结构：数组 => 维持原样平铺
            if (Array.isArray(data)) {
                // 为容器添加数据属性，用于拖拽
                commonTagsContainer.dataset.cat = catKey;
                commonTagsContainer.dataset.subcat = '';

                data.forEach((item, index) => {
                    const label = item?.lang_zh || item?.text || '';
                    const value = item?.text || '';
                    const related = item?.related || '';
                    const style = item?.style || 'default';
                    if (!label || !value) return;
                    const span = document.createElement('span');
                    span.className = 'common-tag' + ((item && item.pinned) ? ' pinned' : '');
                    span.dataset.cat = catKey;
                    span.dataset.index = String(index);
                    span.dataset.subcat = '';
                    span.draggable = true;
                    span.textContent = label;
                    span.title = value;

                    // 根据样式设置背景
                    if (GLOBAL_STYLE_MAP[style]) {
                        span.style.background = GLOBAL_STYLE_MAP[style];
                    }

                    // 创建关联提示词悬浮框
                    if (related) {
                        const tooltip = document.createElement('div');
                        tooltip.className = 'related-tooltip';
                        const title = document.createElement('div');
                        title.className = 'related-tooltip-title';
                        title.textContent = '关联提示词：';
                        tooltip.appendChild(title);

                        // 解析关联提示词（支持中英文逗号或分号分隔不同按钮，竖线分隔同一按钮内的多个词）
                        const relatedTags = related.split(/[,，;；]+/).map(s => s.trim()).filter(Boolean);
                        relatedTags.forEach(tag => {
                            const tagEl = document.createElement('span');
                            tagEl.className = 'related-tooltip-item';

                            // 显示时用空格替换竖线，更美观
                            tagEl.textContent = tag.replace(/\|/g, ' ');

                            tagEl.addEventListener('click', (e) => {
                                e.stopPropagation();
                                const cur = promptEditor.value.trim();
                                // 根据全局变量判断当前语言模式
                                const isChineseMode = window.__chineseMode;
                                // 将竖线替换为逗号
                                const relatedValue = tag.replace(/\|/g, ', ');
                                const mainText = isChineseMode ? label.trim() : value.trim();

                                // 解析关联词
                                const relatedParts = relatedValue.split(',').map(p => p.trim());

                                // 处理触发词匹配
                                const processed = applyTrigger(mainText, relatedValue);

                                // 处理触发词结果
                                let combinedText;
                                if (processed && typeof processed === 'object') {
                                    // 有匹配触发词：组合结果 + 未匹配的词
                                    combinedText = processed.combined;
                                    if (processed.unmatched && processed.unmatched.length > 0) {
                                        combinedText += ', ' + processed.unmatched.join(', ');
                                    }
                                } else {
                                    // 没有匹配触发词：主标签 + 所有关联词
                                    combinedText = mainText + (relatedParts.length ? ', ' + relatedParts.join(', ') : '');
                                }

                                promptEditor.value = cur ? (cur + ', ' + combinedText) : combinedText;
                                normalizePromptInput();
                                updateTags();
                                promptEditor.focus({ preventScroll: true });
                            });
                        });
                        span.appendChild(tooltip);

                        // 调整tooltip位置，防止超出屏幕
                        const adjustTooltipPosition = () => {
                            const rect = tooltip.getBoundingClientRect();
                            const vw = window.innerWidth;
                            const vh = window.innerHeight;

                            // 检查右侧边界
                            if (rect.right > vw - 10) {
                                tooltip.style.left = 'auto';
                                tooltip.style.right = '0';
                                tooltip.style.transform = 'none';
                            }
                            // 检查底部边界
                            if (rect.bottom > vh - 10) {
                                tooltip.style.bottom = 'auto';
                                tooltip.style.top = '100%';
                            }
                        };

                        // 鼠标悬停显示关联提示词
                        let hideTimeout;
                        const showTooltip = () => {
                            clearTimeout(hideTimeout);
                            tooltip.classList.add('show');
                            // 显示后调整位置
                            requestAnimationFrame(adjustTooltipPosition);
                        };
                        const hideTooltip = () => {
                            hideTimeout = setTimeout(() => {
                                tooltip.classList.remove('show');
                            }, 100);
                        };

                        span.addEventListener('mouseenter', showTooltip);
                        span.addEventListener('mouseleave', hideTooltip);
                        tooltip.addEventListener('mouseenter', showTooltip);
                        tooltip.addEventListener('mouseleave', hideTooltip);
                    }

                    span.addEventListener('click', () => {
                        const cur = promptEditor.value.trim();
                        // 根据全局变量判断当前语言模式
                        const isChineseMode = window.__chineseMode;
                        const suffix = isChineseMode ? label.trim() : value.trim();
                        promptEditor.value = cur ? (cur + ', ' + suffix) : suffix;
                        normalizePromptInput();
                        updateTags();
                        promptEditor.focus({ preventScroll: true });
                    });
                    // 添加拖拽事件
                    span.addEventListener('dragstart', handleCommonTagDragStart);
                    span.addEventListener('dragover', handleCommonTagDragOver);
                    span.addEventListener('drop', handleCommonTagDrop);
                    span.addEventListener('dragend', handleCommonTagDragEnd);
                    commonTagsContainer.appendChild(span);
                });
                // 为容器添加 dragover 事件
                commonTagsContainer.addEventListener('dragover', onCommonContainerDragOver);
                return;
            }

            // 分组结构：{ groups: { 类别: [items] } }
            if (isGroupedCategory(data)) {
                const groups = data.groups || {};
                const order = Array.isArray(data.groupsOrder)
                    ? data.groupsOrder.filter(n => Object.prototype.hasOwnProperty.call(groups, n))
                        .concat(Object.keys(groups).filter(n => !data.groupsOrder.includes(n)))
                    : Object.keys(groups);
                order.forEach(sub => {
                    const section = document.createElement('div');
                    section.style.border = '1px solid var(--border-color)';
                    section.style.borderRadius = '8px';
                    section.style.marginBottom = '8px';
                    section.style.overflow = 'visible';
                    section.style.width = '100%';

                    const header = document.createElement('div');
                    header.style.padding = '8px 10px';
                    header.style.background = 'var(--bg-color)';
                    header.style.display = 'flex';
                    header.style.alignItems = 'center';
                    header.style.justifyContent = 'space-between';
                    header.style.width = '100%';

                    const left = document.createElement('div');
                    left.style.display = 'flex';
                    left.style.alignItems = 'center';
                    left.style.gap = '8px';

                    const title = document.createElement('span');
                    title.textContent = sub;

                    const right = document.createElement('div');
                    right.style.display = 'flex';
                    right.style.gap = '8px';

                    const toggle = document.createElement('button');
                    toggle.className = 'btn btn-outline';
                    toggle.textContent = '折叠/展开';

                    const btnNew = document.createElement('button');
                    btnNew.className = 'btn btn-outline';
                    btnNew.textContent = '新建';

                    const btnRename = document.createElement('button');
                    btnRename.className = 'btn btn-outline';
                    btnRename.textContent = '修改名称';

                    const btnDelete = document.createElement('button');
                    btnDelete.className = 'btn btn-outline';
                    btnDelete.textContent = '删除';

                    const btnUp = document.createElement('button');
                    btnUp.className = 'btn btn-outline';
                    btnUp.textContent = '上移';

                    const btnDown = document.createElement('button');
                    btnDown.className = 'btn btn-outline';
                    btnDown.textContent = '下移';

                    const body = document.createElement('div');
                    body.style.display = getSubcatOpen(catKey, sub) ? 'flex' : 'none';
                    body.style.flexWrap = 'wrap';
                    body.style.gap = '4px';
                    body.style.padding = '10px';
                    body.style.width = '100%';
                    body.dataset.containerType = 'common-tag-group';
                    body.dataset.cat = catKey;
                    body.dataset.subcat = sub;

                    const arr = Array.isArray(groups[sub]) ? groups[sub] : [];
                    arr.forEach((item, index) => {
                        const label = item?.lang_zh || item?.text || '';
                        const value = item?.text || '';
                        const related = item?.related || '';
                        const style = item?.style || 'default';
                        if (!label || !value) return;
                        const span = document.createElement('span');
                        span.className = 'common-tag' + ((item && item.pinned) ? ' pinned' : '');
                        span.dataset.cat = catKey;
                        span.dataset.subcat = sub;
                        span.dataset.index = String(index);
                        span.draggable = true;
                        span.textContent = label;
                        span.title = value;

                        // 根据样式设置背景
                        if (GLOBAL_STYLE_MAP[style]) {
                            span.style.background = GLOBAL_STYLE_MAP[style];
                        }

                        // 创建关联提示词悬浮框
                        if (related) {
                            const tooltip = document.createElement('div');
                            tooltip.className = 'related-tooltip';
                            const title = document.createElement('div');
                            title.className = 'related-tooltip-title';
                            title.textContent = '关联提示词：';
                            tooltip.appendChild(title);

                            // 解析关联提示词（支持中英文逗号或分号分隔不同按钮，竖线分隔同一按钮内的多个词）
                            const relatedTags = related.split(/[,，;；]+/).map(s => s.trim()).filter(Boolean);
                            relatedTags.forEach(tag => {
                                const tagEl = document.createElement('span');
                                tagEl.className = 'related-tooltip-item';
                                // 显示时用空格替换竖线，更美观
                                tagEl.textContent = tag.replace(/\|/g, ' ');
                                tagEl.addEventListener('click', (e) => {
                                    e.stopPropagation();
                                    const cur = promptEditor.value.trim();
                                    // 根据全局变量判断当前语言模式
                                    const isChineseMode = window.__chineseMode;
                                    // 将竖线替换为逗号
                                    const relatedValue = tag.replace(/\|/g, ', ');
                                    const mainText = isChineseMode ? label.trim() : value.trim();

                                    // 解析关联词
                                    const relatedParts = relatedValue.split(',').map(p => p.trim());

                                    // 处理触发词匹配
                                    const processed = applyTrigger(mainText, relatedValue);

                                    // 处理触发词结果
                                    let combinedText;
                                    if (processed && typeof processed === 'object') {
                                        // 有匹配触发词：组合结果 + 未匹配的词
                                        combinedText = processed.combined;
                                        if (processed.unmatched && processed.unmatched.length > 0) {
                                            combinedText += ', ' + processed.unmatched.join(', ');
                                        }
                                    } else {
                                        // 没有匹配触发词：主标签 + 所有关联词
                                        combinedText = mainText + (relatedParts.length ? ', ' + relatedParts.join(', ') : '');
                                    }

                                    promptEditor.value = cur ? (cur + ', ' + combinedText) : combinedText;
                                    normalizePromptInput();
                                    updateTags();
                                    promptEditor.focus({ preventScroll: true });
                                });
                                tooltip.appendChild(tagEl);
                            });
                            span.appendChild(tooltip);

                            // 调整tooltip位置，防止超出屏幕
                            const adjustTooltipPosition = () => {
                                const rect = tooltip.getBoundingClientRect();
                                const vw = window.innerWidth;
                                const vh = window.innerHeight;

                                // 检查右侧边界
                                if (rect.right > vw - 10) {
                                    tooltip.style.left = 'auto';
                                    tooltip.style.right = '0';
                                    tooltip.style.transform = 'none';
                                }
                                // 检查底部边界
                                if (rect.bottom > vh - 10) {
                                    tooltip.style.bottom = 'auto';
                                    tooltip.style.top = '100%';
                                }
                            };

                            // 鼠标悬停显示关联提示词
                            let hideTimeout;
                            const showTooltip = () => {
                                clearTimeout(hideTimeout);
                                tooltip.classList.add('show');
                                // 显示后调整位置
                                requestAnimationFrame(adjustTooltipPosition);
                            };
                            const hideTooltip = () => {
                                hideTimeout = setTimeout(() => {
                                    tooltip.classList.remove('show');
                                }, 100);
                            };

                            span.addEventListener('mouseenter', showTooltip);
                            span.addEventListener('mouseleave', hideTooltip);
                            tooltip.addEventListener('mouseenter', showTooltip);
                            tooltip.addEventListener('mouseleave', hideTooltip);
                        }

                        span.addEventListener('click', () => {
                            const cur = promptEditor.value.trim();
                            // 根据全局变量判断当前语言模式
                            const isChineseMode = window.__chineseMode;
                            const suffix = isChineseMode ? label.trim() : value.trim();
                            promptEditor.value = cur ? (cur + ', ' + suffix) : suffix;
                            normalizePromptInput();
                            updateTags();
                            promptEditor.focus({ preventScroll: true });
                        });
                        // 添加拖拽事件
                        span.addEventListener('dragstart', handleCommonTagDragStart);
                        span.addEventListener('dragover', handleCommonTagDragOver);
                        span.addEventListener('drop', handleCommonTagDrop);
                        span.addEventListener('dragend', handleCommonTagDragEnd);
                        body.appendChild(span);
                    });
                    // 为容器添加 dragover 和 drop 事件（支持在空白区域拖拽）
                    body.addEventListener('dragover', onCommonContainerDragOver);
                    body.addEventListener('drop', handleCommonTagDrop);

                    toggle.addEventListener('click', () => {
                        const next = body.style.display === 'none';
                        body.style.display = next ? 'flex' : 'none';
                        setSubcatOpen(catKey, sub, next);
                    });

                    btnNew.addEventListener('click', async () => {
                        const name = await showInputModal('新建类别', '输入名称', '');
                        const val = (name || '').trim();
                        if (!val) return;
                        ensureGrouped(catKey);
                        const catObj = commonData[catKey];
                        const g = catObj.groups || (catObj.groups = {});
                        if (!g[val]) g[val] = [];
                        if (!Array.isArray(catObj.groupsOrder)) catObj.groupsOrder = Object.keys(g);
                        if (!catObj.groupsOrder.includes(val)) catObj.groupsOrder.push(val);
                        saveCommonData();
                        renderCommonTagsByCategory(catKey);
                    });

                    btnRename.addEventListener('click', async () => {
                        const name = await showInputModal('修改类别名称', '输入新名称', sub);
                        const val = (name || '').trim();
                        if (!val || val === sub) return;
                        ensureGrouped(catKey);
                        const catObj = commonData[catKey];
                        const g = catObj.groups || {};
                        if (g[val]) { showInfo('已存在同名类别', '提示'); return; }
                        g[val] = g[sub] || [];
                        delete g[sub];
                        // 同步顺序
                        if (!Array.isArray(catObj.groupsOrder)) catObj.groupsOrder = Object.keys(g);
                        const pos = catObj.groupsOrder.indexOf(sub);
                        if (pos >= 0) catObj.groupsOrder.splice(pos, 1, val);
                        saveCommonData();
                        renderCommonTagsByCategory(catKey);
                    });

                    btnDelete.addEventListener('click', async () => {
                        const ok = await showConfirm(`确认删除类别「${sub}」？${sub==='未分组' ? '（将删除其中所有条目）' : '（其中条目将移动到"未分组"）'}`, '删除类别');
                        if (!ok) return;
                        ensureGrouped(catKey);
                        const catObj = commonData[catKey];
                        const g = catObj.groups || {};
                        if (sub === '未分组') {
                            // 删除未分组：直接删除整个未分组及其内容
                            delete g['未分组'];
                            if (Array.isArray(catObj.groupsOrder)) {
                                const i = catObj.groupsOrder.indexOf('未分组');
                                if (i >= 0) catObj.groupsOrder.splice(i, 1);
                            }
                        } else {
                            const arrOld = g[sub] || [];
                            if (arrOld.length === 0) {
                                // 空类别：直接删除，不迁移到"未分组"，不创建"未分组"
                                delete g[sub];
                                if (!Array.isArray(catObj.groupsOrder)) catObj.groupsOrder = Object.keys(g);
                                const i = catObj.groupsOrder.indexOf(sub);
                                if (i >= 0) catObj.groupsOrder.splice(i, 1);
                            } else {
                                // 非空类别：将条目迁移到"未分组"，再删除分组
                                const uf = g['未分组'] || (g['未分组'] = []);
                                arrOld.forEach(it => uf.push(it));
                                delete g[sub];
                                if (!Array.isArray(catObj.groupsOrder)) catObj.groupsOrder = Object.keys(g);
                                // 确保"未分组"在顺序中存在
                                if (!catObj.groupsOrder.includes('未分组') && g['未分组']) {
                                    catObj.groupsOrder.unshift('未分组');
                                }
                                const i = catObj.groupsOrder.indexOf(sub);
                                if (i >= 0) catObj.groupsOrder.splice(i, 1);
                            }
                        }
                        saveCommonData();
                        renderCommonTagsByCategory(catKey);
                    });

                    left.appendChild(title);
                    right.appendChild(toggle);

                    right.appendChild(btnRename);
                    right.appendChild(btnDelete);
                    right.appendChild(btnUp);
                    right.appendChild(btnDown);
                    header.appendChild(left);
                    header.appendChild(right);
                    section.appendChild(header);
                    section.appendChild(body);

                    // 为 body 容器添加拖拽事件
                    body.addEventListener('dragover', onCommonContainerDragOver);

                    // 移动类别顺序
                    btnUp.addEventListener('click', () => moveSubcat(catKey, sub, 'up'));
                    btnDown.addEventListener('click', () => moveSubcat(catKey, sub, 'down'));

                    commonTagsContainer.appendChild(section);
                });
            }
        }
        
        // 依据英文提示词查找中文描述（从 commonData 中查，支持分组）
        function findZh(enText) {
            if (!enText) return '';
            try {
                // 处理触发词组合格式: trigger_tag 或 tag_trigger
                const prefixTriggerZh = localStorage.getItem('ops_prefix_trigger_zh') || '';
                const suffixTriggerZh = localStorage.getItem('ops_suffix_trigger_zh') || '';

                // 尝试匹配前缀触发词（从多个触发词中查找）
                if (prefixTriggerZh) {
                    const prefixTriggers = prefixTriggerZh.split('|').map(t => t.trim()).filter(Boolean);
                    for (const triggerZh of prefixTriggers) {
                        const triggerEn = findEn(triggerZh);
                        if (triggerEn && enText.toLowerCase().startsWith(triggerEn.toLowerCase() + '_')) {
                            const tagEn = enText.substring(triggerEn.length + 1);
                            const tagZh = findZh(tagEn);
                            return tagZh ? `${triggerZh} ${tagZh}` : '';
                        }
                    }
                }

                // 尝试匹配后缀触发词（从多个触发词中查找）
                if (suffixTriggerZh) {
                    const suffixTriggers = suffixTriggerZh.split('|').map(t => t.trim()).filter(Boolean);
                    for (const triggerZh of suffixTriggers) {
                        const triggerEn = findEn(triggerZh);
                        if (triggerEn && enText.toLowerCase().endsWith('_' + triggerEn.toLowerCase())) {
                            const tagEn = enText.substring(0, enText.length - triggerEn.length - 1);
                            const tagZh = findZh(tagEn);
                            return tagZh ? `${tagZh} ${triggerZh}` : '';
                        }
                    }
                }

                const keys = Object.keys(commonData || {});
                for (const k of keys) {
                    const v = commonData[k];
                    if (Array.isArray(v)) {
                        for (const it of v) {
                            if ((it?.text || '').trim().toLowerCase() === enText.trim().toLowerCase()) {
                                return (it?.lang_zh || '').trim();
                            }
                        }
                    } else if (isGroupedCategory(v)) {
                        const groups = v.groups || {};
                        for (const g of Object.keys(groups)) {
                            const arr = groups[g] || [];
                            for (const it of arr) {
                                if ((it?.text || '').trim().toLowerCase() === enText.trim().toLowerCase()) {
                                    return (it?.lang_zh || '').trim();
                                }
                            }
                        }
                    }
                }
            } catch(_) {}

            // 从IELTS数据中查找中文
            try {
                if (Array.isArray(ieltsData)) {
                    for (const item of ieltsData) {
                        if ((item?.en || '').trim().toLowerCase() === enText.trim().toLowerCase()) {
                            return (item?.zh || '').trim();
                        }
                    }
                }
            } catch(_) {}

            return '';
        }

        /**
         * 标准化提示词输入（自动格式化权重标签、中英文转换等）
         * @param {Object} options - 配置选项
         * @param {boolean} options.restoreCaret - 是否恢复光标位置
         */
        function normalizePromptInput(options = {}) {
            if (!promptEditor) return;
            const raw = promptEditor.value;
            if (!raw) return;
            const segments = raw.split(/[,，]/);
            const normalized = [];
            let changed = false;
            segments.forEach(segment => {
                const trimmed = segment.trim();
                if (!trimmed) return;
                const parsed = parseWeightedTag(trimmed);
                // 中文模式下不自动转换为英文
                const en = window.__chineseMode ? null : findEn(parsed.base);
                if (en) {
                    const formatted = formatWeightedTag(en, parsed.weight);
                    normalized.push(formatted);
                    if (formatted !== trimmed) changed = true;
                } else {
                    const formatted = formatWeightedTag(parsed.base, parsed.weight);
                    normalized.push(formatted);
                    if (formatted !== trimmed) changed = true;
                }
            });
            if (!changed) return;
            const nextValue = normalized.join(', ');
            promptEditor.value = nextValue;
            if (options.restoreCaret) {
                try {
                    const pos = nextValue.length;
                    promptEditor.setSelectionRange(pos, pos);
                } catch (_) {}
            }
        }

        /**
         * 令牌数量统计（按逗号/中文逗号分割，忽略空项与尾部多余逗号）
         */
        function updateTokenCounter() {
            try {
                const val = (promptEditor.value || '').trim();
                // 分割并过滤空白
                const parts = val.split(/[,，]/).map(s => s.trim()).filter(Boolean);
                const count = parts.length;
                const el = document.getElementById('token-counter');
                if (el) el.textContent = 'Tokens: ' + count + '/75';
            } catch (_) {}
        }

        // 维护：被置灰的标签集合与上一次渲染的标签顺序
        window.__disabledTagSet = window.__disabledTagSet || new Set();
        window.__lastRenderList = window.__lastRenderList || [];

        // 处理触发词组合（支持多重组合：前缀+主标签+后缀）
        function applyTrigger(mainText, relatedText) {
            const prefixTriggerZh = localStorage.getItem('ops_prefix_trigger_zh') || '';
            const suffixTriggerZh = localStorage.getItem('ops_suffix_trigger_zh') || '';

            // 支持 ; 或 | 作为触发词分隔符
            const prefixTriggers = prefixTriggerZh.split(/[;|]/).map(t => t.trim()).filter(Boolean);
            const suffixTriggers = suffixTriggerZh.split(/[;|]/).map(t => t.trim()).filter(Boolean);

            // 解析关联词（用逗号或竖线分隔）
            const relatedParts = relatedText.split(/[,|]/).map(t => t.trim()).filter(Boolean);

            const matchedPrefix = [];
            const matchedSuffix = [];
            const unmatched = [];

            // 检查每个关联词是否匹配前缀或后缀触发词
            for (const part of relatedParts) {
                const lowerPart = part.toLowerCase();
                const isPrefix = prefixTriggers.some(t => t.toLowerCase() === lowerPart);
                const isSuffix = suffixTriggers.some(t => t.toLowerCase() === lowerPart);

                if (isPrefix) {
                    matchedPrefix.push(part);
                } else if (isSuffix) {
                    matchedSuffix.push(part);
                } else {
                    unmatched.push(part);
                }
            }

            // 如果有匹配的触发词，按顺序组合
            if (matchedPrefix.length > 0 || matchedSuffix.length > 0) {
                const parts = [];
                // 添加前缀（按顺序转换为英文）
                for (const zh of matchedPrefix) {
                    const en = findEn(zh);
                    parts.push(en || zh);
                }
                // 添加主标签
                parts.push(mainText);
                // 添加后缀（按顺序转换为英文）
                for (const zh of matchedSuffix) {
                    const en = findEn(zh);
                    parts.push(en || zh);
                }
                return { combined: parts.join('_'), unmatched };
            }

            // 没有匹配触发词，返回 null（表示独立插入关联词）
            return null;
        }

        /**
         * 初始化标签（支持点击置灰/恢复，保持原位置不变）
         */
        function updateTags() {
            normalizePromptInput();
            const text = promptEditor.value;
            const active = text.split(/[,，]/)
                .map(s => s.trim())
                .filter(Boolean);

            const normalizedActive = active.map(tag => {
                const parsed = parseWeightedTag(tag);
                const key = parsed.base.toLowerCase();
                const storedWeight = weightStateMap.get(key);
                if (Number.isFinite(storedWeight)) {
                    parsed.weight = storedWeight;
                }
                const normalizedTag = formatWeightedTag(parsed.base, parsed.weight);
                weightStateMap.set(key, parsed.weight);
                return normalizedTag;
            });

            const normalizedUniqueSet = new Set(normalizedActive);

            // 若首次渲染，用输入框的顺序初始化
            if (!Array.isArray(window.__lastRenderList) || window.__lastRenderList.length === 0) {
                window.__lastRenderList = normalizedActive.slice();
            } else {
                // 1) 从顺序表移除已不存在且未被置灰的项
                window.__lastRenderList = window.__lastRenderList.filter(t => normalizedUniqueSet.has(t) || window.__disabledTagSet.has(t));
                // 2) 将新出现（用户手动输入）的激活项追加到末尾
                normalizedActive.forEach(t => {
                    if (!window.__lastRenderList.includes(t)) window.__lastRenderList.push(t);
                });
            }

            // 渲染列表严格按照顺序表，但仅展示：激活项或置灰项
            const renderList = window.__lastRenderList.slice();

            tagsContainer.innerHTML = '';

            renderList.forEach((tag, index) => {
                let parsedTag = parseWeightedTag(tag);
                const baseText = parsedTag.base;
                const baseKey = baseText.toLowerCase();
                const storedWeight = weightStateMap.get(baseKey);
                if (Number.isFinite(storedWeight)) {
                    parsedTag = { ...parsedTag, weight: storedWeight };
                }
                let currentWeight = parsedTag.weight;
                let currentTag = formatWeightedTag(baseText, currentWeight);

                if (currentTag !== tag) {
                    const listIndex = window.__lastRenderList.indexOf(tag);
                    if (listIndex >= 0) {
                        window.__lastRenderList[listIndex] = currentTag;
                    }
                    tag = currentTag;
                }

                weightStateMap.set(baseKey, currentWeight);

                const zh = findZh(baseText) || '';
                const isInactive = window.__disabledTagSet.has(tag);
                const tagElement = document.createElement('div');
                tagElement.className = 'prompt-tag' + (isInactive ? ' inactive' : '');
                tagElement.draggable = true;
                tagElement.setAttribute('data-index', index);
                tagElement.setAttribute('data-base', baseText);
                tagElement.setAttribute('data-weight', String(currentWeight));

                const deleteBtn = document.createElement('span');
                deleteBtn.className = 'delete-tag';
                deleteBtn.setAttribute('data-role', 'del');
                deleteBtn.textContent = '×';

                const enSegment = document.createElement('span');
                enSegment.className = 'seg-en';
                enSegment.textContent = currentTag;

                const zhSegment = zh ? (() => {
                    const span = document.createElement('span');
                    span.className = 'seg-zh';
                    span.textContent = zh;
                    return span;
                })() : null;

                const weightPanel = document.createElement('div');
                weightPanel.className = 'weight-adjust';
                weightPanel.setAttribute('data-role', 'weight-panel');
                const btnDecrease = document.createElement('button');
                btnDecrease.className = 'weight-btn';
                btnDecrease.setAttribute('data-role', 'decrease');
                btnDecrease.title = '权重-';
                btnDecrease.textContent = '−';
                const weightLabelEl = document.createElement('span');
                weightLabelEl.className = 'weight-value';
                weightLabelEl.setAttribute('data-role', 'weight-label');
                weightLabelEl.textContent = (Math.round(currentWeight * 100) / 100).toFixed(2);
                const btnIncrease = document.createElement('button');
                btnIncrease.className = 'weight-btn';
                btnIncrease.setAttribute('data-role', 'increase');
                btnIncrease.title = '权重+';
                btnIncrease.textContent = '+';

                weightPanel.appendChild(btnDecrease);
                weightPanel.appendChild(weightLabelEl);
                weightPanel.appendChild(btnIncrease);

                tagElement.appendChild(deleteBtn);
                tagElement.appendChild(enSegment);
                if (zhSegment) tagElement.appendChild(zhSegment);
                tagElement.appendChild(weightPanel);

                const updateWeightView = () => {
                    weightLabelEl.textContent = (Math.round(currentWeight * 100) / 100).toFixed(2);
                    enSegment.textContent = currentTag;
                    tagElement.setAttribute('data-weight', String(currentWeight));
                };

                const applyWeightVisibility = () => {
                    const enabled = window.__weightControlsEnabled;
                    tagElement.classList.toggle('weight-disabled', !enabled);
                    weightPanel.style.display = enabled ? 'inline-flex' : 'none';
                };
                applyWeightVisibility();

                tagElement.addEventListener('click', (e) => {
                    if (e.target && (e.target.closest('[data-role="del"]') || e.target.closest('[data-role="weight-panel"]'))) return;
                    const wasInactive = window.__disabledTagSet.has(currentTag);
                    if (wasInactive) {
                        window.__disabledTagSet.delete(currentTag);
                        const orderedActive = (window.__lastRenderList || []).filter(t => !window.__disabledTagSet.has(t));
                        promptEditor.value = orderedActive.join(', ');
                        normalizePromptInput();
                    } else {
                        window.__disabledTagSet.add(currentTag);
                        const parts = (promptEditor.value || '').split(/[,，]/)
                            .map(s => formatWeightedTag(parseWeightedTag(s).base, parseWeightedTag(s).weight))
                            .filter(Boolean);
                        const pos = parts.indexOf(currentTag);
                        if (pos >= 0) {
                            parts.splice(pos, 1);
                        }
                        promptEditor.value = parts.join(', ');
                        normalizePromptInput();
                    }
                    updateTags();
                });

                const applyWeightChange = (deltaSteps) => {
                    const previousTag = currentTag;
                    const nextWeight = computeNextWeight(currentWeight, deltaSteps);
                    if (nextWeight === currentWeight) return;

                    currentWeight = nextWeight;
                    currentTag = formatWeightedTag(baseText, currentWeight);
                    weightStateMap.set(baseKey, currentWeight);
                    updateWeightView();

                    if (Array.isArray(window.__lastRenderList)) {
                        const idx = window.__lastRenderList.indexOf(previousTag);
                        if (idx >= 0) {
                            window.__lastRenderList.splice(idx, 1, currentTag);
                        }
                    }

                    if (window.__disabledTagSet.has(previousTag)) {
                        window.__disabledTagSet.delete(previousTag);
                        window.__disabledTagSet.add(currentTag);
                    }

                    let parts = (promptEditor.value || '').split(/[,，]/)
                        .map(s => formatWeightedTag(parseWeightedTag(s).base, parseWeightedTag(s).weight))
                        .filter(Boolean);
                    const textIdx = parts.indexOf(previousTag);
                    if (textIdx >= 0) {
                        parts[textIdx] = currentTag;
                        promptEditor.value = parts.join(', ');
                    }

                    normalizePromptInput();
                    updateTokenCounter();
                };

                btnDecrease.addEventListener('click', (e) => {
                    e.stopPropagation();
                    applyWeightChange(-1);
                });
                btnIncrease.addEventListener('click', (e) => {
                    e.stopPropagation();
                    applyWeightChange(1);
                });

                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    removeWeightedTag(currentTag);
                });

                tagElement.addEventListener('dragstart', handleDragStart);
                tagElement.addEventListener('dragover', handleDragOver);
                tagElement.addEventListener('drop', handleDrop);
                tagElement.addEventListener('dragend', handleDragEnd);

                tagsContainer.appendChild(tagElement);
            });

            // 同步更新计数（按输入框里激活的项）
            updateTokenCounter();
        }
        
        // 拖拽功能
        let draggedItem = null;
        let placeholderEl = null;
        
        function handleDragStart(e) {
            draggedItem = this;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.innerHTML);
        }
        
        function handleDragOver(e) {
            // 统一交给容器级处理，确保空白区域也可放置
            return onContainerDragOver(e);
        }
        
        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();

            // 当前渲染顺序（包含置灰项），以它为准进行重排
            const list = Array.isArray(window.__lastRenderList) ? window.__lastRenderList.slice() : [];
            if (!draggedItem || !list.length) { updateTags(); return false; }

            const fromIndex = parseInt(draggedItem.getAttribute('data-index'), 10);

            // 计算目标索引：占位条（placeholderEl）之前的 .prompt-tag 数量
            let toIndex = fromIndex;
            const children = Array.from(tagsContainer.children);
            if (placeholderEl && tagsContainer.contains(placeholderEl)) {
                let countBefore = 0;
                let hit = false;
                for (const el of children) {
                    if (el === placeholderEl) { hit = true; break; }
                    if (el.classList && el.classList.contains('prompt-tag')) countBefore++;
                }
                toIndex = hit ? countBefore : countBefore; // 若占位在末尾，countBefore 即为末尾索引
            } else {
                // 兜底：以当前目标元素位置估算
                let countBefore = 0;
                for (const el of children) {
                    if (el === this) break;
                    if (el.classList && el.classList.contains('prompt-tag')) countBefore++;
                }
                toIndex = countBefore;
            }

            if (!Number.isNaN(fromIndex) && !Number.isNaN(toIndex) && fromIndex !== toIndex) {
                const [moved] = list.splice(fromIndex, 1);
                // 防御：约束范围
                const safeTo = Math.max(0, Math.min(toIndex, list.length));
                list.splice(safeTo, 0, moved);
                window.__lastRenderList = list;

                // 仅用"激活项"（排除置灰项）写回文本
                const disabledSet = window.__disabledTagSet || new Set();
                const orderedActive = list.filter(t => !disabledSet.has(t));
                promptEditor.value = orderedActive.join(', ');
                normalizePromptInput();
            }

            updateTags();
            return false;
        }
        
        function handleDragEnd(e) {
            this.classList.remove('dragging');
            document.querySelectorAll('.prompt-tag').forEach(tag => {
                tag.classList.remove('dragging');
            });
            // 清理占位条
            if (placeholderEl && placeholderEl.parentNode) {
                placeholderEl.parentNode.removeChild(placeholderEl);
            }
            placeholderEl = null;
        }

        // 容器级拖拽：允许在空白区域放置，并精确计算插入索引（支持多行）
        function getInsertIndexByPoint(x, y) {
            const items = Array.from(tagsContainer.querySelectorAll('.prompt-tag'));
            if (!items.length) return 0;
            const TOL = 8; // 行判定的垂直容差

            // 1) 先尝试找到与鼠标 Y 同行（含容差）的所有元素
            const sameRow = items.filter(el => {
                const r = el.getBoundingClientRect();
                return y >= r.top - TOL && y <= r.bottom + TOL;
            });

            if (sameRow.length) {
                // 在该行内按 X 决定插入到哪个元素之前
                for (let i = 0; i < sameRow.length; i++) {
                    const r = sameRow[i].getBoundingClientRect();
                    const mid = r.left + r.width / 2;
                    if (x < mid) return items.indexOf(sameRow[i]);
                }
                // 若都在所有元素中点右侧，插入到同行最后一个之后
                return items.indexOf(sameRow[sameRow.length - 1]) + 1;
            }

            // 2) 若没有同行元素，选择垂直距离最近的一行中的一个锚点元素
            let anchor = items[items.length - 1];
            let minDist = Infinity;
            items.forEach(el => {
                const r = el.getBoundingClientRect();
                const cy = r.top + r.height / 2;
                const d = Math.abs(y - cy);
                if (d < minDist) { minDist = d; anchor = el; }
            });
            const r = anchor.getBoundingClientRect();
            const mid = r.left + r.width / 2;
            const baseIdx = items.indexOf(anchor);
            return x < mid ? baseIdx : baseIdx + 1;
        }

        function onContainerDragOver(e) {
            if (!draggedItem) return false;
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            if (!placeholderEl) {
                placeholderEl = document.createElement('div');
                placeholderEl.className = 'tag-placeholder';
            }
            const idx = getInsertIndexByPoint(e.clientX, e.clientY);
            const items = Array.from(tagsContainer.querySelectorAll('.prompt-tag'));
            if (idx >= items.length) {
                if (placeholderEl.parentNode !== tagsContainer || placeholderEl.nextElementSibling !== null) {
                    tagsContainer.appendChild(placeholderEl);
                }
            } else {
                const ref = items[idx];
                if (ref.previousSibling !== placeholderEl) {
                    tagsContainer.insertBefore(placeholderEl, ref);
                }
            }
            return false;
        }

        function onContainerDrop(e) {
            if (!draggedItem) return false;
            e.preventDefault();
            e.stopPropagation();

            const list = Array.isArray(window.__lastRenderList) ? window.__lastRenderList.slice() : [];
            if (!list.length) { updateTags(); return false; }

            const fromIndex = parseInt(draggedItem.getAttribute('data-index'), 10);
            let toIndex = getInsertIndexByPoint(e.clientX, e.clientY);

            if (!Number.isNaN(fromIndex) && !Number.isNaN(toIndex) && fromIndex !== toIndex) {
                const [moved] = list.splice(fromIndex, 1);
                // 拖起位置在目标之前时，移除后目标索引左移一位
                if (fromIndex < toIndex) toIndex -= 1;
                const safeTo = Math.max(0, Math.min(toIndex, list.length));
                list.splice(safeTo, 0, moved);
                window.__lastRenderList = list;

                const disabledSet = window.__disabledTagSet || new Set();
                const orderedActive = list.filter(t => !disabledSet.has(t));
                promptEditor.value = orderedActive.join(', ');
                normalizePromptInput();
            }

            // 清理占位条
            if (placeholderEl && placeholderEl.parentNode) {
                placeholderEl.parentNode.removeChild(placeholderEl);
            }
            placeholderEl = null;

            updateTags();
            return false;
        }

        // 绑定容器级事件（确保空白区域可放置）
        if (tagsContainer) {
            tagsContainer.addEventListener('dragover', onContainerDragOver);
            tagsContainer.addEventListener('drop', onContainerDrop);
        }

        // ========== common-tags 拖拽排序功能 ==========
        let draggedCommonTag = null;
        let commonPlaceholderEl = null;
        let commonDragSourceContainer = null;

        function handleCommonTagDragStart(e) {
            draggedCommonTag = this;
            this.classList.add('dragging');
            commonDragSourceContainer = this.closest('[data-container-type]') || this.parentElement;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.innerHTML);
        }

        function handleCommonTagDragOver(e) {
            return onCommonContainerDragOver(e);
        }

        function handleCommonTagDrop(e) {
            e.preventDefault();
            e.stopPropagation();

            if (!draggedCommonTag) return false;

            const targetContainer = e.target.closest('[data-container-type]') || e.target.closest('.common-tags') || e.target.parentElement;

            if (!targetContainer) return false;

            const cat = draggedCommonTag.dataset.cat;
            const fromSubcat = draggedCommonTag.dataset.subcat || '';
            const fromIndex = parseInt(draggedCommonTag.dataset.index, 10);

            const toSubcat = targetContainer.dataset.subcat || '';

            // 直接根据鼠标位置计算目标索引（与 prompt-tags 完全一致）
            let toIndex = getCommonInsertIndexByPoint(e.clientX, e.clientY, targetContainer);

            if (!Number.isNaN(fromIndex) && !Number.isNaN(toIndex)) {
                if (cat && (fromSubcat !== toSubcat || targetContainer !== commonDragSourceContainer)) {
                    // 跨容器移动
                    moveCommonTagTo(cat, fromSubcat, fromIndex, toSubcat, toIndex);
                } else if (fromIndex !== toIndex) {
                    // 同容器内排序
                    reorderCommonTags(targetContainer, fromIndex, toIndex);
                }
            }

            cleanupCommonDrag();
            return false;
        }

        function handleCommonTagDragEnd(e) {
            this.classList.remove('dragging');
            document.querySelectorAll('.common-tag').forEach(tag => {
                tag.classList.remove('dragging');
            });
            cleanupCommonDrag();
        }

        function cleanupCommonDrag() {
            if (commonPlaceholderEl && commonPlaceholderEl.parentNode) {
                commonPlaceholderEl.parentNode.removeChild(commonPlaceholderEl);
            }
            commonPlaceholderEl = null;
            draggedCommonTag = null;
            commonDragSourceContainer = null;
        }

        function getCommonInsertIndexByPoint(x, y, container) {
            const items = Array.from(container.querySelectorAll('.common-tag'));
            if (!items.length) return 0;
            const TOL = 8;

            const sameRow = items.filter(el => {
                const r = el.getBoundingClientRect();
                return y >= r.top - TOL && y <= r.bottom + TOL;
            });

            if (sameRow.length) {
                for (let i = 0; i < sameRow.length; i++) {
                    const r = sameRow[i].getBoundingClientRect();
                    const mid = r.left + r.width / 2;
                    if (x < mid) return items.indexOf(sameRow[i]);
                }
                return items.indexOf(sameRow[sameRow.length - 1]) + 1;
            }

            let anchor = items[items.length - 1];
            let minDist = Infinity;
            items.forEach(el => {
                const r = el.getBoundingClientRect();
                const cy = r.top + r.height / 2;
                const d = Math.abs(y - cy);
                if (d < minDist) { minDist = d; anchor = el; }
            });
            const r = anchor.getBoundingClientRect();
            const mid = r.left + r.width / 2;
            const baseIdx = items.indexOf(anchor);
            return x < mid ? baseIdx : baseIdx + 1;
        }

        function onCommonContainerDragOver(e) {
            if (!draggedCommonTag) return false;
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            if (!commonPlaceholderEl) {
                commonPlaceholderEl = document.createElement('div');
                commonPlaceholderEl.className = 'tag-placeholder';
            }

            const targetContainer = e.target.closest('[data-container-type]') || e.target.closest('.common-tags');
            if (!targetContainer) return false;

            const idx = getCommonInsertIndexByPoint(e.clientX, e.clientY, targetContainer);
            const items = Array.from(targetContainer.querySelectorAll('.common-tag'));

            if (idx >= items.length) {
                if (commonPlaceholderEl.parentNode !== targetContainer || commonPlaceholderEl.nextElementSibling !== null) {
                    targetContainer.appendChild(commonPlaceholderEl);
                }
            } else {
                const ref = items[idx];
                if (ref.previousSibling !== commonPlaceholderEl) {
                    targetContainer.insertBefore(commonPlaceholderEl, ref);
                }
            }
            return false;
        }

        function reorderCommonTags(container, fromIndex, toIndex) {
            const cat = container.dataset.cat;
            const subcat = container.dataset.subcat || '';

            if (!cat) return;

            const data = commonData?.[cat];
            if (!data) return;

            if (isGroupedCategory(data) && subcat) {
                const arr = data.groups?.[subcat];
                if (Array.isArray(arr)) {
                    const [moved] = arr.splice(fromIndex, 1);
                    // 防御：约束范围
                    if (fromIndex < toIndex) toIndex -= 1;
                    const safeTo = Math.max(0, Math.min(toIndex, arr.length));
                    arr.splice(safeTo, 0, moved);
                    saveCommonData();
                    renderCommonTagsByCategory(cat);
                }
            } else if (Array.isArray(data)) {
                const [moved] = data.splice(fromIndex, 1);
                // 防御：约束范围
                if (fromIndex < toIndex) toIndex -= 1;
                const safeTo = Math.max(0, Math.min(toIndex, data.length));
                data.splice(safeTo, 0, moved);
                saveCommonData();
                renderCommonTagsByCategory(cat);
            }
        }

        function moveCommonTag(cat, fromSubcat, fromIndex, targetContainer) {
            const toSubcat = targetContainer.dataset.subcat || '';

            if (!cat) return;

            const data = commonData?.[cat];
            if (!isGroupedCategory(data)) return;

            const fromArr = data.groups?.[fromSubcat];
            if (!Array.isArray(fromArr)) return;

            const [movedItem] = fromArr.splice(fromIndex, 1);

            if (!data.groups[toSubcat]) {
                data.groups[toSubcat] = [];
            }
            data.groups[toSubcat].push(movedItem);

            saveCommonData();
            renderCommonTagsByCategory(cat);
        }

        function moveCommonTagTo(cat, fromSubcat, fromIndex, toSubcat, toIndex) {
            if (!cat) return;

            const data = commonData?.[cat];
            if (!isGroupedCategory(data)) return;

            const fromArr = data.groups?.[fromSubcat];
            if (!Array.isArray(fromArr)) return;

            const [movedItem] = fromArr.splice(fromIndex, 1);

            if (!data.groups[toSubcat]) {
                data.groups[toSubcat] = [];
            }

            const toArr = data.groups[toSubcat];
            const safeTo = Math.max(0, Math.min(toIndex, toArr.length));
            toArr.splice(safeTo, 0, movedItem);

            saveCommonData();
            renderCommonTagsByCategory(cat);
        }

        // 移除标签
        function removeTag(index) {
            const tags = promptEditor.value.split(/[,，]/).map(tag => tag.trim()).filter(tag => tag.length > 0);
            tags.splice(index, 1);
            promptEditor.value = tags.join(', ');
            updateTags();
        }

        function removeWeightedTag(tag) {
            const parsed = parseWeightedTag(tag);
            const baseKey = parsed.base.toLowerCase();
            let parts = (promptEditor.value || '').split(/[,，]/)
                .map(s => formatWeightedTag(parseWeightedTag(s).base, parseWeightedTag(s).weight))
                .filter(Boolean);
            parts = parts.filter(t => t !== tag);
            promptEditor.value = parts.join(', ');
            normalizePromptInput();
            if (window.__disabledTagSet.has(tag)) window.__disabledTagSet.delete(tag);
            window.__lastRenderList = (window.__lastRenderList || []).filter(t => t !== tag);
            weightStateMap.delete(baseKey);
            updateTags();
        }
        
        // 重置提示词
        function resetPrompt() {
            promptEditor.value = '';
            normalizePromptInput();
            updateTags();
        }
        
        // 复制提示词
        async function copyPrompt() {
            const text = promptEditor.value || '';
            try {
                await navigator.clipboard.writeText(text);
            } catch (e) {
                const ta = document.createElement('textarea');
                ta.value = text;
                document.body.appendChild(ta);
                ta.select();
                try { document.execCommand('copy'); } finally { document.body.removeChild(ta); }
            }
        }

        // 随机选择当前分类的标签并追加到编辑器
        function randomPickFromActive() {
            const cat = getActiveCategory();
            if (!cat) { showInfo('请先创建或选择一个分类', '提示'); return; }
            const v = commonData[cat];
            const picks = [];
            if (isGroupedCategory(v)) {
                const groups = v.groups || {};
                const groupNames = Object.keys(groups).filter(name => Array.isArray(groups[name]) && groups[name].length > 0);
                if (!groupNames.length) { showInfo('该分类下没有可用的小标签', '提示'); return; }
                const k = Math.floor(Math.random() * groupNames.length) + 1; // 1..N
                const shuffled = groupNames.slice().sort(() => Math.random() - 0.5);
                const chosen = shuffled.slice(0, k);
                chosen.forEach(name => {
                    const arr = groups[name];
                    const it = arr[Math.floor(Math.random() * arr.length)];
                    if (it && it.text) picks.push(it.text);
                });
            } else if (Array.isArray(v)) {
                if (!v.length) { showInfo('该分类下没有标签', '提示'); return; }
                const max = Math.min(4, v.length);
                const k = Math.floor(Math.random() * max) + 1; // 1..max
                const idxs = [...Array(v.length).keys()].sort(() => Math.random() - 0.5).slice(0, k);
                idxs.forEach(i => { const it = v[i]; if (it && it.text) picks.push(it.text); });
            } else {
                showInfo('该分类暂无标签', '提示'); return;
            }
            if (!picks.length) { showInfo('未选出可用标签', '提示'); return; }
            const cur = promptEditor.value.trim();
            const add = picks.join(', ');
            promptEditor.value = cur ? (cur + ', ' + add) : add;
            normalizePromptInput();
            updateTags();
            promptEditor.focus();
        }

        // 全局随机：每个大标签至少1个；若为分组结构则每个小标签至多1个
        function randomPickAll() {
            const picks = [];
            const cats = Object.keys(commonData || {});
            cats.forEach(cat => {
                const v = commonData[cat];
                if (v && typeof v === 'object' && !Array.isArray(v) && v.groups && typeof v.groups === 'object') {
                    // 分组结构：每个非空小标签取1条
                    const groups = v.groups || {};
                    Object.keys(groups).forEach(sub => {
                        const arr = Array.isArray(groups[sub]) ? groups[sub] : [];
                        if (arr.length > 0) {
                            const it = arr[Math.floor(Math.random() * arr.length)];
                            if (it && it.text) picks.push(it.text);
                        }
                    });
                } else if (Array.isArray(v)) {
                    // 非分组：该大标签取1条
                    if (v.length > 0) {
                        const it = v[Math.floor(Math.random() * v.length)];
                        if (it && it.text) picks.push(it.text);
                    }
                }
            });
            if (!picks.length) { showInfo('暂无可随机的标签', '提示'); return; }
            // 覆盖写入（先清空再写入）
            promptEditor.value = picks.join(', ');
            normalizePromptInput();
            updateTags();
            promptEditor.focus();
        }

        // ==================== 历史快照存储与查看 ====================
        function loadHistory() {
            try {
                const raw = localStorage.getItem(HISTORY_KEY);
                const arr = raw ? JSON.parse(raw) : [];
                return Array.isArray(arr) ? arr : [];
            } catch(e) { return []; }
        }
        function saveHistory(arr) {
            try { localStorage.setItem(HISTORY_KEY, JSON.stringify(arr)); } catch(e) {}
        }
        function formatDate(ts) {
            const d = new Date(ts);
            const y = d.getFullYear();
            const m = d.getMonth() + 1;
            const day = d.getDate();
            return `${y}年${m}月${day}日`;
        }
        function isToday(ts) {
            const d = new Date(ts);
            const now = new Date();
            return d.getFullYear() === now.getFullYear() && d.getMonth() === now.getMonth() && d.getDate() === now.getDate();
        }
        function savePromptSnapshot() {
            const text = (promptEditor.value || '').trim();
            if (!text) { showInfo('内容为空，无法存储', '提示'); return; }
            const arr = loadHistory();
            arr.push({ ts: Date.now(), text });
            saveHistory(arr);
            showInfo('已存储当前提示词内容', '存储成功');
        }
        function openHistoryModal() {
            const wrap = document.getElementById('modal-history');
            const list = document.getElementById('history-list');
            const btnClose = document.getElementById('modal-history-close');
            const btnClear = document.getElementById('modal-history-clear');

            // 原始数组（用于删除定位）
            const arrRaw = loadHistory();
            // 排序并携带原始索引
            const arrSorted = arrRaw.map((v, i) => ({ ...v, _idx: i })).sort((a, b) => b.ts - a.ts);

            // 分组：按日期分组
            const groups = {};
            arrSorted.forEach(it => {
                const k = formatDate(it.ts);
                if (!groups[k]) groups[k] = [];
                groups[k].push(it);
            });

            // 渲染
            list.innerHTML = '';
            const todayStr = formatDate(Date.now());
            Object.keys(groups).forEach(dateStr => {
                const items = groups[dateStr];
                const sec = document.createElement('div');
                sec.style.border = '1px solid var(--border-color)';
                sec.style.borderRadius = '8px';
                sec.style.overflow = 'hidden';

                const header = document.createElement('div');
                header.style.padding = '10px 12px';
                header.style.background = 'var(--bg-color)';
                header.style.display = 'flex';
                header.style.justifyContent = 'space-between';
                header.style.alignItems = 'center';

                const title = document.createElement('span');
                title.textContent = dateStr;

                const toggle = document.createElement('button');
                toggle.className = 'btn btn-outline';
                toggle.textContent = '折叠/展开';

                const body = document.createElement('div');
                body.style.display = (dateStr === todayStr) ? 'block' : 'none';
                body.style.padding = '10px 12px';

                items.forEach(it => {
                    const itemEl = document.createElement('div');
                    itemEl.style.borderTop = '1px dashed var(--border-color)';
                    itemEl.style.padding = '8px 0';

                    // 顶部行：时间 + 操作按钮
                    const topRow = document.createElement('div');
                    topRow.style.display = 'flex';
                    topRow.style.justifyContent = 'space-between';
                    topRow.style.alignItems = 'center';

                    const time = new Date(it.ts);
                    const timeStr = `${time.getHours().toString().padStart(2,'0')}:${time.getMinutes().toString().padStart(2,'0')}:${time.getSeconds().toString().padStart(2,'0')}`;
                    const timeEl = document.createElement('div');
                    timeEl.style.fontSize = '0.85rem';
                    timeEl.style.opacity = '.7';
                    timeEl.textContent = timeStr;

                    const ops = document.createElement('div');
                    ops.style.display = 'flex';
                    ops.style.gap = '8px';

                    // 新增：导入按钮（清空后导入到编辑区）
                    const btnImport = document.createElement('button');
                    btnImport.className = 'btn btn-outline';
                    btnImport.textContent = '导入';
                    btnImport.addEventListener('click', () => {
                        const t = it.text || '';
                        promptEditor.value = '';      // 先清空
                        promptEditor.value = t;       // 再写入
                        normalizePromptInput();
                        updateTags();
                        promptEditor.focus();
                        // 导入后关闭"提示词历史"弹窗
                        onClose();
                    });

                    const btnCopy = document.createElement('button');
                    btnCopy.className = 'btn btn-outline';
                    btnCopy.textContent = '复制';
                    btnCopy.addEventListener('click', async () => {
                        try {
                            await navigator.clipboard.writeText(it.text || '');
                            showInfo('已复制到剪贴板', '复制成功');
                        } catch (e) {
                            showInfo('复制失败，请手动选择文本复制', '复制失败');
                        }
                    });

                    const btnDel = document.createElement('button');
                    btnDel.className = 'btn btn-outline';
                    btnDel.textContent = '删除';
                    btnDel.addEventListener('click', async () => {
                        const ok = await showConfirm('确认删除该历史记录？', '删除记录');
                        if (!ok) return;
                        const idx = it._idx;
                        if (typeof idx === 'number' && idx >= 0) {
                            const arrNew = loadHistory();
                            if (idx < arrNew.length && (arrNew[idx]?.ts === it.ts) && (arrNew[idx]?.text === it.text)) {
                                arrNew.splice(idx, 1);
                            } else {
                                // 回退策略：按 ts+text 查找
                                const pos = arrNew.findIndex(x => x.ts === it.ts && x.text === it.text);
                                if (pos >= 0) arrNew.splice(pos, 1);
                            }
                            saveHistory(arrNew);
                            openHistoryModal(); // 重新渲染
                        }
                    });

                    // 顺序：导入、复制、删除
                    ops.appendChild(btnImport);
                    ops.appendChild(btnCopy);
                    ops.appendChild(btnDel);
                    topRow.appendChild(timeEl);
                    topRow.appendChild(ops);

                    // 正文
                    const contentRow = document.createElement('pre');
                    contentRow.style.whiteSpace = 'pre-wrap';
                    contentRow.style.wordBreak = 'break-word';
                    contentRow.style.margin = '6px 0 0 0';
                    contentRow.textContent = it.text || '';

                    // 中文标签行：从英文文本拆分并映射中文
                    const zhRow = document.createElement('div');
                    zhRow.style.display = 'flex';
                    zhRow.style.flexWrap = 'wrap';
                    zhRow.style.gap = '6px';
                    zhRow.style.marginTop = '8px';

                    const parts = (it.text || '').split(/[,，]/).map(s => s.trim()).filter(Boolean);
                    parts.forEach(en => {
                        const zh = findZh(en);
                        if (!zh) return;
                        const tag = document.createElement('span');
                        tag.className = 'common-tag';
                        tag.textContent = zh;
                        tag.title = en;
                        zhRow.appendChild(tag);
                    });

                    itemEl.appendChild(topRow);
                    itemEl.appendChild(contentRow);
                    itemEl.appendChild(zhRow);
                    body.appendChild(itemEl);
                });

                toggle.addEventListener('click', () => {
                    const now = body.style.display !== 'none';
                    body.style.display = now ? 'none' : 'block';
                });

                header.appendChild(title);
                header.appendChild(toggle);
                sec.appendChild(header);
                sec.appendChild(body);
                list.appendChild(sec);
            });

            // 事件
            function onKey(e) {
                if (e.key === 'Escape') onClose();
            }
            function cleanup() {
                btnClose.removeEventListener('click', onClose);
                btnClear.removeEventListener('click', onClear);
                document.removeEventListener('keydown', onKey);
                hide(wrap);
            }
            function onClose() { cleanup(); }
            async function onClear() {
                const ok = await showConfirm('确认清空全部历史快照？', '清空历史');
                if (!ok) return;
                saveHistory([]);
                openHistoryModal(); // 重新渲染
            }

            btnClose.addEventListener('click', onClose);
            btnClear.addEventListener('click', onClear);
            document.addEventListener('keydown', onKey);
            show(wrap);
        }
        
        // 模态框逻辑
        function show(el) { el.style.display = 'flex'; }
        function hide(el) { el.style.display = 'none'; }

        function openCategoryModal(oldName) {
            const wrap = document.getElementById('modal-category');
            const input = document.getElementById('modal-cat-name');
            const confirmBtn = document.getElementById('modal-cat-confirm');
            const cancelBtn = document.getElementById('modal-cat-cancel');
            const closeBtn = document.getElementById('modal-cat-close');
            input.value = oldName ? oldName : '';
            show(wrap);
            setTimeout(() => input.focus(), 0);

            const onConfirm = () => {
                const newName = (input.value || '').trim();
                if (!newName) { input.focus(); return; }
                if (oldName && newName !== oldName) {
                    // 重命名分类
                    if (commonData[newName]) {
                        showInfo('已存在同名分类', '提示');
                        return;
                    }
                    const items = commonData[oldName] || [];
                    delete commonData[oldName];
                    commonData[newName] = items;
                    saveCommonData();
                    setActiveCategory(newName);
                    renderSidebar();
                } else if (!oldName) {
                    if (!commonData[newName]) commonData[newName] = [];
                    saveCommonData();
                    setActiveCategory(newName);
                    renderSidebar();
                }
                cleanup();
            };
            const onCancel = () => cleanup();

            function cleanup() {
                confirmBtn.removeEventListener('click', onConfirm);
                cancelBtn.removeEventListener('click', onCancel);
                closeBtn.removeEventListener('click', onCancel);
                input.removeEventListener('keydown', onKey);
                hide(wrap);
            }
            function onKey(e) {
                if (e.key === 'Enter') onConfirm();
                if (e.key === 'Escape') onCancel();
            }

            confirmBtn.addEventListener('click', onConfirm);
            cancelBtn.addEventListener('click', onCancel);
            closeBtn.addEventListener('click', onCancel);
            input.addEventListener('keydown', onKey);
        }

        function openTagModal(cat, index, subcat) {
            const wrap = document.getElementById('modal-tag');
            const title = document.getElementById('modal-tag-title');
            const zh = document.getElementById('modal-tag-zh');
            const en = document.getElementById('modal-tag-en');
            const related = document.getElementById('modal-tag-related');
            const tokenInput = document.getElementById('modal-cy-token');
            const translateBtn = document.getElementById('modal-tag-translate');
            const translateMyBtn = document.getElementById('modal-tag-translate-mymemory');
            const confirmBtn = document.getElementById('modal-tag-confirm');
            const cancelBtn = document.getElementById('modal-tag-cancel');
            const closeBtn = document.getElementById('modal-tag-close');
            const subBtnsWrap = document.getElementById('modal-subcat-buttons');
            const subNewBtn = document.getElementById('modal-subcat-newbtn');
            const styleBtnsWrap = document.getElementById('modal-style-buttons');
            const LAST_SUBCAT_KEY = 'ops_last_subcat_' + cat;
            const LAST_STYLE_KEY = 'ops_last_style';

            const editing = typeof index === 'number';
            title.textContent = editing ? '编辑标签' : '添加标签';

            // 样式选择
            let selectedStyle = 'default';

            // 初始化样式按钮
            function initStyleButtons() {
                if (!styleBtnsWrap) return;
                const buttons = styleBtnsWrap.querySelectorAll('button[data-style]');
                buttons.forEach(btn => {
                    btn.onclick = null;
                    btn.addEventListener('click', () => {
                        selectedStyle = btn.dataset.style;
                        try { localStorage.setItem(LAST_STYLE_KEY, selectedStyle); } catch(e) {}
                        updateStyleButtons();
                    });
                });
                // 恢复上次选择的样式
                try { selectedStyle = localStorage.getItem(LAST_STYLE_KEY) || 'default'; } catch(e) {}
                updateStyleButtons();
            }

            function updateStyleButtons() {
                if (!styleBtnsWrap) return;
                const buttons = styleBtnsWrap.querySelectorAll('button[data-style]');
                buttons.forEach(btn => {
                    if (btn.dataset.style === selectedStyle) {
                        btn.classList.add('active');
                        btn.setAttribute('aria-pressed', 'true');
                    } else {
                        btn.classList.remove('active');
                        btn.setAttribute('aria-pressed', 'false');
                    }
                });
            }

            initStyleButtons();

            // 类别按钮渲染（默认恢复上次选择；若无记录，稍后自动选第一个）
            let selectedSub = subcat || (function(){ try { return localStorage.getItem(LAST_SUBCAT_KEY) || ''; } catch(e){ return ''; } })();
            function renderSubButtons() {
                if (!subBtnsWrap) return;
                // 清空旧按钮（保留"新建类别"按钮）
                Array.from(subBtnsWrap.querySelectorAll('button[data-subcat]')).forEach(el => el.remove());
                const v0 = commonData?.[cat];
                const names = [];
                if (isGroupedCategory(v0)) {
                    const g = v0.groups || {};
                    const order = Array.isArray(v0.groupsOrder)
                        ? v0.groupsOrder.filter(n => Object.prototype.hasOwnProperty.call(g, n))
                            .concat(Object.keys(g).filter(n => !v0.groupsOrder.includes(n)))
                        : Object.keys(g);
                    order.forEach(k => names.push(k));
                }
                // 若当前没有选中小类别，则默认选中第一个
                if (!selectedSub && names.length) {
                    selectedSub = names[0];
                    try { localStorage.setItem(LAST_SUBCAT_KEY, selectedSub); } catch(e) {}
                }
                names.forEach(name => {
                    const btn = document.createElement('button');
                    btn.className = 'btn btn-outline btn-toggle' + (selectedSub === name ? ' active' : '');
                    btn.type = 'button';
                    btn.textContent = name;
                    btn.dataset.subcat = name;
                    btn.setAttribute('aria-pressed', selectedSub === name ? 'true' : 'false');
                    btn.addEventListener('click', () => {
                        selectedSub = name;
                        try { localStorage.setItem(LAST_SUBCAT_KEY, selectedSub); } catch(e) {}
                        renderSubButtons();
                    });
                    subBtnsWrap.appendChild(btn);
                });
            }
            if (subNewBtn) {
                // 覆盖式绑定，避免重复 addEventListener 导致多次弹窗
                subNewBtn.onclick = null;
                subNewBtn.onclick = async () => {
                    const name = await showInputModal('新建类别', '输入名称', '');
                    const val = (name || '').trim();
                    if (!val) return;
                    ensureGrouped(cat);
                    const catObj = commonData[cat];
                    const g = catObj.groups;
                    if (!g[val]) g[val] = [];
                    if (!Array.isArray(catObj.groupsOrder)) catObj.groupsOrder = Object.keys(g);
                    if (!catObj.groupsOrder.includes(val)) catObj.groupsOrder.push(val);
                    selectedSub = val;
                    try { localStorage.setItem(LAST_SUBCAT_KEY, selectedSub); } catch(e) {}
                    saveCommonData();
                    renderSubButtons(); // 刷新弹窗内按钮
                    renderCommonTagsByCategory(cat); // 同步刷新主界面分组，无需关闭弹窗
                };
            }
            renderSubButtons();

            // 预填表单
            const v = commonData?.[cat];
            if (editing) {
                if (isGroupedCategory(v) && subcat) {
                    const item = ((v.groups?.[subcat]) || [])[index] || {};
                    zh.value = item.lang_zh || '';
                    en.value = item.text || '';
                    related.value = item.related || '';
                    selectedStyle = item.style || 'default';
                } else {
                    const item = (Array.isArray(v) ? v : [])[index] || {};
                    zh.value = item.lang_zh || '';
                    en.value = item.text || '';
                    related.value = item.related || '';
                    selectedStyle = item.style || 'default';
                }
                updateStyleButtons();
            } else {
                zh.value = '';
                en.value = '';
                related.value = '';
                selectedStyle = 'default';
                updateStyleButtons();
            }
            // 预填 token
            try { tokenInput.value = localStorage.getItem('ops_cy_token') || ''; } catch(e) {}

            show(wrap);
            setTimeout(() => (editing ? en : zh).focus(), 0);

            // 翻译函数
            const onTranslate = async () => {
                const lang_zh = (zh.value || '').trim();
                const token = (tokenInput.value || '').trim();
                if (!lang_zh) { zh.focus(); return; }
                if (!token) { tokenInput.focus(); return; }
                try { localStorage.setItem('ops_cy_token', token); } catch(e) {}
                try {
                    const res = await fetch('https://api.interpreter.caiyunai.com/v1/translator', {
                        method: 'POST',
                        headers: {
                            'content-type': 'application/json',
                            'x-authorization': 'token ' + token
                        },
                        body: JSON.stringify({
                            source: [lang_zh],
                            trans_type: 'auto2en',
                            request_id: 'ops',
                            detect: true
                        })
                    });
                    if (!res.ok) throw new Error('HTTP ' + res.status);
                    const data = await res.json();
                    const target = Array.isArray(data?.target) ? data.target[0] : (data?.target || '');
                    if (!target) throw new Error('翻译结果为空');
                    en.value = target;
                } catch (err) {
                    showInfo('翻译失败：' + (err?.message || err), '翻译失败');
                }
            };

            // MyMemory 翻译：无需令牌，直接 GET
            const onTranslateMyMemory = async () => {
                const lang_zh = (zh.value || '').trim();
                if (!lang_zh) { zh.focus(); return; }
                try {
                    const url = 'https://api.mymemory.translated.net/get?q=' + encodeURIComponent(lang_zh) + '&langpair=zh|en';
                    const res = await fetch(url, { method: 'GET' });
                    if (!res.ok) throw new Error('HTTP ' + res.status);
                    const data = await res.json();
                    const target = (data && data.responseData && data.responseData.translatedText) ? data.responseData.translatedText : '';
                    if (!target) throw new Error('翻译结果为空');
                    en.value = target;
                } catch (err) {
                    showInfo('MyMemory 翻译失败：' + (err?.message || err), '翻译失败');
                }
            };

            const onConfirm = async () => {
                const lang_zh2 = (zh.value || '').trim();
                let text2 = (en.value || '').trim();
                const related2 = (related.value || '').trim();

                // 自动翻译：若存在 Token 且英文为空，仅有中文，则先翻译再保存
                if (lang_zh2 && !text2) {
                    let token = '';
                    try { token = (tokenInput.value || '').trim() || (localStorage.getItem('ops_cy_token') || ''); } catch(e) {}
                    if (token) {
                        try {
                            // 持久化 Token
                            try { localStorage.setItem('ops_cy_token', token); } catch(e) {}
                            const res = await fetch('https://api.interpreter.caiyunai.com/v1/translator', {
                                method: 'POST',
                                headers: {
                                    'content-type': 'application/json',
                                    'x-authorization': 'token ' + token
                                },
                                body: JSON.stringify({
                                    source: [lang_zh2],
                                    trans_type: 'auto2en',
                                    request_id: 'ops',
                                    detect: true
                                })
                            });
                            if (!res.ok) throw new Error('HTTP ' + res.status);
                            const data = await res.json();
                            const target = Array.isArray(data?.target) ? data.target[0] : (data?.target || '');
                            if (target) {
                                text2 = target;
                                en.value = target;
                            }
                        } catch (err) {
                            // 翻译失败则回退到手动填写
                        }
                    }
                }

                // 支持多标签：按英文逗号(,)、中文逗号(,)、英文分号(;)、中文分号(；)、顿号(、)分割
                const zhParts = lang_zh2.split(/[,，;；、]+/).map(s => s.trim()).filter(Boolean);
                const enParts = text2.split(/[,，;；、]+/).map(s => s.trim()).filter(Boolean);

                // 验证至少有一个标签对
                if (zhParts.length === 0 || enParts.length === 0) {
                    zh.focus();
                    return;
                }

                const targetSub = (selectedSub || '').trim();
                const vNow = commonData?.[cat];
                const tagsToAdd = [];

                // 生成标签对（取较大值，缺失部分为空）
                const maxLength = Math.max(zhParts.length, enParts.length);
                for (let i = 0; i < maxLength; i++) {
                    tagsToAdd.push({
                        lang_zh: zhParts[i] || '',
                        text: enParts[i] || ''
                    });
                }

                if (editing) {
                    // 编辑模式：只更新单个标签，不支持批量编辑
                    const zhSingle = zhParts[0] || lang_zh2;
                    const enSingle = enParts[0] || text2;

                    if (isGroupedCategory(vNow) && subcat) {
                        const g = vNow.groups || {};
                        const fromArr = g[subcat] || [];
                        const old = fromArr[index] || {};
                        if (targetSub && targetSub !== subcat) {
                            // 移动到其他类别
                            fromArr.splice(index, 1);
                            if (!g[targetSub]) g[targetSub] = [];
                            g[targetSub].push({ text: enSingle, lang_zh: zhSingle, pinned: !!old.pinned, related: related2, style: selectedStyle });
                        } else {
                            // 就地更新
                            fromArr[index] = { text: enSingle, lang_zh: zhSingle, pinned: !!old.pinned, related: related2, style: selectedStyle };
                        }
                    } else if (isGroupedCategory(vNow) && !subcat) {
                        const g = vNow.groups || {};
                        const uf = g['未分组'] || (g['未分组'] = []);
                        const old = uf[index] || {};
                        if (targetSub && targetSub !== '未分组') {
                            uf.splice(index, 1);
                            if (!g[targetSub]) g[targetSub] = [];
                            g[targetSub].push({ text: enSingle, lang_zh: zhSingle, pinned: !!old.pinned, related: related2, style: selectedStyle });
                        } else {
                            uf[index] = { text: enSingle, lang_zh: zhSingle, pinned: !!old.pinned, related: related2, style: selectedStyle };
                        }
                    } else {
                        commonData[cat] = Array.isArray(vNow) ? vNow : [];
                        // 旧数组模式
                        if (targetSub) {
                            // 升级为分组，并把旧数组作为"未分组"
                            ensureGrouped(cat);
                            const g = commonData[cat].groups;
                            const uf = g['未分组'];
                            const old = uf[index] || {};
                            uf.splice(index, 1);
                            if (!g[targetSub]) g[targetSub] = [];
                            g[targetSub].push({ text: enSingle, lang_zh: zhSingle, pinned: !!old.pinned, related: related2, style: selectedStyle });
                        } else {
                            const old = commonData[cat][index] || {};
                            commonData[cat][index] = { text: enSingle, lang_zh: zhSingle, pinned: !!old.pinned, related: related2, style: selectedStyle };
                        }
                    }
                } else {
                    // 添加模式：支持批量添加多个标签
                    tagsToAdd.forEach(tag => {
                        // 只添加中英文都存在的标签
                        if (tag.lang_zh && tag.text) {
                            if (targetSub) {
                                ensureGrouped(cat);
                                const groups = commonData[cat].groups;
                                if (!groups[targetSub]) groups[targetSub] = [];
                                groups[targetSub].push({ text: tag.text, lang_zh: tag.lang_zh, pinned: false, related: related2, style: selectedStyle });
                            } else {
                                if (Array.isArray(vNow)) {
                                    vNow.push({ text: tag.text, lang_zh: tag.lang_zh, pinned: false, related: related2, style: selectedStyle });
                                    commonData[cat] = vNow;
                                } else if (isGroupedCategory(vNow)) {
                                    const arr = vNow.groups?.['未分组'] || (vNow.groups['未分组'] = []);
                                    arr.push({ text: tag.text, lang_zh: tag.lang_zh, pinned: false, related: related2, style: selectedStyle });
                                } else {
                                    commonData[cat] = [{ text: tag.text, lang_zh: tag.lang_zh, pinned: false, related: related2, style: selectedStyle }];
                                }
                            }
                        }
                    });
                }

                // 记录最后一次小类别选择
                try {
                    if (selectedSub) localStorage.setItem(LAST_SUBCAT_KEY, selectedSub);
                } catch(e) {}

                saveCommonData();
                renderCommonTagsByCategory(cat);
                cleanup();
            };
            const onCancel = () => cleanup();

            function cleanup() {
                translateBtn.removeEventListener('click', onTranslate);
                translateMyBtn && translateMyBtn.removeEventListener('click', onTranslateMyMemory);
                confirmBtn.removeEventListener('click', onConfirm);
                cancelBtn.removeEventListener('click', onCancel);
                closeBtn.removeEventListener('click', onCancel);
                zh.removeEventListener('keydown', onKey);
                en.removeEventListener('keydown', onKey);
                related.removeEventListener('keydown', onKey);
                hide(wrap);
                // 调用关闭回调（用于刷新搜索结果）
                if (window.__tagModalOnClose) {
                    window.__tagModalOnClose();
                    window.__tagModalOnClose = null;
                }
            }
            function onKey(e) {
                if (e.key === 'Enter') onConfirm();
                if (e.key === 'Escape') onCancel();
            }

            translateBtn.addEventListener('click', onTranslate);
            translateMyBtn && translateMyBtn.addEventListener('click', onTranslateMyMemory);
            confirmBtn.addEventListener('click', onConfirm);
            cancelBtn.addEventListener('click', onCancel);
            closeBtn.addEventListener('click', onCancel);
            zh.addEventListener('keydown', onKey);
            en.addEventListener('keydown', onKey);
            related.addEventListener('keydown', onKey);
        }

        // 通用信息提示（居中模态，仅"确定"）
        let toastQueue = [];
        let isShowingToast = false;

        function showInfo(message, title = '提示') {
            return new Promise((resolve) => {
                toastQueue.push({ message, resolve });
                processToastQueue();
            });
        }

        function processToastQueue() {
            if (isShowingToast || toastQueue.length === 0) {
                return;
            }

            isShowingToast = true;
            const { message, resolve } = toastQueue.shift();

            const toast = document.createElement('div');
            toast.className = 'toast-notification';
            toast.innerHTML = message;
            document.body.appendChild(toast);

            // 触发进入动画
            requestAnimationFrame(() => {
                toast.classList.add('show');
            });

            setTimeout(() => {
                toast.classList.add('hide');
                toast.addEventListener('transitionend', () => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                    isShowingToast = false;
                    resolve();
                    processToastQueue();
                });
            }, 2000);
        }

        // 通用确认函数（居中模态）
        function showConfirm(message, title = '确认操作') {
            const wrap = document.getElementById('modal-confirm');
            const titleEl = document.getElementById('modal-confirm-title');
            const msgEl = document.getElementById('modal-confirm-message');
            const okBtn = document.getElementById('modal-confirm-ok');
            const cancelBtn = document.getElementById('modal-confirm-cancel');
            const closeBtn = document.getElementById('modal-confirm-close');
            titleEl.textContent = title || '确认操作';
            msgEl.textContent = message || '';
            show(wrap);
            return new Promise((resolve) => {
                const onOk = () => cleanup(true);
                const onCancel = () => cleanup(false);
                function onKey(e) {
                    if (e.key === 'Enter') cleanup(true);
                    if (e.key === 'Escape') cleanup(false);
                }
                function cleanup(result) {
                    okBtn.removeEventListener('click', onOk);
                    cancelBtn.removeEventListener('click', onCancel);
                    closeBtn.removeEventListener('click', onCancel);
                    document.removeEventListener('keydown', onKey);
                    hide(wrap);
                    resolve(!!result);
                }
                okBtn.addEventListener('click', onOk);
                cancelBtn.addEventListener('click', onCancel);
                closeBtn.addEventListener('click', onCancel);
                document.addEventListener('keydown', onKey);
            });
        }

        // 输入弹窗（居中），返回 Promise<string|null>
        function showInputModal(title = '请输入', placeholder = '', defaultValue = '') {
            return new Promise((resolve) => {
                // 创建容器
                const backdrop = document.createElement('div');
                backdrop.className = 'modal-backdrop';
                backdrop.style.zIndex = '5000'; // 确保在编辑标签弹窗之上
                const modal = document.createElement('div');
                modal.className = 'modal';

                const header = document.createElement('div');
                header.className = 'modal-header';
                const hTitle = document.createElement('span');
                hTitle.textContent = title || '请输入';
                const btnClose = document.createElement('button');
                btnClose.className = 'btn btn-outline';
                btnClose.textContent = '关闭';
                header.appendChild(hTitle);
                header.appendChild(btnClose);

                const body = document.createElement('div');
                body.className = 'modal-body';
                const row = document.createElement('div');
                row.className = 'modal-row';
                const label = document.createElement('label');
                label.textContent = placeholder || '';
                const input = document.createElement('input');
                input.className = 'modal-input';
                input.type = 'text';
                input.value = defaultValue || '';
                input.placeholder = placeholder || '';
                row.appendChild(label);
                row.appendChild(input);
                body.appendChild(row);

                const footer = document.createElement('div');
                footer.className = 'modal-footer';
                const btnCancel = document.createElement('button');
                btnCancel.className = 'btn btn-outline';
                btnCancel.textContent = '取消';
                const btnOk = document.createElement('button');
                btnOk.className = 'btn btn-primary';
                btnOk.textContent = '确定';
                footer.appendChild(btnCancel);
                footer.appendChild(btnOk);

                modal.appendChild(header);
                modal.appendChild(body);
                modal.appendChild(footer);
                backdrop.appendChild(modal);
                document.body.appendChild(backdrop);
                show(backdrop);
                setTimeout(() => input.focus(), 0);

                function cleanup(val) {
                    btnOk.removeEventListener('click', onOk);
                    btnCancel.removeEventListener('click', onCancel);
                    btnClose.removeEventListener('click', onCancel);
                    input.removeEventListener('keydown', onKey);
                    hide(backdrop);
                    document.body.removeChild(backdrop);
                    resolve(val);
                }
                function onOk() { cleanup(input.value); }
                function onCancel() { cleanup(null); }
                function onKey(e) {
                    if (e.key === 'Enter') onOk();
                    if (e.key === 'Escape') onCancel();
                }

                btnOk.addEventListener('click', onOk);
                btnCancel.addEventListener('click', onCancel);
                btnClose.addEventListener('click', onCancel);
                input.addEventListener('keydown', onKey);
            });
        }

        // 图标选择器（固定集合）
        async function showIconPicker(defaultIcon = 'fas fa-globe') {
            return new Promise((resolve) => {
                const icons = ['fas fa-images','fas fa-book','fas fa-tags','fas fa-search','fas fa-image','fas fa-globe'];
                const backdrop = document.createElement('div');
                backdrop.className = 'modal-backdrop';
                backdrop.style.zIndex = '5000'; // 确保在编辑标签弹窗之上
                const modal = document.createElement('div');
                modal.className = 'modal';

                const header = document.createElement('div');
                header.className = 'modal-header';
                const title = document.createElement('span');
                title.textContent = '选择图标';
                const btnClose = document.createElement('button');
                btnClose.className = 'btn btn-outline';
                btnClose.textContent = '关闭';
                header.appendChild(title);
                header.appendChild(btnClose);

                const body = document.createElement('div');
                body.className = 'modal-body';
                const grid = document.createElement('div');
                grid.style.display = 'grid';
                grid.style.gridTemplateColumns = 'repeat(3, 1fr)';
                grid.style.gap = '8px';

                let selected = defaultIcon || 'fas fa-globe';
                icons.forEach(ic => {
                    const btn = document.createElement('button');
                    btn.className = 'btn btn-outline btn-toggle' + (ic === selected ? ' active' : '');
                    btn.style.display = 'flex';
                    btn.style.alignItems = 'center';
                    btn.style.gap = '8px';
                    btn.setAttribute('data-icon', ic);
                    const iEl = document.createElement('i');
                    iEl.className = ic;
                    const span = document.createElement('span');
                    span.textContent = ic;
                    btn.appendChild(iEl);
                    btn.appendChild(span);
                    btn.addEventListener('click', () => {
                        selected = ic;
                        Array.from(grid.querySelectorAll('button')).forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                    });
                    grid.appendChild(btn);
                });
                body.appendChild(grid);

                const footer = document.createElement('div');
                footer.className = 'modal-footer';
                const btnCancel = document.createElement('button');
                btnCancel.className = 'btn btn-outline';
                btnCancel.textContent = '取消';
                const btnOk = document.createElement('button');
                btnOk.className = 'btn btn-primary';
                btnOk.textContent = '确定';
                footer.appendChild(btnCancel);
                footer.appendChild(btnOk);

                modal.appendChild(header);
                modal.appendChild(body);
                modal.appendChild(footer);
                backdrop.appendChild(modal);
                document.body.appendChild(backdrop);
                show(backdrop);

                function cleanup(val) {
                    hide(backdrop);
                    document.body.removeChild(backdrop);
                    resolve(val);
                }
                btnOk.addEventListener('click', () => cleanup(selected));
                btnCancel.addEventListener('click', () => cleanup(null));
                btnClose.addEventListener('click', () => cleanup(null));
            });
        }

        // 右键菜单逻辑（委托）
        const ctxMenu = document.getElementById('context-menu');
        const ctxList = document.getElementById('context-menu-list');
        let activeSubMenu = null;
        let hideSubMenuTimer = null;

        // 隐藏子菜单的通用函数
        function hideSubMenu() {
            if (activeSubMenu && activeSubMenu.parentNode) {
                activeSubMenu.parentNode.removeChild(activeSubMenu);
                activeSubMenu = null;
            }
        }

        // 取消隐藏子菜单
        function cancelHideSubMenu() {
            if (hideSubMenuTimer) {
                clearTimeout(hideSubMenuTimer);
                hideSubMenuTimer = null;
            }
        }

        // 延迟隐藏子菜单
        function scheduleHideSubMenu() {
            hideSubMenuTimer = setTimeout(hideSubMenu, 200);
        }

        function hideContextMenu() {
            ctxMenu.style.display = 'none';
            ctxList.innerHTML = '';
            cancelHideSubMenu();
            hideSubMenu();
        }
        function showContextMenu(x, y, items) {
            ctxList.innerHTML = '';
            items.forEach(({label, action, icon, submenu}) => {
                const div = document.createElement('div');
                div.className = 'item';
                div.style.display = 'flex';
                div.style.alignItems = 'center';
                div.style.justifyContent = 'space-between';

                const left = document.createElement('div');
                left.style.display = 'flex';
                left.style.alignItems = 'center';
                left.style.gap = '8px';

                if (icon) {
                    const iEl = document.createElement('i');
                    iEl.className = icon;
                    left.appendChild(iEl);
                }
                const span = document.createElement('span');
                span.textContent = label;
                left.appendChild(span);

                div.appendChild(left);

                // 如果有子菜单，添加箭头
                if (submenu) {
                    const arrow = document.createElement('i');
                    arrow.className = 'fas fa-chevron-right';
                    arrow.style.fontSize = '12px';
                    arrow.style.opacity = '0.5';
                    div.appendChild(arrow);

                    // 鼠标悬停显示子菜单
                    div.addEventListener('mouseenter', () => {
                        cancelHideSubMenu();
                        hideSubMenu();
                        submenu();
                    });

                    // 鼠标移出延迟隐藏子菜单
                    div.addEventListener('mouseleave', () => {
                        scheduleHideSubMenu();
                    });
                } else {
                    div.addEventListener('click', () => {
                        hideContextMenu();
                        action();
                    });
                }

                ctxList.appendChild(div);
            });
            ctxMenu.style.display = 'block';
            const vw = window.innerWidth, vh = window.innerHeight;
            const rect = { w: 180, h: 40 * items.length };
            const px = Math.min(x, vw - rect.w - 8);
            const py = Math.min(y, vh - rect.h - 8);
            ctxMenu.style.left = px + 'px';
            ctxMenu.style.top = py + 'px';
        }

        // 显示样式选择菜单
        function showStyleMenu(cat, sub, idx, currentStyle) {
            // 移除之前的子菜单
            if (activeSubMenu && activeSubMenu.parentNode) {
                activeSubMenu.parentNode.removeChild(activeSubMenu);
            }

            const styleMenu = document.createElement('div');
            styleMenu.className = 'context-menu';
            styleMenu.style.display = 'block';
            activeSubMenu = styleMenu;

            const styleOptions = [
                { value: 'default', label: '默认', background: '' },
                { value: 'purple', label: '紫色', background: '#a29bfe' },
                { value: 'green', label: '绿色', background: 'linear-gradient(#a0b181, #57b049)' },
                { value: 'orange', label: '橙色', background: 'linear-gradient(#cb9131, #b57e22)' },
                { value: 'pink', label: '粉色', background: 'linear-gradient(#fd79a8, #e84393)' },
                { value: 'dark-purple', label: '深紫', background: 'linear-gradient(#584589, #7774a0)' },
                { value: 'blue', label: '深蓝', background: 'linear-gradient(#2c3e80, #344495)' }
                
            ];

            styleOptions.forEach(opt => {
                const div = document.createElement('div');
                div.className = 'item';
                div.style.display = 'flex';
                div.style.alignItems = 'center';
                div.style.gap = '10px';

                const label = document.createElement('span');
                label.textContent = opt.label;

                div.appendChild(label);

                // 颜色预览（在右侧）
                const preview = document.createElement('div');
                preview.style.width = '20px';
                preview.style.height = '20px';
                preview.style.borderRadius = '4px';
                preview.style.border = '1px solid var(--border-color)';
                preview.style.marginLeft = 'auto';
                if (opt.background) {
                    preview.style.background = opt.background;
                } else {
                    preview.style.background = '#406e6d';
                }

                // 选中标记
                if (opt.value === currentStyle) {
                    const check = document.createElement('i');
                    check.className = 'fas fa-check';
                    check.style.color = 'var(--success-color)';
                    check.style.fontSize = '12px';
                    preview.appendChild(check);
                }

                div.appendChild(preview);

                div.addEventListener('click', () => {
                    // 更新标签样式
                    const v = commonData[cat];
                    if (Array.isArray(v)) {
                        v[idx].style = opt.value;
                    } else if (isGroupedCategory(v)) {
                        const arr = v.groups?.[sub] || [];
                        arr[idx].style = opt.value;
                    }
                    saveCommonData();
                    renderCommonTagsByCategory(cat);
                    hideContextMenu();
                });

                styleMenu.appendChild(div);
            });

            // 定位菜单,确保不超出屏幕边界
            const rect = ctxMenu.getBoundingClientRect();
            const styleMenuWidth = 180;
            const styleMenuHeight = styleOptions.length * 40;
            const vw = window.innerWidth;
            const vh = window.innerHeight;

            // 如果放在右侧会超出屏幕,则放在左侧(紧贴主菜单)
            const left = rect.right + styleMenuWidth > vw ? rect.left - styleMenuWidth - -98 : rect.right;
            // 如果底部会超出屏幕,则向上调整
            const top = rect.top + styleMenuHeight > vh ? vh - styleMenuHeight - 8 : rect.top;

            styleMenu.style.left = left + 'px';
            styleMenu.style.top = top + 'px';

            // 鼠标进入子菜单时取消隐藏
            styleMenu.addEventListener('mouseenter', cancelHideSubMenu);

            // 鼠标离开子菜单时延迟隐藏
            styleMenu.addEventListener('mouseleave', scheduleHideSubMenu);

            document.body.appendChild(styleMenu);
        }

        document.addEventListener('click', hideContextMenu, { passive: true });
        window.addEventListener('scroll', hideContextMenu, { passive: true });
        window.addEventListener('resize', hideContextMenu, { passive: true });

        document.addEventListener('contextmenu', (e) => {
            const catCard = e.target.closest('.prompt-card');
            const promptTagEl = e.target.closest('.prompt-tag');
            const weightPanelEl = e.target.closest('[data-role="weight-panel"]');
            if (weightPanelEl) return; // 内联按钮保持默认行为
            const tagEl = e.target.closest('.common-tag');
            if (catCard) {
                e.preventDefault();
                const cat = catCard.getAttribute('data-cat') || '';
                if (!cat) return;
                showContextMenu(e.clientX, e.clientY, [
                    { label: '编辑名称', icon: 'fas fa-pen', action: () => openCategoryModal(cat) },
                    { label: '删除', icon: 'fas fa-trash', action: async () => {
                        const ok = await showConfirm(`确认删除分类「${cat}」及其所有标签？`, '删除分类');
                        if (!ok) return;
                        delete commonData[cat];
                        saveCommonData();
                        const keys = Object.keys(commonData);
                        setActiveCategory(keys[0] || '');
                        renderSidebar();
                    } }
                ]);
            } else if (promptTagEl) {
                e.preventDefault();
                const segEn = promptTagEl.querySelector('.seg-en');
                const currentTag = segEn ? (segEn.textContent || '').trim() : '';
                if (!currentTag) return;

                // 查找标签对应的原始数据
                const tagInfo = findTagByEnglish(currentTag);

                const menuItems = [
                    { label: '权重+', icon: 'fas fa-plus', action: () => adjustTagWeightBySteps(currentTag, +1) },
                    { label: '权重-', icon: 'fas fa-minus', action: () => adjustTagWeightBySteps(currentTag, -1) }
                ];

                // 如果找到对应的标签数据，添加编辑选项
                if (tagInfo) {
                    menuItems.splice(2, 0, {
                        label: '编辑',
                        icon: 'fas fa-pen',
                        action: () => openTagModal(tagInfo.category, tagInfo.index, tagInfo.subcategory)
                    });
                }

                menuItems.push({ label: '删除', icon: 'fas fa-trash', action: () => removeWeightedTag(currentTag) });

                showContextMenu(e.clientX, e.clientY, menuItems);
                return;
            }

            if (tagEl) {
                e.preventDefault();
                const cat = tagEl.getAttribute('data-cat') || getActiveCategory();
                const idx = parseInt(tagEl.getAttribute('data-index') || '-1', 10);
                const sub = tagEl.getAttribute('data-subcat') || '';
                if (!cat || idx < 0) return;

                let it = null, isPinned = false;
                const v = commonData[cat];
                if (Array.isArray(v)) {
                    it = v[idx];
                } else if (isGroupedCategory(v)) {
                    it = (v.groups?.[sub] || [])[idx];
                }
                if (!it) return;
                const currentStyle = it?.style || 'default';

                // 组装右键菜单：固定项 + 自定义项 + 删除
                const menuItems = [
                    { label: '编辑标签', icon: 'fas fa-pen', action: () => openTagModal(cat, idx, sub) },
                    {
                        label: '修改样式',
                        icon: 'fas fa-palette',
                        submenu: () => showStyleMenu(cat, sub, idx, currentStyle)
                    }
                ];

                // 自定义外链项（出现在"删除"上方）
                try {
                    const customMenus = (typeof getCtxMenus === 'function') ? getCtxMenus() : [];
                    if (Array.isArray(customMenus) && customMenus.length) {
                        const en = (it && it.text) ? String(it.text).trim() : '';
                        const zh = (it && it.lang_zh) ? String(it.lang_zh).trim() : '';
                        customMenus.forEach(m => {
                            const label = (m && m.name) ? String(m.name) : '链接';
                            const icon = (m && m.icon) ? String(m.icon) : 'fas fa-globe';
                            const tpl = (m && m.url) ? String(m.url) : '';
                            menuItems.push({
                                label,
                                icon,
                                action: () => {
                                    const url = (typeof buildUrlFromTemplate === 'function') ? buildUrlFromTemplate(tpl, en, zh) : '';
                                    if (!url) { showInfo('链接模板为空', '提示'); return; }
                                    window.open(url, '_blank');
                                }
                            });
                        });
                    }
                } catch(_) {}

                // 删除放在最后
                menuItems.push({
                    label: '删除',
                    icon: 'fas fa-trash',
                    action: async () => {
                        const v2 = commonData[cat];
                        let it2 = null;
                        if (Array.isArray(v2)) {
                            it2 = v2[idx];
                            if (!it2) return;
                            v2.splice(idx, 1);
                        } else if (isGroupedCategory(v2)) {
                            const arr = v2.groups?.[sub] || [];
                            it2 = arr[idx];
                            if (!it2) return;
                            arr.splice(idx, 1);
                        }
                        saveCommonData();
                        renderCommonTagsByCategory(cat);
                        showInfo(`已删除 <b>${it2.lang_zh || it2.text}</b> 提示词`);
                    }
                });

                showContextMenu(e.clientX, e.clientY, menuItems);
            } else {
                hideContextMenu();
            }
        });

        // 标记/取消标记（支持分组）
        function pinTag(cat, subcat, index, shouldPin) {
            const v = commonData[cat];
            if (Array.isArray(v)) {
                if (!v[index]) return;
                v[index].pinned = !!shouldPin;
                commonData[cat] = v;
            } else if (isGroupedCategory(v)) {
                const arr = v.groups?.[subcat] || [];
                if (!arr[index]) return;
                arr[index].pinned = !!shouldPin;
            }
            saveCommonData();
            renderCommonTagsByCategory(cat);
        }

        // 上移/下移 类别分组顺序（以显式顺序数组 groupsOrder 控制渲染顺序）
        function moveSubcat(catKey, sub, direction) {
            const v = commonData[catKey];
            if (!isGroupedCategory(v)) { return; }
            const g = v.groups || {};
            // 基于现有顺序或键集合构造 order
            const baseOrder = Array.isArray(v.groupsOrder)
                ? v.groupsOrder.filter(n => Object.prototype.hasOwnProperty.call(g, n))
                    .concat(Object.keys(g).filter(n => !v.groupsOrder.includes(n)))
                : Object.keys(g);
            const idx = baseOrder.indexOf(sub);
            if (idx === -1) return;
            const target = direction === 'up' ? idx - 1 : idx + 1;
            if (target < 0 || target >= baseOrder.length) return;

            const newOrder = baseOrder.slice();
            newOrder.splice(idx, 1);
            newOrder.splice(target, 0, sub);

            // 生成全新 groups，保证插入顺序一致
            const reordered = {};
            for (const k of newOrder) {
                reordered[k] = Array.isArray(g[k]) ? g[k].slice() : (g[k] || []);
            }
            // 回写：同时写入 groups 与 groupsOrder
            commonData[catKey] = { groups: reordered, groupsOrder: newOrder };
            saveCommonData();
            renderCommonTagsByCategory(catKey);
        }

        // 兼容函数：若需要外部调用，可通过 key 切换分类
        function loadPrompt(catKey) {
            document.querySelectorAll('.prompt-card').forEach(card => card.classList.remove('active'));
            // 不强制设置 active，这里仅切换标签
            renderCommonTagsByCategory(catKey);
        }
        
        // 监听编辑器内容变化
        promptEditor.addEventListener('input', () => {
            normalizePromptInput({ restoreCaret: true });
            updateTags();
        });

        // 根据英文查找标签对应的原始数据
        function findTagByEnglish(englishText) {
            const normalizedEn = englishText.trim().toLowerCase();
            // 移除权重标记，如 (1.2)、::1.2 等
            const cleanEn = normalizedEn.replace(/\([^)]*\)|::[\d.]+/g, '').trim();

            for (const cat in commonData) {
                const data = commonData[cat];
                if (Array.isArray(data)) {
                    // 数组格式
                    const idx = data.findIndex(t => {
                        const tagEn = (t.text || '').trim().toLowerCase();
                        return tagEn === cleanEn || tagEn === normalizedEn;
                    });
                    if (idx >= 0) {
                        return { category: cat, index: idx, subcategory: '' };
                    }
                } else if (data.groups) {
                    // 分组格式
                    for (const sub in data.groups) {
                        const tags = data.groups[sub];
                        const idx = tags.findIndex(t => {
                            const tagEn = (t.text || '').trim().toLowerCase();
                            return tagEn === cleanEn || tagEn === normalizedEn;
                        });
                        if (idx >= 0) {
                            return { category: cat, index: idx, subcategory: sub };
                        }
                    }
                }
            }
            return null;
        }

        // 重置：清空所有分类、类别与历史
        async function resetAll() {
            const ok = await showConfirm('确认清空所有分类、类别与历史记录？此操作不可恢复。', '重置数据');
            if (!ok) return;
            // 清空数据
            commonData = {};
            saveCommonData();
            try {
                localStorage.removeItem('ops_prompt_history');
                localStorage.removeItem('ops_active_cat');
                localStorage.removeItem('ops_prefix_trigger_zh');
                localStorage.removeItem('ops_suffix_trigger_zh');
                // 保留 Dropbox 配置与文件选择
            } catch(e) {}
            resetPrompt();
            renderSidebar();
            showInfo('已清空所有标签与分类', '完成');
        }

        // 全局IELTS数据存储
        let ieltsData = [];

        // 搜索提示词模态框
        function openSearchTagsModal() {
            const wrap = document.getElementById('modal-search-tags');
            const searchInput = document.getElementById('search-input');
            const searchResults = document.getElementById('search-results');
            const closeBtn = document.getElementById('modal-search-close');
            const clearBtn = document.getElementById('modal-search-clear');
            const sourceButtons = document.querySelectorAll('#search-source-buttons .btn-toggle');

            // 使用Set存储选中的数据源，支持多选
            let selectedSources = new Set(['default']);

            // 分页配置
            const PAGE_SIZE = 50; // 每页显示50条
            let currentPage = 1;
            let allSearchResults = []; // 存储所有搜索结果

            // 加载IELTS数据
            async function loadIELTSData() {
                try {
                    const response = await fetch('./IELTS/IELTS.json');
                    if (response.ok) {
                        ieltsData = await response.json();
                    }
                } catch (e) {
                    console.error('加载IELTS数据失败:', e);
                }
            }

            // 初始化加载数据
            loadIELTSData();

            searchInput.value = '';
            searchResults.innerHTML = '<div style="opacity:0.6;font-size:0.9rem;">输入关键词后，下方将显示匹配的提示词</div>';

            // 数据源切换（支持多选）
            sourceButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const source = btn.dataset.source;

                    if (selectedSources.has(source)) {
                        // 如果已选中，则取消选择
                        selectedSources.delete(source);
                        btn.classList.remove('active');

                        // 如果所有都取消，则恢复默认
                        if (selectedSources.size === 0) {
                            selectedSources.add('default');
                            document.getElementById('btn-source-default').classList.add('active');
                        }
                    } else {
                        // 添加选择
                        selectedSources.add(source);
                        btn.classList.add('active');
                    }

                    // 清空搜索结果
                    searchInput.value = '';
                    searchResults.innerHTML = '<div style="opacity:0.6;font-size:0.9rem;">输入关键词后，下方将显示匹配的提示词</div>';
                });
            });

            // 搜索所有提示词
            function searchTags(keyword) {
                const results = [];
                const lowerKeyword = keyword.toLowerCase();

                // 搜索IELTS数据（如果选中）
                if (selectedSources.has('ielts')) {
                    ieltsData.forEach(item => {
                        const zh = (item.zh || '').trim();
                        const en = (item.en || '').trim();
                        const zhMatch = zh && zh.toLowerCase().includes(lowerKeyword);
                        const enMatch = en && en.toLowerCase().includes(lowerKeyword);

                        if (zhMatch || enMatch) {
                            results.push({
                                zh: zh,
                                en: en,
                                category: 'IELTS',
                                subcategory: ''
                            });
                        }
                    });
                }

                // 搜索默认数据（如果选中）
                if (selectedSources.has('default')) {
                    for (const cat in commonData) {
                        const data = commonData[cat];

                        // 判断是数组格式还是分组格式
                        if (Array.isArray(data)) {
                            // 数组格式（旧版），类别为"未分组"
                            data.forEach((tag, idx) => {
                                const zh = (tag.lang_zh || '').trim();
                                const en = (tag.text || '').trim();
                                const zhMatch = zh && zh.toLowerCase().includes(lowerKeyword);
                                const enMatch = en && en.toLowerCase().includes(lowerKeyword);

                                if (zhMatch || enMatch) {
                                    results.push({
                                        zh: zh,
                                        en: en,
                                        category: cat,
                                        subcategory: '未分组',
                                        index: idx,
                                        tagRef: tag
                                    });
                                }
                            });
                        } else if (data.groups) {
                            // 分组格式（新版）
                            for (const sub in data.groups) {
                                const tags = data.groups[sub];
                                tags.forEach((tag, idx) => {
                                    const zh = (tag.lang_zh || '').trim();
                                    const en = (tag.text || '').trim();
                                    const zhMatch = zh && zh.toLowerCase().includes(lowerKeyword);
                                    const enMatch = en && en.toLowerCase().includes(lowerKeyword);

                                    if (zhMatch || enMatch) {
                                        results.push({
                                            zh: zh,
                                            en: en,
                                            category: cat,
                                            subcategory: sub,
                                            index: idx,
                                            tagRef: tag
                                        });
                                    }
                                });
                            }
                        }
                    }
                }

                return results;
            }

            // 渲染搜索结果（支持分页）
            function renderSearchResults(results, page = 1) {
                allSearchResults = results; // 保存所有结果

                if (results.length === 0) {
                    searchResults.innerHTML = '<div style="opacity:0.6;font-size:0.9rem;">未找到匹配的提示词</div>';
                    return;
                }

                searchResults.innerHTML = '';

                // 计算分页
                const startIndex = (page - 1) * PAGE_SIZE;
                const endIndex = startIndex + PAGE_SIZE;
                const pageResults = results.slice(startIndex, endIndex);
                const totalPages = Math.ceil(results.length / PAGE_SIZE);

                // 渲染当前页结果
                pageResults.forEach((result, index) => {
                    const row = document.createElement('div');
                    row.style.border = '1px solid var(--border-color)';
                    row.style.borderRadius = '8px';
                    row.style.padding = '8px 12px 8px 12px';
                    row.style.cursor = 'pointer';
                    row.style.transition = 'all 0.2s ease';

                    // 第一行：中文和英文并排显示
                    const firstLine = document.createElement('div');
                    firstLine.style.display = 'flex';
                    firstLine.style.justifyContent = 'space-between';
                    firstLine.style.alignItems = 'center';
                    firstLine.style.marginBottom = '4px';

                    const title = document.createElement('div');
                    title.style.fontWeight = '600';
                    title.style.color = 'var(--primary-color)';
                    title.textContent = result.zh || result.en || '未命名';


                    const en = document.createElement('div');
                    en.style.fontSize = '0.9rem';
                    en.style.opacity = '0.85';
                    en.textContent = result.en || '';

                    firstLine.appendChild(title);
                    if (result.en) firstLine.appendChild(en);

                    row.appendChild(firstLine);

                    // IELTS数据不显示分类信息
                    if (result.category !== 'IELTS') {
                        const cat = document.createElement('div');
                        cat.style.fontSize = '0.8rem';
                        cat.style.opacity = '0.6';
                        cat.textContent = `分类: ${result.category} | 类别: ${result.subcategory}`;
                        row.appendChild(cat);
                    }

                    row.addEventListener('click', () => {
                        // 根据全局变量判断当前语言模式
                        const isChineseMode = window.__chineseMode;
                        const textToInsert = isChineseMode ? (result.zh || result.en) : (result.en || result.zh);

                        // 插入到提示词编辑器
                        const currentText = promptEditor.value || '';
                        const separator = currentText.trim() ? ', ' : '';
                        promptEditor.value = currentText + separator + textToInsert;

                        // 触发输入事件以更新标签显示
                        promptEditor.dispatchEvent(new Event('input'));

                        // 创建临时提示元素（使用统一样式）
                        const toast = document.createElement('div');
                        toast.className = 'toast-notification';
                        toast.textContent = `已插入: ${textToInsert}`;
                        document.body.appendChild(toast);

                        // 触发进入动画
                        requestAnimationFrame(() => {
                            toast.classList.add('show');
                        });

                        setTimeout(() => {
                            toast.classList.add('hide');
                            toast.addEventListener('transitionend', () => {
                                if (toast.parentNode) {
                                    toast.parentNode.removeChild(toast);
                                }
                            });
                        }, 1000);
                    });

                    // 右键菜单（仅默认数据支持编辑）
                    if (result.category !== 'IELTS') {
                        row.addEventListener('contextmenu', (e) => {
                            e.preventDefault();

                            // 移除搜索框相关的右键菜单（通过特定标记）
                            document.querySelectorAll('.context-menu.search-context-menu').forEach(menu => menu.remove());

                            // 创建右键菜单
                            const ctxMenu = document.createElement('div');
                            ctxMenu.className = 'context-menu search-context-menu';
                            ctxMenu.style.display = 'block';
                            ctxMenu.style.left = e.clientX + 'px';
                            ctxMenu.style.top = e.clientY + 'px';
                            ctxMenu.style.zIndex = '4000';

                            const editBtn = document.createElement('div');
                            editBtn.className = 'item';
                            editBtn.innerHTML = '<i class="fas fa-edit"></i> 编辑标签';
                            editBtn.addEventListener('click', () => {
                                ctxMenu.remove();

                                // 直接使用搜索结果中保存的索引
                                const category = result.category;
                                const subcategory = result.subcategory;
                                const tagIndex = result.index;

                                if (tagIndex >= 0 && commonData[category]) {
                                    // 设置关闭回调，编辑完成后刷新搜索结果
                                    const originalHandler = window.__tagModalOnClose;
                                    window.__tagModalOnClose = () => {
                                        // 刷新搜索结果
                                        searchInput.dispatchEvent(new Event('input'));
                                        if (originalHandler) originalHandler();
                                    };
                                    openTagModal(category, tagIndex, subcategory);
                                }
                            });

                            // 删除按钮
                            const deleteBtn = document.createElement('div');
                            deleteBtn.className = 'item';
                            deleteBtn.innerHTML = '<i class="fas fa-trash"></i> 删除标签';
                            deleteBtn.addEventListener('click', async () => {
                                ctxMenu.remove();

                                // 直接使用搜索结果中保存的索引
                                const category = result.category;
                                const subcategory = result.subcategory;
                                const tagIndex = result.index;

                                if (tagIndex >= 0 && commonData[category]) {
                                    const data = commonData[category];
                                    let deletedTag = null;

                                    if (Array.isArray(data)) {
                                        // 数组格式
                                        deletedTag = data[tagIndex];
                                        data.splice(tagIndex, 1);
                                    } else if (data.groups && data.groups[subcategory]) {
                                        // 分组格式
                                        const tags = data.groups[subcategory];
                                        deletedTag = tags[tagIndex];
                                        tags.splice(tagIndex, 1);
                                    }

                                    saveCommonData();
                                    renderCommonTagsByCategory(category);
                                    // 重新搜索以刷新结果
                                    searchInput.dispatchEvent(new Event('input'));
                                    showInfo(`已删除 <b>${deletedTag?.lang_zh || deletedTag?.text}</b> 提示词`);
                                }
                            });

                            ctxMenu.appendChild(editBtn);
                            ctxMenu.appendChild(deleteBtn);
                            document.body.appendChild(ctxMenu);

                            // 点击其他地方关闭菜单
                            const closeCtxMenu = () => {
                                ctxMenu.remove();
                                document.removeEventListener('click', closeCtxMenu);
                            };
                            setTimeout(() => {
                                document.addEventListener('click', closeCtxMenu);
                            }, 0);
                        });
                    }

                    row.addEventListener('mouseenter', () => {
                        row.style.backgroundColor = 'var(--primary-color)';
                        title.style.color = 'white';
                        en.style.color = 'rgba(255,255,255,0.9)';
                    });

                    row.addEventListener('mouseleave', () => {
                        row.style.backgroundColor = '';
                        title.style.color = 'var(--primary-color)';
                        en.style.color = '';
                    });

                    searchResults.appendChild(row);
                });

                // 添加分页控制
                if (totalPages > 1) {
                    const pagination = document.createElement('div');
                    pagination.style.display = 'flex';
                    pagination.style.justifyContent = 'center';
                    pagination.style.alignItems = 'center';
                    pagination.style.gap = '8px';
                    pagination.style.marginTop = '16px';
                    pagination.style.padding = '12px';
                    pagination.style.borderTop = '1px solid var(--border-color)';

                    // 显示当前页信息
                    const pageInfo = document.createElement('span');
                    pageInfo.style.fontSize = '0.9rem';
                    pageInfo.style.opacity = '0.7';
                    pageInfo.textContent = `第 ${page} / ${totalPages} 页 (共 ${results.length} 条)`;
                    pagination.appendChild(pageInfo);

                    // 上一页按钮
                    if (page > 1) {
                        const prevBtn = document.createElement('button');
                        prevBtn.className = 'btn btn-outline';
                        prevBtn.style.padding = '4px 12px';
                        prevBtn.style.fontSize = '0.85rem';
                        prevBtn.textContent = '上一页';
                        prevBtn.addEventListener('click', () => {
                            currentPage = page - 1;
                            renderSearchResults(allSearchResults, currentPage);
                        });
                        pagination.appendChild(prevBtn);
                    }

                    // 下一页按钮
                    if (page < totalPages) {
                        const nextBtn = document.createElement('button');
                        nextBtn.className = 'btn btn-outline';
                        nextBtn.style.padding = '4px 12px';
                        nextBtn.style.fontSize = '0.85rem';
                        nextBtn.textContent = '下一页';
                        nextBtn.addEventListener('click', () => {
                            currentPage = page + 1;
                            renderSearchResults(allSearchResults, currentPage);
                        });
                        pagination.appendChild(nextBtn);
                    }

                    searchResults.appendChild(pagination);
                }
            }

            // 搜索输入监听
            searchInput.addEventListener('input', (e) => {
                const keyword = e.target.value.trim();
                if (!keyword) {
                    searchResults.innerHTML = '<div style="opacity:0.6;font-size:0.9rem;">输入关键词后，下方将显示匹配的提示词</div>';
                    return;
                }

                const results = searchTags(keyword);
                currentPage = 1; // 重置到第一页
                renderSearchResults(results, currentPage);
            });

            // 清空按钮
            clearBtn.addEventListener('click', () => {
                searchInput.value = '';
                searchResults.innerHTML = '<div style="opacity:0.6;font-size:0.9rem;">输入关键词后，下方将显示匹配的提示词</div>';
                searchInput.focus();
            });

            // 关闭按钮
            closeBtn.addEventListener('click', () => {
                hide(wrap);
                searchInput.removeEventListener('input', arguments.callee);
            });

            // ESC键关闭
            const onEscape = (e) => {
                if (e.key === 'Escape') {
                    document.removeEventListener('keydown', onEscape);
                    hide(wrap);
                }
            };
            document.addEventListener('keydown', onEscape);

            show(wrap);
            setTimeout(() => searchInput.focus(), 100);
        }

        // 绑定搜索按钮事件
        document.getElementById('search-tags-btn')?.addEventListener('click', openSearchTagsModal);

        // 全局快捷键 - 使用保存的设置
        document.addEventListener('keydown', (e) => {
            const activeElement = document.activeElement;
            const isInputActive = activeElement && (
                activeElement.tagName === 'INPUT' ||
                activeElement.tagName === 'TEXTAREA' ||
                activeElement.isContentEditable
            );

            // 获取保存的快捷键
            const searchShortcut = localStorage.getItem('ops_shortcut_search') || '/';
            const resetShortcut = localStorage.getItem('ops_shortcut_reset') || '';
            const copyShortcut = localStorage.getItem('ops_shortcut_copy') || '';
            const saveShortcut = localStorage.getItem('ops_shortcut_save') || '';

            // 搜索快捷键
            if (e.key === searchShortcut && !isInputActive) {
                e.preventDefault();
                openSearchTagsModal();
            }
            // 重置快捷键
            else if (e.key === resetShortcut && !isInputActive) {
                e.preventDefault();
                resetPrompt();
            }
            // 复制快捷键
            else if (e.key === copyShortcut && !isInputActive) {
                e.preventDefault();
                copyPrompt();
            }
            // 存储快捷键
            else if (e.key === saveShortcut && !isInputActive) {
                e.preventDefault();
                document.getElementById('save-prompt-btn')?.click();
            }
        });

        // 初始化
        updateTags();
        loadCommonTagsFromStorage();
        setupUIEvents();
        // 启用侧栏拖拽容器事件
        if (sidebarList) {
            sidebarList.addEventListener('dragover', onSidebarDragOver);
            sidebarList.addEventListener('drop', onSidebarDrop);
        }
        // 点击"提示词编辑器"标题切换侧栏显示/隐藏
        const toggleSidebarBtn = document.getElementById('toggle-sidebar-btn');
        const sidebar = document.querySelector('.sidebar');
        const mainContent = document.getElementById('main-content');
        let sidebarVisible = true;

        if (toggleSidebarBtn && sidebar && mainContent) {
            toggleSidebarBtn.addEventListener('click', () => {
                sidebarVisible = !sidebarVisible;
                if (sidebarVisible) {
                    sidebar.style.display = 'block';
                    mainContent.style.marginLeft = '';
                } else {
                    sidebar.style.display = 'none';
                    mainContent.style.marginLeft = '0';
                }
            });
        }
        // 首次打开提示：若无数据则询问是否导入默认测试数据
        maybePromptDefaultImport();
        document.getElementById('settings-toggle')?.addEventListener('click', openCtxMenuModal);
        updateTokenCounter();
    </script>
</body>
</html>