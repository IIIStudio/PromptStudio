
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>IIIStudio - AI绘画提示词工具</title>
    <meta name="keywords" content="AI绘画提示词 , 工具 , 咒语 , 炼金 , 翻译 ,ComfyUI" />
    <meta name="description" content="一个纯前端的提示词管理与编辑页面。支持分类/分组管理、标签拖拽排序、历史快照存储、翻译、JSON 导入/导出、本地持久化，以及可选的 Dropbox 云同步；同时提供一键导出提示词区域为图片（html2canvas）。" />
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="dns-prefetch" href="https://cdnjs.cloudflare.com">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="./js/cos-js-sdk-v5.min.js"></script>
    <style>
        :root {
            --primary-color: #6c5ce7;
            --secondary-color: #a29bfe;
            --bg-color: #f8f9fa;
            --card-bg: #ffffff;
            --text-color: #2d3436;
            --border-color: #dfe6e9;
            --sidebar-width: 280px;
            --header-height: 60px;
            --success-color: #00b894;
            --warning-color: #fdcb6e;
            --danger-color: #e17055;
        }

        .dark-mode {
            --primary-color: #7c6ef5;
            --secondary-color: #9c8ef7;
            --bg-color: #1e2026;
            --card-bg: #2d3036;
            --text-color: #e1e5eb;
            --border-color: #3a3f4b;
            --success-color: #00d8a7;
            --warning-color: #ffd166;
            --danger-color: #ff7b54;
        }

        * {
            margin: 0;

            box-sizing: border-box;
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }

        body {
            font-family: 'Segoe UI', 'PingFang SC', 'Microsoft YaHei', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            overflow-x: hidden;
        }

        .container {
            display: flex;
            min-height: 100vh;
        }

        /* 侧边栏样式 */
        .sidebar {
            width: var(--sidebar-width);
            background-color: var(--card-bg);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            height: 100vh;
            position: fixed;
            overflow-y: auto;
            z-index: 100;
        }

        .logo {
            padding: 20px;
            display: flex;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--primary-color);
            color: white;
        }

        .logo h1 {
            font-size: 1.5rem;
            margin-left: 10px;
            font-weight: 600;
        }

        .logo-icon {
            font-size: 1.8rem;
        }

        .category-list {
            padding: 15px;
            flex-grow: 1;
        }

        .category-title {
            font-size: 1.1rem;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            color: var(--primary-color);
        }

        .category-title span {
            cursor: pointer;
        }

        .prompt-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 20px;
        }

        .prompt-card {
            background-color: var(--bg-color);
            border-radius: 10px;
            padding: 6px 10px 6px 15px;
            cursor: pointer;
            border: 1px solid var(--border-color);
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .prompt-card:hover {
            border-color: var(--primary-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .prompt-card.active {
            border-color: var(--primary-color);
            background-color: rgba(108, 92, 231, 0.05);
        }

        .prompt-card h3 {
            font-size: .91rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .prompt-card p {
            font-size: 0.85rem;
            color: #888;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        .tag {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            background-color: var(--secondary-color);
            color: white;
            margin-right: 5px;
        }

        /* 主内容区样式 */
        .main-content {
            flex: 1;
            margin-left: var(--sidebar-width);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .header h2 {
            font-size: 1.8rem;
            font-weight: 600;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header-actions {
            display: flex;
            gap: 15px;
        }

        .btn {
            padding: 5px 10px;
            border-radius: 5px;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            transition: all 0.2s ease;
            font-size: 0.9rem;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }

        .btn-outline {
            background-color: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-color);
        }

        .btn-success {
            background-color: var(--success-color);
            color: white;
        }
        .icon-plus::before {
            content: "\2b";
            font-family: "Font Awesome 6 Free";
            -webkit-font-smoothing: antialiased;
            display: var(--fa-display, inline-block);
            font-style: normal;
            font-variant: normal;
            line-height: 1;
            text-rendering: auto;
        }

        .editor-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .editor-card {
            background-color: var(--card-bg);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            border: 1px solid var(--border-color);
        }

        .editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .editor-title {
            font-size: 1.2rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .editor-title i {
            color: var(--primary-color);
        }

        .editor-actions {
            display: flex;
            gap: 10px;
        }

        .editor-textarea {
            width: 100%;
            min-height: 150px;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Courier New', monospace;
            resize: vertical;
            font-size: 0.95rem;
            line-height: 1.5;
        }

        .editor-textarea:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        /* 提示词标签样式 */
        .prompt-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 15px;
            min-height: 40px;
            padding: 10px;
            border-radius: 8px;
            background-color: var(--bg-color);
            border: 1px dashed var(--border-color);
        }

        .prompt-tag {
            position: relative;
            display: inline-flex;
            align-items: stretch;
            min-height: 28px;
            border-radius: 8px;
            box-shadow: 0 2px 2px rgba(51, 54, 67, .25);
            color: #fff;
            cursor: grab;
            transition: all .2s ease;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            overflow: hidden;
        }
        .prompt-tag .delete-tag {
            position: absolute;
            top: 5px;
            left: 5px;
            width: 18px;
            height: 18px;
            border-radius: 10px;
            background: rgba(0,0,0,.55);
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            line-height: 18px;
            color: #fff;
            cursor: pointer;
            transition: background-color .2s ease;
            z-index: 2;
        }
        .prompt-tag:hover .delete-tag {
            display: inline-flex;
        }
        .prompt-tag .delete-tag:hover {
            background: rgba(0,0,0,.75);
        }
        .prompt-tag .seg-en {
            display: inline-flex;
            align-items: center;
            padding: 0 10px;
            background: linear-gradient(#606060, #6c6c6c);
            font-size: 0.85rem;
            border-top-left-radius: 8px;
            border-bottom-left-radius: 8px;
        }
        .prompt-tag .seg-zh {
            display: inline-flex;
            align-items: center;
            padding: 0 10px;
            background: linear-gradient(#a0b181, #57b049);
            font-size: 0.85rem;
        }
        .prompt-tag.no-zh .seg-en {
            border-top-right-radius: 8px;
            border-bottom-right-radius: 8px;
        }
        .prompt-tag .weight-adjust {
            display: inline-flex;
            align-items: stretch;
            background: linear-gradient(#454545, #555);
            overflow: hidden;
        }
        .prompt-tag.weight-disabled .weight-adjust {
            display: none !important;
        }
        .prompt-tag .weight-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            border: none;
            background: transparent;
            color: #fff;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color .2s ease, color .2s ease;
        }
        .prompt-tag .weight-btn + .weight-btn {
            border-left: 1px solid rgba(255,255,255,0.12);
        }
        .prompt-tag .weight-btn:hover {
            background-color: rgba(255,255,255,0.12);
            color: #ffd166;
        }
        .prompt-tag .weight-value {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0 8px;
            font-size: 0.75rem;
            font-weight: 600;
            color: #ffdd7a;
            min-width: 40px;
            background: transparent;
        }
        .dark-mode .prompt-tag .weight-adjust {
            background: linear-gradient(#2e2e2e, #3a3a3a);
        }
        .dark-mode .prompt-tag .weight-btn:hover {
            background-color: rgba(255,255,255,0.1);
        }
        .dark-mode .prompt-tag .weight-value {
            color: #ffe0a3;
        }
        .dark-mode .prompt-tag .delete-tag {
            background: rgba(0,0,0,.6);
        }

        .prompt-tag:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(51, 54, 67, .25);
        }

        .prompt-tag.dragging {
            opacity: 0.5;
        }
        /* 拖拽占位指示条 */
        .tag-placeholder {
            width: 6px;
            height: 15px;
            background: var(--primary-color);
            border-radius: 3px;
            margin: 6px 4px;
            align-self: stretch;
        }

        /* 点击置灰 + 按键凹陷效果（保留中英分段配色，仅做整体淡化与凹陷） */
        .prompt-tag:active {
            transform: translateY(0);
            box-shadow: inset 0 2px 6px rgba(0,0,0,.25);
        }
        .prompt-tag.inactive {
            opacity: .55;                 /* 整体淡化 */
            filter: grayscale(35%);       /* 轻度灰度，仍保留配色差异 */
            transform: translateY(1px);   /* 轻微下压 */
            box-shadow: inset 0 2px 8px rgba(0,0,0,.28); /* 内凹阴影 */
            cursor: pointer;
        }
        .prompt-tag.inactive:hover {
            transform: translateY(1px);   /* 悬停也保持按下，不上浮 */
            box-shadow: inset 0 2px 10px rgba(0,0,0,.32);
        }

        /* 常用提示词区域样式 */
        .common-tags-section {
            margin-top: 16px;
        }
        .common-tags-title {
            font-size: 0.95rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .common-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 10px;
            border-radius: 8px;
            background-color: var(--bg-color);
            border: 1px dashed var(--border-color);
            min-height: 40px;
        }
        .common-tag {
            height: 28px;
            display: inline-flex;
            align-items: center;
            padding: 0 10px;
            border-radius: 8px;
            font-size: 0.85rem;
            background: linear-gradient(#406e6d, #749b98);
            color: #fff;
            cursor: pointer;
            user-select: none;
            box-shadow: 0 2px 2px rgba(51, 54, 67, .25);
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }
        .common-tag.pinned {
            background: linear-gradient(#8d79c0, #7a78dc);
        }
        .common-tag:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(51, 54, 67, .25);
        }

        .common-tag.dragging {
            opacity: 0.5;
        }

        /* 主题切换按钮 */
        .theme-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: var(--primary-color);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 100;
            transition: all 0.3s ease;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
        }

        /* 设置按钮（位于主题切换按钮之上） */
        .settings-toggle {
            position: fixed;
            bottom: 80px;
            right: 20px;
            width: 46px;
            height: 46px;
            border-radius: 50%;
            background-color: var(--card-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 100;
            transition: all 0.3s ease;
        }
        .settings-toggle:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(0,0,0,.2);
        }

        /* 响应式设计 */
        @media (max-width: 968px) {
            .sidebar {
                width: 250px;
            }
            
            .main-content {
                margin-left: 250px;
            }
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: auto;
                position: relative;
            }
            
            .main-content {
                margin-left: 0;
            }
            
            .header {
                flex-direction: column;
                gap: 15px;
                align-items: flex-start;
            }
            
            .header-actions {
                width: 100%;
                justify-content: space-between;
            }
        }

        /* 动画效果 */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .editor-card {
            animation: fadeIn 0.5s ease;
        }

        /* 滚动条样式 */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-color);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary-color);
        }
        /* 居中模态框样式 */
        .modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.35);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .modal {
            width: min(92vw, 480px);
            background: var(--card-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        .modal-header {
            padding: 14px 16px;
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-body {
            padding: 16px;
            display: grid;
            gap: 12px;
        }
        .modal-row {
            display: grid;
            gap: 6px;
        }
        .modal-row label {
            font-size: 0.9rem;
            opacity: 0.85;
        }
        .modal-input {
            /* width: 100%; */
            padding: 10px 12px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background: var(--bg-color);
            color: var(--text-color);
            outline: none;
        }
        .modal-input:focus {
            border-color: var(--primary-color);
        }
        .modal-footer {
            padding: 12px 16px;
            border-top: 1px solid var(--border-color);
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        .hidden { display: none; }

        /* Toggle Switch 样式 */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--border-color);
            transition: 0.3s;
            border-radius: 24px;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }
        .toggle-switch input:checked + .toggle-slider {
            background-color: var(--primary-color);
        }
        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }

        /* 右键菜单 */
        .context-menu {
            position: fixed;
            z-index: 2000;
            min-width: 150px;
            background: var(--card-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 8px 24px rgba(0,0,0,.18);
            padding: 6px 0;
            display: none;
        }
        .context-menu .item {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.9rem;
        }
        .context-menu .item:hover {
            background: var(--bg-color);
        }
        /* 让通用提示模态位于最上层（覆盖其他模态） */
        #modal-confirm {
            z-index: 5000;
        }
        /* 编辑标签模态框（需要覆盖搜索模态框） */
        #modal-tag {
            z-index: 4000;
        }
        /* 提示词历史模态宽度扩展 */
        #modal-history .modal {
            width: min(92vw, 720px);
        }
        /* 提示词历史模态主体在内容过多时可滚动 */
        #modal-history .modal-body {
            max-height: 60vh;
            overflow: auto;
        }
        /* 右键菜单设置模态：加宽并在内容过高时可滚动 */
        #modal-ctxmenu .modal {
            width: min(92vw, 720px);
        }
        #modal-ctxmenu .modal-body {
            max-height: 60vh;
            overflow: auto;
        }
        /* 类别按钮式选择的按压/选中态 */
        .btn-toggle.active {
            background-color: var(--primary-color);
            color: #fff;
            box-shadow: inset 0 2px 6px rgba(0,0,0,.25);
            border-color: var(--primary-color);
        }
        .btn-toggle:active {
            transform: translateY(0);
            box-shadow: inset 0 2px 6px rgba(0,0,0,.25);
        }
        .token-counter {
            text-align: right;
            font-size: 12px;
            opacity: .75;
            margin-top: 6px;
        }
    /* 降低动画以满足系统减少动态偏好 */
    @media (prefers-reduced-motion: reduce) {
        * {
            animation-duration: 0.01ms !important;
            animation-iteration-count: 1 !important;
            transition-duration: 0.01ms !important;
            scroll-behavior: auto !important;
        }
    }
    </style>
</head>
<body>
    <div class="container">
        <!-- 侧边栏 -->
        <div class="sidebar">
            <div class="logo">
                <a href="https://github.com/IIIStudio/PromptStudio" target="_blank" rel="noopener" style="display:flex;align-items:center;color:inherit;text-decoration:none;">
                    <i class="fab fa-github logo-icon"></i>
                    <h1>Prompt Studio</h1>
                </a>
            </div>
            
            <div class="category-list">
                <div class="category-title">
                    <span>提示词标签</span>
                    <button class="btn btn-outline icon-plus" id="add-category-btn" title="新建标签"></button>
                </div>
                <div class="prompt-list">
                    
                    
                </div>
            </div>
        </div>
        
        <!-- 主内容区 -->
        <div class="main-content">
            <div class="header">
                <h2>提示词编辑器</h2>
                <div class="header-actions">
                    <button class="btn btn-outline" id="download-json-btn">
                        <i class="fas fa-save"></i> 下载JSON/上传
                    </button>
                    <button class="btn btn-primary" id="import-json-btn">
                        <i class="fas fa-file-import"></i> 导入JSON
                    </button>
                    <button class="btn btn-outline" id="sync-config-btn">
                        <i class="fas fa-sync"></i> 同步
                    </button>
                    <button class="btn btn-outline" id="reset-all-btn">
                        <i class="fas fa-trash"></i> 重置
                    </button>
                </div>
            </div>
            
            <div class="editor-container">
                <div class="editor-card">
                    <div class="editor-header">
                        <div class="editor-title">
                            <i class="fas fa-edit"></i> 提示词内容
                        </div>
                        <div class="editor-actions">
                            <button class="btn btn-outline" id="search-tags-btn">
                                <i class="fas fa-search"></i> 搜索
                            </button>
                            <button class="btn btn-outline" id="random-pick-btn">
                                <i class="fas fa-dice"></i> 随机
                            </button>
                            <button class="btn btn-outline" onclick="resetPrompt()">
                                <i class="fas fa-redo"></i> 重置
                            </button>
                            <button class="btn btn-outline" onclick="copyPrompt()">
                                <i class="fas fa-copy"></i> 复制
                            </button>
                            <button class="btn btn-outline" id="save-prompt-btn">
                                <i class="fas fa-bookmark"></i> 存储
                            </button>
                            <button class="btn btn-outline" id="view-history-btn">
                                <i class="fas fa-list"></i> 查看
                            </button>
                        </div>
                    </div>
                    <textarea class="editor-textarea" id="prompt-editor"></textarea>

                    
                    <div class="prompt-tags" id="prompt-tags-container">
                        <!-- 标签将通过JavaScript动态生成 -->
                    </div>

                    <div class="common-tags-section">
                        <div class="common-tags-title">常用提示词
                            <button class="btn btn-outline icon-plus" id="add-tag-btn" style="margin-left:8px" title="添加标签"></button>
                            <button class="btn btn-outline" id="export-tags-image-btn" style="margin-left:8px" title="生成提示词图片并下载">提示词图片</button>
                            <button class="btn btn-outline" id="compose-tags-image-btn" style="margin-left:8px" title="合成提示词图片到选择的图片">合成图片</button>
                        </div>
                        <div class="common-tags" id="common-tags">

                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 设置按钮 -->
    <div class="settings-toggle" id="settings-toggle" title="右键菜单设置">
        <i class="fas fa-cog"></i>
    </div>
    <!-- 主题切换按钮 -->
    <div class="theme-toggle" id="theme-toggle">
        <i class="fas fa-moon"></i>
    </div>
    <input type="file" id="json-file-input" accept="application/json" style="display:none" />
    <!-- 新建分类 模态框 -->
    <div class="modal-backdrop" id="modal-category">
        <div class="modal">
            <div class="modal-header">
                <span>新建提示词标签</span>
                <button class="btn btn-outline" id="modal-cat-close">关闭</button>
            </div>
            <div class="modal-body">
                <div class="modal-row">
                    <label for="modal-cat-name">分类名称</label>
                    <input class="modal-input" id="modal-cat-name" type="text" placeholder="例如：人脸标签" />
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-outline" id="modal-cat-cancel">取消</button>
                <button class="btn btn-primary" id="modal-cat-confirm">确定</button>
            </div>
        </div>
    </div>
    <!-- 添加标签 模态框 -->
    <div class="modal-backdrop" id="modal-tag">
        <div class="modal">
            <div class="modal-header">
                <span id="modal-tag-title">添加标签</span>
                <button class="btn btn-outline" id="modal-tag-close">关闭</button>
            </div>
            <div class="modal-body">
                <div class="modal-row" style="font-size:12px;opacity:.75;">
                    支持批量添加多个标签，使用分号(;)或顿号(、)分隔
                </div>
                <div class="modal-row">
                    <label for="modal-tag-zh">中文</label>
                    <input class="modal-input" id="modal-tag-zh" type="text" placeholder="例如：斗鸡眼;歪嘴;龅牙" />
                </div>
                <div class="modal-row">
                    <label for="modal-tag-en">英文</label>
                    <input class="modal-input" id="modal-tag-en" type="text" placeholder="例如：cross-eyed;crooked mouth;bucktooth" />
                </div>
                <div class="modal-row">
                    <label>类别</label>
                    <div id="modal-subcat-buttons" style="display:flex;flex-wrap:wrap;gap:8px;">
                        <button class="btn btn-outline" id="modal-subcat-newbtn" type="button">新建类别</button>
                        <!-- 下面的现有类别按钮将由 openTagModal 动态生成 -->
                    </div>
                </div>

                <div class="modal-row">
                    <label for="modal-cy-token">彩云翻译 Token</label>
                    <input class="modal-input" id="modal-cy-token" type="password" placeholder="请输入你的彩云翻译 Token" />
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-outline" id="modal-tag-translate-mymemory" title="使用 Translated 翻译">Translated</button>
                <button class="btn btn-outline" id="modal-tag-translate" title="将中文翻译为英文">彩云翻译</button>
                <button class="btn btn-outline" id="modal-tag-cancel">取消</button>
                <button class="btn btn-primary" id="modal-tag-confirm">确定</button>
            </div>
        </div>
    </div>

    <!-- 右键菜单容器 -->
    <div id="context-menu" class="context-menu">
        <div id="context-menu-list"></div>
    </div>

    <!-- 通用确认模态框 -->
    <div class="modal-backdrop" id="modal-confirm">
        <div class="modal">
            <div class="modal-header">
                <span id="modal-confirm-title">确认操作</span>
                <button class="btn btn-outline" id="modal-confirm-close">关闭</button>
            </div>
            <div class="modal-body">
                <div class="modal-row">
                    <div id="modal-confirm-message"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-outline" id="modal-confirm-cancel">取消</button>
                <button class="btn btn-primary" id="modal-confirm-ok">确定</button>
            </div>
        </div>
    </div>

    <!-- 历史快照模态框 -->
    <div class="modal-backdrop" id="modal-history">
        <div class="modal">
            <div class="modal-header">
                <span>提示词历史</span>
                <button class="btn btn-outline" id="modal-history-close">关闭</button>
            </div>
            <div class="modal-body">
                <div id="history-list" style="display:flex;flex-direction:column;gap:8px;"></div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-outline" id="modal-history-clear">清空全部</button>
            </div>
        </div>
    </div>

    <!-- 右键菜单设置模态框 -->
    <div class="modal-backdrop" id="modal-ctxmenu">
        <div class="modal">
            <div class="modal-header">
                <span>右键菜单设置</span>
                <button class="btn btn-outline" id="modal-ctx-close">关闭</button>
            </div>
            <div class="modal-body">
                <div class="modal-row" style="font-size:12px;opacity:.8;">
                    支持占位符：{{中文}}、{{英文}}（将自动进行 URL 编码）
                </div>
                <div class="modal-row">
                    <button class="btn btn-outline" id="ctx-add-btn">新增菜单项</button>
                </div>
                <div class="modal-row">
                    <div id="ctx-list" style="display:flex;flex-direction:column;gap:8px;"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" id="modal-ctx-save">保存</button>
            </div>
        </div>
    </div>

    <!-- 搜索提示词模态框 -->
    <div class="modal-backdrop" id="modal-search-tags">
        <div class="modal" style="width: min(92vw, 640px);">
            <div class="modal-header">
                <span>搜索提示词</span>
                <button class="btn btn-outline" id="modal-search-close">关闭</button>
            </div>
            <div class="modal-body">
                <div class="modal-row">
                    <input class="modal-input" id="search-input" type="text" placeholder="输入中文或英文关键词搜索..." />
                </div>
                <div class="modal-row">
                    <div id="search-results" style="display:flex;flex-direction:column;gap:8px;max-height:400px;overflow:auto;">
                        <div style="opacity:0.6;font-size:0.9rem;">输入关键词后，下方将显示匹配的提示词</div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" id="modal-search-clear">清空搜索</button>
            </div>
        </div>
    </div>

    <!-- 编辑分类模态框 -->
    <div class="modal-backdrop" id="modal-edit-category">
        <div class="modal">
            <div class="modal-header">
                <span>编辑分类</span>
                <button class="btn btn-outline" id="modal-edit-cat-close">关闭</button>
            </div>
            <div class="modal-body">
                <div class="modal-row">
                    <label for="modal-edit-cat-name">分类名称</label>
                    <input class="modal-input" id="modal-edit-cat-name" type="text" placeholder="例如：人脸标签" />
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-outline" id="modal-edit-cat-cancel">取消</button>
                <button class="btn btn-primary" id="modal-edit-cat-confirm">确定</button>
            </div>
        </div>
    </div>

    <!-- 同步配置模态框 -->
    <div class="modal-backdrop" id="modal-sync">
        <div class="modal">
            <div class="modal-header">
                <span>同步配置</span>
                <div style="display:flex;align-items:center;gap:8px;">
                    <label style="font-size:14px;">启用云端</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="modal-cloud-enabled" />
                        <span class="toggle-slider"></span>
                    </label>
                    <button class="btn btn-outline" id="modal-sync-close">关闭</button>
                </div>
            </div>
            <div class="modal-body">
                <div class="modal-row">
                    <label>同步方式</label>
                    <div id="sync-provider-buttons" style="display:flex;flex-wrap:wrap;gap:8px;">
                        <button class="btn btn-toggle btn-outline" data-provider="dropbox" id="btn-provider-dropbox">Dropbox</button>
                        <button class="btn btn-toggle btn-outline" data-provider="s3" id="btn-provider-s3">S3 (腾讯云 COS)</button>
                    </div>
                </div>

                <!-- Dropbox 配置区域 -->
                <div id="sync-dropbox-config">
                    <div class="modal-row">
                        <label for="modal-db-key">App Key</label>
                        <input class="modal-input" id="modal-db-key" type="text" placeholder="Dropbox App Key" />
                    </div>
                    <div class="modal-row">
                        <label for="modal-db-secret">App Secret</label>
                        <input class="modal-input" id="modal-db-secret" type="text" placeholder="Dropbox App Secret" />
                    </div>
                    <div class="modal-row">
                        <label for="modal-db-refresh">Refresh Token / 授权码或回调URL</label>
                        <input class="modal-input" id="modal-db-refresh" type="password" placeholder="可粘贴 Refresh Token，或直接粘贴回调后的整条URL" />
                    </div>
                    <div class="modal-row" style="font-size:12px;opacity:.75;"><p></p>
                        <p style="color:var(--danger-color);margin-bottom:8px;">
                            ⚠️ 使用说明：点击"授权"在弹窗中登录并同意授权。授权完成后若拿到 https://localhost/?code=...，可直接将整条地址或 code部分 粘贴到上方输入框并点"登录"，系统会自动先兑换 Refresh Token；若已拿到 Refresh Token，直接粘贴后点"登录"即可获取临时 Access Token。
                        </p>
                    </div>
                </div>

                <!-- S3 配置区域 -->
                <div id="sync-s3-config" style="display:none;">
                    <div class="modal-row">
                        <label for="modal-s3-secret-id">Secret ID</label>
                        <input class="modal-input" id="modal-s3-secret-id" type="password" placeholder="腾讯云 API 密钥 SecretId" />
                    </div>
                    <div class="modal-row">
                        <label for="modal-s3-secret-key">Secret Key</label>
                        <input class="modal-input" id="modal-s3-secret-key" type="password" placeholder="腾讯云 API 密钥 SecretKey" />
                    </div>
                    <div class="modal-row">
                        <label for="modal-s3-region">Region</label>
                        <input class="modal-input" id="modal-s3-region" type="password" placeholder="存储桶所在区域，例如 ap-beijing" />
                    </div>
                    <div class="modal-row">
                        <label for="modal-s3-bucket">Bucket Name</label>
                        <input class="modal-input" id="modal-s3-bucket" type="password" placeholder="存储桶名称，例如 examplebucket-1250000000" />
                    </div>
                    <div class="modal-row" style="font-size:12px;opacity:.75;">
                      <p style="color:var(--danger-color);margin-bottom:8px;">⚠️ 重要：必须配置 CORS 才能使用！如何开启 <a href="https://cnb.cool/IIIStudio/Code/HTML/PromptStudio#s3-%E8%85%BE%E8%AE%AF%E4%BA%91-cos%E5%8F%AF%E9%80%89" target="_blank">CORS 配置</a>文件会在
Prompt Studio目录下</p>
                    </div>
                </div>
            </div>
            <div class="modal-footer" id="sync-footer-dropbox">
                <button class="btn btn-outline" id="modal-db-cancel">取消</button>
                <button class="btn btn-outline" id="modal-db-authorize">授权</button>
                <button class="btn btn-success" id="modal-db-login">登录</button>
                <button class="btn btn-primary" id="modal-db-save">保存</button>
            </div>
            <div class="modal-footer hidden" id="sync-footer-s3">
                <button class="btn btn-outline" id="modal-s3-cancel">取消</button>
                <button class="btn btn-primary" id="modal-s3-save">保存</button>
            </div>
        </div>
    </div>

    <script>
        // 主题切换功能（持久化 + 跟随系统偏好）
        const themeToggle = document.getElementById('theme-toggle');
        const THEME_KEY = 'ops_theme';

        function applyTheme(mode) {
            const isDark = mode === 'dark';
            document.body.classList.toggle('dark-mode', isDark);
            const icon = themeToggle?.querySelector('i');
            if (icon) {
                if (isDark) {
                    icon.classList.remove('fa-moon');
                    icon.classList.add('fa-sun');
                } else {
                    icon.classList.remove('fa-sun');
                    icon.classList.add('fa-moon');
                }
            }
        }

        // 首次加载：优先使用本地保存，其次使用系统偏好
        (function initTheme() {
            try {
                const saved = localStorage.getItem(THEME_KEY);
                const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                const mode = saved === 'dark' || saved === 'light' ? saved : (prefersDark ? 'dark' : 'light');
                applyTheme(mode);
            } catch(e) {
                applyTheme('light');
            }
        })();

        themeToggle?.addEventListener('click', () => {
            const next = document.body.classList.contains('dark-mode') ? 'light' : 'dark';
            applyTheme(next);
            try { localStorage.setItem(THEME_KEY, next); } catch(e) {}
        });
        
        // 提示词编辑器
        const promptEditor = document.getElementById('prompt-editor');

        const TAG_WEIGHT_MIN = 0.5;
        const TAG_WEIGHT_MAX = 2;
        const TAG_WEIGHT_STEP_TICKS = 1; // 单步对应 0.1
        const TAG_WEIGHT_MIN_TICKS = Math.round(TAG_WEIGHT_MIN * 10);
        const TAG_WEIGHT_MAX_TICKS = Math.round(TAG_WEIGHT_MAX * 10);

        function parseWeightedTag(raw) {
            const text = (raw || '').trim();
            if (!text) {
                return { base: '', weight: 1, hasWeight: false };
            }
            if (text.startsWith('(') && text.endsWith(')')) {
                const inner = text.slice(1, -1);
                const colonIndex = inner.lastIndexOf(':');
                if (colonIndex > 0) {
                    const base = inner.slice(0, colonIndex).trim();
                    const weightStr = inner.slice(colonIndex + 1).trim();
                    const weightNum = parseFloat(weightStr);
                    if (base && !Number.isNaN(weightNum)) {
                        return { base, weight: weightNum, hasWeight: true };
                    }
                }
            }
            return { base: text, weight: 1, hasWeight: false };
        }

        function clampWeightTicks(ticks) {
            if (!Number.isFinite(ticks)) return Math.round(1 * 10);
            if (ticks < TAG_WEIGHT_MIN_TICKS) return TAG_WEIGHT_MIN_TICKS;
            if (ticks > TAG_WEIGHT_MAX_TICKS) return TAG_WEIGHT_MAX_TICKS;
            return ticks;
        }

        function ticksToWeight(ticks) {
            return clampWeightTicks(Math.round(ticks)) / 10;
        }

        function weightToTicks(weight) {
            const safeWeight = Number.isFinite(weight) ? weight : 1;
            return clampWeightTicks(Math.round(safeWeight * 10));
        }

        function formatWeightedTag(baseText, weightValue) {
            const base = (baseText || '').trim();
            if (!base) return '';
            const ticks = weightToTicks(weightValue);
            if (ticks === Math.round(1 * 10)) {
                return base;
            }
            const normalizedWeight = ticks / 10;
            const weightStr = (Math.round(normalizedWeight * 100) / 100).toFixed(2).replace(/\. ?0+$/, '');
            return `(${base}:${weightStr})`;
        }

        function computeNextWeight(currentWeight, deltaSteps) {
            const currentTicks = weightToTicks(currentWeight);
            const nextTicks = clampWeightTicks(currentTicks + (deltaSteps * TAG_WEIGHT_STEP_TICKS));
            return nextTicks / 10;
        }

        function adjustTagWeightBySteps(currentTag, deltaSteps) {
            if (!currentTag) return;
            const parsed = parseWeightedTag(currentTag);
            const base = parsed.base;
            const baseKey = base.toLowerCase();
            const curW = Number.isFinite(parsed.weight) ? parsed.weight : 1;
            const nextW = computeNextWeight(curW, deltaSteps);
            const formatted = formatWeightedTag(base, nextW);

            weightStateMap.set(baseKey, nextW);

            if (Array.isArray(window.__lastRenderList)) {
                const pos = window.__lastRenderList.indexOf(currentTag);
                if (pos >= 0) window.__lastRenderList.splice(pos, 1, formatted);
            }
            if (window.__disabledTagSet.has(currentTag)) {
                window.__disabledTagSet.delete(currentTag);
                window.__disabledTagSet.add(formatted);
            }
            let parts = (promptEditor.value || '').split(/[,，]/)
                .map(s => formatWeightedTag(parseWeightedTag(s).base, parseWeightedTag(s).weight))
                .filter(Boolean);
            const idx = parts.indexOf(currentTag);
            if (idx >= 0) {
                parts[idx] = formatted;
                promptEditor.value = parts.join(', ');
            }
            normalizePromptInput();
            updateTags();
        }

        // 右键菜单配置存取
        const MENU_KEY = 'ops_ctx_menu_items';
        function getCtxMenus() {
            try {
                const raw = localStorage.getItem(MENU_KEY);
                const arr = raw ? JSON.parse(raw) : [];
                return Array.isArray(arr) ? arr.filter(x => x && typeof x === 'object') : [];
            } catch(e) { return []; }
        }
        function setCtxMenus(arr) {
            try { localStorage.setItem(MENU_KEY, JSON.stringify(Array.isArray(arr) ? arr : [])); } catch(e) {}
        }
        // URL 模板：支持 {{中文}} / {{英文}}，自动 URL 编码
        function buildUrlFromTemplate(tpl, en, zh) {
            const rep = s => encodeURIComponent(s || '');
            return String(tpl || '')
                .replace(/{{\s*英文\s*}}/g, rep(en || ''))
                .replace(/{{\s*中文\s*}}/g, rep(zh || ''));
        }

        // 设置弹窗
        function openCtxMenuModal() {
            const wrap = document.getElementById('modal-ctxmenu');
            const closeBtn = document.getElementById('modal-ctx-close');
            const saveBtn = document.getElementById('modal-ctx-save');
            const list = document.getElementById('ctx-list');
            const addBtn = document.getElementById('ctx-add-btn');

            let data = getCtxMenus().slice();

            function renderList() {
                list.innerHTML = '';
                if (!data.length) {
                    const empty = document.createElement('div');
                    empty.style.opacity = '.7';
                    empty.style.fontSize = '0.9rem';
                    empty.textContent = '暂无菜单项，点击"新增菜单项"进行添加';
                    list.appendChild(empty);
                    return;
                }
                data.forEach((m, i) => {
                    const row = document.createElement('div');
                    row.style.border = '1px solid var(--border-color)';
                    row.style.borderRadius = '8px';
                    row.style.padding = '8px';
                    row.style.display = 'grid';
                    row.style.gap = '6px';

                    const head = document.createElement('div');
                    head.style.display = 'flex';
                    head.style.justifyContent = 'space-between';
                    head.style.alignItems = 'center';

                    const title = document.createElement('div');
                    title.style.display = 'flex';
                    title.style.alignItems = 'center';
                    title.style.gap = '8px';

                    const iconEl = document.createElement('i');
                    iconEl.className = (m.icon || 'fas fa-globe');
                    const nameEl = document.createElement('span');
                    nameEl.textContent = m.name || '(未命名)';
                    nameEl.style.fontWeight = '600';

                    title.appendChild(iconEl);
                    title.appendChild(nameEl);

                    const ops = document.createElement('div');
                    ops.style.display = 'flex';
                    ops.style.gap = '8px';

                    const btnEdit = document.createElement('button');
                    btnEdit.className = 'btn btn-outline';
                    btnEdit.textContent = '编辑';
                    btnEdit.addEventListener('click', async () => {
                        const icon = await showIconPicker(m.icon || 'fas fa-globe');
                        if (icon === null) return;
                        const name = await showInputModal('名称', '谷歌翻译', m.name || '');
                        if (name === null) return;
                        const url = await showInputModal('链接模板', '例如：https://translate.google.com/?source=osdd&sl=auto&tl=zh-CN&text={{英文}}', m.url || '');
                        if (url === null) return;
                        data[i] = { icon: (icon || 'fas fa-globe').trim(), name: (name || '').trim(), url: (url || '').trim() };
                        renderList();
                    });

                    const btnDel = document.createElement('button');
                    btnDel.className = 'btn btn-outline';
                    btnDel.textContent = '删除';
                    btnDel.addEventListener('click', async () => {
                        const ok = await showConfirm('确认删除该菜单项？', '删除菜单项');
                        if (!ok) return;
                        data.splice(i, 1);
                        renderList();
                    });

                    const btnUp = document.createElement('button');
                    btnUp.className = 'btn btn-outline';
                    btnUp.textContent = '上移';
                    btnUp.addEventListener('click', () => {
                        if (i <= 0) return;
                        const tmp = data[i - 1];
                        data[i - 1] = data[i];
                        data[i] = tmp;
                        renderList();
                    });

                    const btnDown = document.createElement('button');
                    btnDown.className = 'btn btn-outline';
                    btnDown.textContent = '下移';
                    btnDown.addEventListener('click', () => {
                        if (i >= data.length - 1) return;
                        const tmp = data[i + 1];
                        data[i + 1] = data[i];
                        data[i] = tmp;
                        renderList();
                    });

                    ops.appendChild(btnEdit);
                    ops.appendChild(btnUp);
                    ops.appendChild(btnDown);
                    ops.appendChild(btnDel);

                    head.appendChild(title);
                    head.appendChild(ops);

                    const urlPreview = document.createElement('div');
                    urlPreview.style.fontSize = '0.85rem';
                    urlPreview.style.opacity = '.75';
                    urlPreview.textContent = m.url || '';

                    row.appendChild(head);
                    row.appendChild(urlPreview);
                    list.appendChild(row);
                });
            }

            addBtn.onclick = async () => {
                const icon = await showIconPicker('fas fa-globe');
                if (icon === null) return;
                const name = await showInputModal('名称', '菜单名字，例如：谷歌翻译', '');
                if (name === null) return;
                const url = await showInputModal('链接模板', '例如：https://translate.google.com/?source=osdd&sl=auto&tl=zh-CN&text={{英文}}', '');
                if (url === null) return;
                data.push({ icon: (icon || 'fas fa-globe').trim(), name: (name || '').trim(), url: (url || '').trim() });
                renderList();
            };

            function onSave() {
                const cleaned = data.filter(m => (m && (m.url || '').trim() && (m.name || '').trim()))
                    .map(m => ({ icon: (m.icon || 'fas fa-globe').trim(), name: m.name.trim(), url: m.url.trim() }));
                setCtxMenus(cleaned);
                hide(wrap);
            }
            function onClose() { hide(wrap); }

            saveBtn.onclick = onSave;
            closeBtn.onclick = onClose;

            renderList();
            show(wrap);
        }

        // 绑定设置按钮
        document.getElementById('settings-toggle')?.addEventListener('click', openCtxMenuModal);



        // 设置弹窗
        function openCtxMenuModal() {
            const wrap = document.getElementById('modal-ctxmenu');
            const closeBtn = document.getElementById('modal-ctx-close');
            const saveBtn = document.getElementById('modal-ctx-save');
            const list = document.getElementById('ctx-list');
            const addBtn = document.getElementById('ctx-add-btn');

            let data = getCtxMenus().slice();

            function renderList() {
                list.innerHTML = '';
                if (!data.length) {
                    const empty = document.createElement('div');
                    empty.style.opacity = '.7';
                    empty.style.fontSize = '0.9rem';
                    empty.textContent = '暂无菜单项，点击"新增菜单项"进行添加';
                    list.appendChild(empty);
                    return;
                }
                data.forEach((m, i) => {
                    const row = document.createElement('div');
                    row.style.border = '1px solid var(--border-color)';
                    row.style.borderRadius = '8px';
                    row.style.padding = '8px';
                    row.style.display = 'grid';
                    row.style.gap = '6px';

                    const head = document.createElement('div');
                    head.style.display = 'flex';
                    head.style.justifyContent = 'space-between';
                    head.style.alignItems = 'center';

                    const title = document.createElement('div');
                    title.style.display = 'flex';
                    title.style.alignItems = 'center';
                    title.style.gap = '8px';

                    const iconEl = document.createElement('i');
                    iconEl.className = (m.icon || 'fas fa-globe');
                    const nameEl = document.createElement('span');
                    nameEl.textContent = m.name || '(未命名)';
                    nameEl.style.fontWeight = '600';

                    title.appendChild(iconEl);
                    title.appendChild(nameEl);

                    const ops = document.createElement('div');
                    ops.style.display = 'flex';
                    ops.style.gap = '8px';

                    const btnEdit = document.createElement('button');
                    btnEdit.className = 'btn btn-outline';
                    btnEdit.textContent = '编辑';
                    btnEdit.addEventListener('click', async () => {
                        const icon = await showIconPicker(m.icon || 'fas fa-globe');
                        if (icon === null) return;
                        const name = await showInputModal('名称', '菜单名字，例如：谷歌翻译', m.name || '');
                        if (name === null) return;
                        const url = await showInputModal('链接模板', '例如：https://translate.google.com/?source=osdd&sl=auto&tl=zh-CN&text={{英文}}', m.url || '');
                        if (url === null) return;
                        data[i] = { icon: (icon || 'fas fa-globe').trim(), name: (name || '').trim(), url: (url || '').trim() };
                        renderList();
                    });

                    const btnDel = document.createElement('button');
                    btnDel.className = 'btn btn-outline';
                    btnDel.textContent = '删除';
                    btnDel.addEventListener('click', async () => {
                        const ok = await showConfirm('确认删除该菜单项？', '删除菜单项');
                        if (!ok) return;
                        data.splice(i, 1);
                        renderList();
                    });

                    const btnUp = document.createElement('button');
                    btnUp.className = 'btn btn-outline';
                    btnUp.textContent = '上移';
                    btnUp.addEventListener('click', () => {
                        if (i <= 0) return;
                        const tmp = data[i - 1];
                        data[i - 1] = data[i];
                        data[i] = tmp;
                        renderList();
                    });

                    const btnDown = document.createElement('button');
                    btnDown.className = 'btn btn-outline';
                    btnDown.textContent = '下移';
                    btnDown.addEventListener('click', () => {
                        if (i >= data.length - 1) return;
                        const tmp = data[i + 1];
                        data[i + 1] = data[i];
                        data[i] = tmp;
                        renderList();
                    });

                    ops.appendChild(btnEdit);
                    ops.appendChild(btnUp);
                    ops.appendChild(btnDown);
                    ops.appendChild(btnDel);

                    head.appendChild(title);
                    head.appendChild(ops);

                    const urlPreview = document.createElement('div');
                    urlPreview.style.fontSize = '0.85rem';
                    urlPreview.style.opacity = '.75';
                    urlPreview.textContent = m.url || '';

                    row.appendChild(head);
                    row.appendChild(urlPreview);
                    list.appendChild(row);
                });
            }

            addBtn.onclick = async () => {
                const icon = await showIconPicker('fas fa-globe');
                if (icon === null) return;
                const name = await showInputModal('名称', '菜单名字，例如：谷歌翻译', '');
                if (name === null) return;
                const url = await showInputModal('链接模板', '例如：https://translate.google.com/?source=osdd&sl=auto&tl=zh-CN&text={{英文}}', '');
                if (url === null) return;
                data.push({ icon: (icon || 'fas fa-globe').trim(), name: (name || '').trim(), url: (url || '').trim() });
                renderList();
            };

            function onSave() {
                const cleaned = data.filter(m => (m && (m.url || '').trim() && (m.name || '').trim()))
                    .map(m => ({ icon: (m.icon || 'fas fa-globe').trim(), name: m.name.trim(), url: m.url.trim() }));
                setCtxMenus(cleaned);
                hide(wrap);
            }
            function onClose() { hide(wrap); }

            saveBtn.onclick = onSave;
            closeBtn.onclick = onClose;

            renderList();
            show(wrap);
        }
        const tagsContainer = document.getElementById('prompt-tags-container');
        const commonTagsContainer = document.getElementById('common-tags');
        const weightStateMap = new Map();
        const weightPrefKey = 'ops_weight_controls_enabled';
        const savedWeightPref = localStorage.getItem(weightPrefKey);
        if (savedWeightPref === null) {
            window.__weightControlsEnabled = false;
        } else {
            window.__weightControlsEnabled = savedWeightPref === 'true';
        }
        function updateWeightControlVisibility() {
            const enabled = window.__weightControlsEnabled;
            if (!tagsContainer) return;
            tagsContainer.querySelectorAll('.prompt-tag').forEach(tagEl => {
                tagEl.classList.toggle('weight-disabled', !enabled);
                const panel = tagEl.querySelector('[data-role="weight-panel"]');
                if (panel) panel.style.display = enabled ? 'inline-flex' : 'none';
            });
        }
        // 确保 Token 计数器存在，并添加权重开关
        (function ensureTokenCounter() {
            try {
                let wrap = document.getElementById('token-counter-wrap');
                if (!wrap) {
                    wrap = document.createElement('div');
                    wrap.id = 'token-counter-wrap';
                    wrap.style.display = 'flex';
                    wrap.style.justifyContent = 'space-between';
                    wrap.style.alignItems = 'center';
                    wrap.style.gap = '12px';

                    const toggleLabel = document.createElement('label');
                    toggleLabel.className = 'weight-toggle';
                    const initialEnabled = window.__weightControlsEnabled;
                    toggleLabel.innerHTML = `
                        <input type="checkbox" id="weight-visibility-toggle"${initialEnabled ? ' checked' : ''}>
                        <span class="slider"></span>
                        <span class="label-text">显示权重控制</span>
                    `;

                    const counter = document.createElement('div');
                    counter.id = 'token-counter';
                    counter.className = 'token-counter';
                    counter.textContent = 'Tokens: 0/75';

                    wrap.appendChild(toggleLabel);
                    wrap.appendChild(counter);

                    if (promptEditor && promptEditor.parentNode) {
                        promptEditor.parentNode.insertBefore(wrap, promptEditor.nextSibling);
                    }

                    const toggle = wrap.querySelector('#weight-visibility-toggle');
                    if (toggle) {
                        toggle.checked = window.__weightControlsEnabled;
                        updateWeightControlVisibility();
                        toggle.addEventListener('change', (e) => {
                            const enabled = !!e.target.checked;
                            window.__weightControlsEnabled = enabled;
                            try {
                                localStorage.setItem(weightPrefKey, String(enabled));
                            } catch (_) {}
                            updateWeightControlVisibility();
                        });
                    }
                } else {
                    const counter = document.getElementById('token-counter');
                    if (counter) counter.textContent = 'Tokens: 0/75';
                }
            } catch(_) {}
        })();

        // 本地存储常用提示词（顶层为分类名，值为数组 {text, lang_zh}）
        let commonData = {};
        let zhToEnMap = null;
        const sidebarList = document.querySelector('.prompt-list');
        const STORAGE_KEY = 'ops_common_data';

        function normalizeZhKey(text) {
            if (typeof text !== 'string') return '';
            return text.trim().replace(/\s+/g, '');
        }

        function extractZhVariants(raw) {
            const base = typeof raw === 'string' ? raw.trim() : '';
            if (!base) return [];
            const variants = new Set([base]);
            base.split(/[\|｜/、，,;；]+/).forEach(part => {
                const trimmed = part.trim();
                if (trimmed) variants.add(trimmed);
            });
            return Array.from(variants);
        }

        function refreshZhToEnCache() {
            const map = new Map();
            const addPair = (variant, enText) => {
                const key = normalizeZhKey(variant);
                if (!key || map.has(key)) return;
                map.set(key, enText);
            };
            const collectFromArray = (arr) => {
                arr.forEach(item => {
                    const enText = (item?.text || '').trim();
                    const zhRaw = (item?.lang_zh || '').trim();
                    if (!enText || !zhRaw) return;
                    extractZhVariants(zhRaw).forEach(variant => addPair(variant, enText));
                });
            };
            try {
                Object.keys(commonData || {}).forEach(cat => {
                    const value = commonData[cat];
                    if (Array.isArray(value)) {
                        collectFromArray(value);
                    } else if (isGroupedCategory(value)) {
                        const groups = value.groups || {};
                        Object.keys(groups).forEach(groupKey => {
                            const arr = groups[groupKey];
                            if (Array.isArray(arr)) collectFromArray(arr);
                        });
                    }
                });
            } catch (_) {}
            zhToEnMap = map;
        }

        function findEn(zhText) {
            const key = normalizeZhKey(zhText);
            if (!key) return '';
            if (!zhToEnMap) refreshZhToEnCache();
            return zhToEnMap?.get(key) || '';
        }

        // 分组工具函数
        function isGroupedCategory(v) {
            return v && typeof v === 'object' && !Array.isArray(v) && v.groups && typeof v.groups === 'object';
        }
        function getGroups(cat) {
            const v = commonData?.[cat];
            if (isGroupedCategory(v)) return v.groups;
            return null;
        }
        function ensureGrouped(cat) {
            const v = commonData?.[cat];
            if (isGroupedCategory(v)) return; // 已是分组
            const arr = Array.isArray(v) ? v : [];
            if (arr.length > 0) {
                // 旧有条目迁移到"未分组"
                commonData[cat] = { groups: { '未分组': arr } };
            } else {
                // 空分类：不自动创建"未分组"
                commonData[cat] = { groups: {}, groupsOrder: [] };
            }
        }
        function normalizeItem(x) {
            return {
                text: (x?.text || '').trim(),
                lang_zh: (x?.lang_zh || '').trim() || (x?.text || '').trim(),
                pinned: !!x?.pinned
            };
        }
        // 类别折叠状态（默认展开）
        function getSubcatOpen(cat, subcat) {
            try { return localStorage.getItem('ops_open_' + cat + '::' + subcat) !== '0'; } catch(e) { return true; }
        }
        function setSubcatOpen(cat, subcat, open) {
            try { localStorage.setItem('ops_open_' + cat + '::' + subcat, open ? '1' : '0'); } catch(e) {}
        }

        function saveCommonData() {
            try { localStorage.setItem(STORAGE_KEY, JSON.stringify(commonData)); } catch(e) { console.error('保存失败', e); }
            refreshZhToEnCache();
        }

        function loadCommonTagsFromStorage() {
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                commonData = raw ? JSON.parse(raw) : {};
            } catch (e) {
                commonData = {};
            }
            refreshZhToEnCache();
            renderSidebar();
        }

        function renderSidebar() {
            if (!sidebarList) return;
            sidebarList.innerHTML = '';
            const keys = Object.keys(commonData);
            const active = getActiveCategory();
            keys.forEach((key) => {
                const card = document.createElement('div');
                card.className = 'prompt-card' + (key === active ? ' active' : '');
                card.setAttribute('data-cat', key);
                card.innerHTML = `<h3><i class="fas fa-tag"></i> ${key}</h3>`;
                card.addEventListener('click', () => {
                    document.querySelectorAll('.prompt-card').forEach(c => c.classList.remove('active'));
                    card.classList.add('active');
                    setActiveCategory(key);
                    renderCommonTagsByCategory(key);
                });
                // 启用侧栏分类拖拽
                card.draggable = true;
                card.addEventListener('dragstart', handleCatDragStart);
                card.addEventListener('dragend', handleCatDragEnd);
                // 子元素也监听 dragover/drop，确保在卡片上释放也能触发
                card.addEventListener('dragover', onSidebarDragOver);
                card.addEventListener('drop', onSidebarDrop);
                // 右键菜单支持
                card.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    showCategoryContextMenu(e, key);
                });
                sidebarList.appendChild(card);
            });
            if (keys.length > 0) {
                const current = active && commonData[active] ? active : keys[0];
                setActiveCategory(current);
                renderCommonTagsByCategory(current);
                // 确保侧栏高亮
                document.querySelectorAll('.prompt-card').forEach(c => {
                    if (c.textContent.trim() === current) c.classList.add('active');
                });
            } else {
                const commonTagsContainer = document.getElementById('common-tags');
                if (commonTagsContainer) commonTagsContainer.innerHTML = '';
                setActiveCategory('');
            }
        }

        // 分类顺序调整：上移/下移
        function moveCategory(cat, direction) {
            if (!cat || !commonData) return;
            const keys = Object.keys(commonData);
            const idx = keys.indexOf(cat);
            if (idx === -1) return;
            const target = direction === 'up' ? idx - 1 : idx + 1;
            if (target < 0) { showInfo('已经是第一个了', '提示'); return; }
            if (target >= keys.length) { showInfo('已经是最后一个了', '提示'); return; }
            const newKeys = keys.slice();
            newKeys.splice(idx, 1);
            newKeys.splice(target, 0, cat);
            const reordered = {};
            newKeys.forEach(k => { reordered[k] = commonData[k]; });
            commonData = reordered;
            saveCommonData();
            setActiveCategory(cat);
            renderSidebar();
        }
        function moveCategoryUp(cat) { moveCategory(cat, 'up'); }
        function moveCategoryDown(cat) { moveCategory(cat, 'down'); }

        // 侧栏分类右键菜单
        let currentContextCategory = null;
        const categoryContextMenu = document.createElement('div');
        categoryContextMenu.className = 'context-menu';
        categoryContextMenu.innerHTML = `
            <div class="item" id="ctx-cat-edit"><i class="fas fa-edit"></i> 编辑名称</div>
            <div class="item" id="ctx-cat-delete" style="color:var(--danger-color);"><i class="fas fa-trash"></i> 删除分类</div>
            <div class="item" id="ctx-cat-move-up"><i class="fas fa-arrow-up"></i> 上移</div>
            <div class="item" id="ctx-cat-move-down"><i class="fas fa-arrow-down"></i> 下移</div>
        `;
        document.body.appendChild(categoryContextMenu);

        function showCategoryContextMenu(e, catKey) {
            currentContextCategory = catKey;
            const menu = categoryContextMenu;
            menu.style.display = 'block';
            menu.style.left = e.clientX + 'px';
            menu.style.top = e.clientY + 'px';

            // 绑定菜单项事件
            const editItem = document.getElementById('ctx-cat-edit');
            const deleteItem = document.getElementById('ctx-cat-delete');
            const upItem = document.getElementById('ctx-cat-move-up');
            const downItem = document.getElementById('ctx-cat-move-down');

            editItem.onclick = () => {
                hideCategoryContextMenu();
                openEditCategoryModal(catKey);
            };

            deleteItem.onclick = async () => {
                hideCategoryContextMenu();
                const ok = await showConfirm(`确定要删除分类"${catKey}"吗？分类下的所有标签也将被删除。`, '删除确认');
                if (ok) {
                    delete commonData[catKey];
                    saveCommonData();
                    renderSidebar();
                }
            };

            upItem.onclick = () => {
                hideCategoryContextMenu();
                moveCategoryUp(catKey);
            };

            downItem.onclick = () => {
                hideCategoryContextMenu();
                moveCategoryDown(catKey);
            };
        }

        function hideCategoryContextMenu() {
            categoryContextMenu.style.display = 'none';
            currentContextCategory = null;
        }

        // 点击其他地方关闭右键菜单
        document.addEventListener('click', (e) => {
            if (!categoryContextMenu.contains(e.target)) {
                hideCategoryContextMenu();
            }
        });

        // 编辑分类模态框
        function openEditCategoryModal(oldName) {
            const wrap = document.getElementById('modal-edit-category');
            const input = document.getElementById('modal-edit-cat-name');
            const confirmBtn = document.getElementById('modal-edit-cat-confirm');
            const cancelBtn = document.getElementById('modal-edit-cat-cancel');
            const closeBtn = document.getElementById('modal-edit-cat-close');
            input.value = oldName || '';
            show(wrap);
            setTimeout(() => input.focus(), 0);

            const onConfirm = () => {
                const newName = (input.value || '').trim();
                if (!newName) { input.focus(); return; }
                if (newName !== oldName) {
                    if (commonData[newName]) {
                        showInfo('已存在同名分类', '提示');
                        return;
                    }
                    const items = commonData[oldName] || [];
                    delete commonData[oldName];
                    commonData[newName] = items;
                    saveCommonData();
                    setActiveCategory(newName);
                    renderSidebar();
                }
                cleanup();
            };
            const onCancel = () => cleanup();

            function cleanup() {
                confirmBtn.removeEventListener('click', onConfirm);
                cancelBtn.removeEventListener('click', onCancel);
                closeBtn.removeEventListener('click', onCancel);
                input.removeEventListener('keydown', onKey);
                hide(wrap);
            }
            function onKey(e) {
                if (e.key === 'Enter') onConfirm();
                if (e.key === 'Escape') onCancel();
            }

            confirmBtn.addEventListener('click', onConfirm);
            cancelBtn.addEventListener('click', onCancel);
            closeBtn.addEventListener('click', onCancel);
            input.addEventListener('keydown', onKey);
        }

        // 侧栏分类拖拽排序逻辑
        let catDraggedKey = null;
        let catPlaceholderEl = null;

        function handleCatDragStart(e) {
            const key = this.getAttribute('data-cat') || '';
            catDraggedKey = key || null;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', key);
        }

        function handleCatDragEnd(e) {
            this.classList.remove('dragging');
            document.querySelectorAll('.prompt-card').forEach(card => card.classList.remove('dragging'));
            if (catPlaceholderEl && catPlaceholderEl.parentNode) {
                catPlaceholderEl.parentNode.removeChild(catPlaceholderEl);
            }
            catPlaceholderEl = null;
            catDraggedKey = null;
        }

        function getCatInsertIndexByPoint(y) {
            const items = Array.from(sidebarList.querySelectorAll('.prompt-card'));
            if (!items.length) return 0;
            // 找到垂直位置最近的卡片
            let anchor = items[items.length - 1];
            let minDist = Infinity;
            items.forEach(el => {
                const r = el.getBoundingClientRect();
                const cy = r.top + r.height / 2;
                const d = Math.abs(y - cy);
                if (d < minDist) { minDist = d; anchor = el; }
            });
            const r = anchor.getBoundingClientRect();
            const mid = r.top + r.height / 2;
            const baseIdx = items.indexOf(anchor);
            return y < mid ? baseIdx : baseIdx + 1;
        }

        function onSidebarDragOver(e) {
            if (!catDraggedKey) return false;
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            if (!catPlaceholderEl) {
                catPlaceholderEl = document.createElement('div');
                catPlaceholderEl.style.height = '10px';
                catPlaceholderEl.style.margin = '6px 12px';
                catPlaceholderEl.style.borderRadius = '4px';
                catPlaceholderEl.style.background = 'var(--primary-color)';
            }
            const idx = getCatInsertIndexByPoint(e.clientY);
            const cards = Array.from(sidebarList.querySelectorAll('.prompt-card'));
            if (idx >= cards.length) {
                if (catPlaceholderEl.parentNode !== sidebarList || catPlaceholderEl.nextElementSibling !== null) {
                    sidebarList.appendChild(catPlaceholderEl);
                }
            } else {
                const ref = cards[idx];
                if (ref.previousSibling !== catPlaceholderEl) {
                    sidebarList.insertBefore(catPlaceholderEl, ref);
                }
            }
            return false;
        }

        function onSidebarDrop(e) {
            if (!catDraggedKey) return false;
            e.preventDefault();
            e.stopPropagation();

            const keys = Object.keys(commonData);
            const fromIndex = keys.indexOf(catDraggedKey);

            // 优先使用占位条位置确定目标索引
            let toIndex = -1;
            if (catPlaceholderEl && sidebarList.contains(catPlaceholderEl)) {
                const cards = Array.from(sidebarList.querySelectorAll('.prompt-card'));
                let countBefore = 0;
                for (const node of sidebarList.children) {
                    if (node === catPlaceholderEl) break;
                    if (node.classList && node.classList.contains('prompt-card')) countBefore++;
                }
                toIndex = countBefore;
            } else {
                // 回退：用坐标估算
                toIndex = getCatInsertIndexByPoint(e.clientY);
            }

            if (fromIndex >= 0 && toIndex >= 0 && fromIndex !== toIndex) {
                // 拖起位置在目标之前时，移除后目标索引左移一位
                if (fromIndex < toIndex) toIndex -= 1;
                const newKeys = keys.slice();
                newKeys.splice(fromIndex, 1);
                newKeys.splice(Math.max(0, Math.min(toIndex, newKeys.length)), 0, catDraggedKey);

                const reordered = {};
                newKeys.forEach(k => { reordered[k] = commonData[k]; });
                commonData = reordered;
                saveCommonData();
                renderSidebar();
            }

            if (catPlaceholderEl && catPlaceholderEl.parentNode) {
                catPlaceholderEl.parentNode.removeChild(catPlaceholderEl);
            }
            catPlaceholderEl = null;
            catDraggedKey = null;

            return false;
        }

        function getActiveCategory() {
            try { return localStorage.getItem('ops_active_cat') || ''; } catch(e) { return ''; }
        }
        function setActiveCategory(key) {
            try { localStorage.setItem('ops_active_cat', key || ''); } catch(e) {}
        }

        // 已废弃：不再使用 | 分隔输入
        // function parseTagInput() {}

        function addCategory() {
            openCategoryModal();
        }

        function addTagToCurrent() {
            const cat = getActiveCategory();
            if (!cat) return showInfo('请先创建或选择一个分类', '提示');
            openTagModal(cat);
        }

        function getDropboxToken() {
            try { return localStorage.getItem('ops_dbx_token') || ''; } catch(e) { return ''; }
        }
        // 固定 Dropbox 应用参数
        const DBX_APP_KEY = '5rf7xfl3li2j3tw';
        const DBX_APP_SECRET = 'kjmbl4fcp68gqz9';
        function getDropboxConfig() {
            try {
                return {
                    key: DBX_APP_KEY,
                    secret: DBX_APP_SECRET,
                    token: localStorage.getItem('ops_dbx_token') || '',
                    refresh: localStorage.getItem('ops_dbx_refresh') || ''
                };
            } catch(e) { return { key: DBX_APP_KEY, secret: DBX_APP_SECRET, token:'', refresh:'' }; }
        }
        function getDropboxSelectedFilename() {
            try {
                const v = localStorage.getItem('ops_dbx_filename');
                return v && v.trim() ? v.trim() : '/OHAO AI Prompt Studio.json';
            } catch(e) { return '/OHAO AI Prompt Studio.json'; }
        }
        function isDropboxEnabled() {
            try { return localStorage.getItem('ops_cloud_enabled') === '1'; } catch(e) { return false; }
        }

        // S3 (腾讯云 COS) 配置
        function getS3Config() {
            try {
                return {
                    secretId: localStorage.getItem('ops_s3_secret_id') || '',
                    secretKey: localStorage.getItem('ops_s3_secret_key') || '',
                    region: localStorage.getItem('ops_s3_region') || '',
                    bucket: localStorage.getItem('ops_s3_bucket') || ''
                };
            } catch(e) { return { secretId: '', secretKey: '', region: '', bucket: '' }; }
        }
        function getS3SelectedFilename() {
            try {
                const v = localStorage.getItem('ops_s3_filename');
                return v && v.trim() ? v.trim() : 'OHAO AI Prompt Studio.json';
            } catch(e) { return 'OHAO AI Prompt Studio.json'; }
        }
        function isS3Enabled() {
            try { return localStorage.getItem('ops_cloud_enabled') === '1'; } catch(e) { return false; }
        }
        function isCloudEnabled() {
            try { return localStorage.getItem('ops_cloud_enabled') === '1'; } catch(e) { return false; }
        }

        // 同步配置
        function getSyncProvider() {
            try { return localStorage.getItem('sync_provider') || 'dropbox'; } catch(e) { return 'dropbox'; }
        }
        function setSyncProvider(provider) {
            try { localStorage.setItem('sync_provider', provider || 'dropbox'); } catch(e) {}
        }
        function getCloudSelectedFilename() {
            const provider = getSyncProvider();
            if (provider === 's3') return getS3SelectedFilename();
            return getDropboxSelectedFilename();
        }
        async function uploadToDropbox(filename, contentStr) {
            const { token } = getDropboxConfig();
            if (!token) throw new Error('未配置 Dropbox Access Token');
            const isAscii = (s) => { try { return /^[\x00-\x7F]+$/.test(s); } catch(_) { return true; } };
            const target = filename.startsWith('/') ? filename : '/' + filename;

            // ASCII 文件名：直接上传（请求头可用）
            if (isAscii(target)) {
                const res = await fetch('https://content.dropboxapi.com/2/files/upload', {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Bearer ' + token,
                        'Content-Type': 'application/octet-stream',
                        'Dropbox-API-Arg': JSON.stringify({
                            path: target,
                            mode: 'overwrite',
                            mute: true,
                            autorename: false
                        })
                    },
                    body: new TextEncoder().encode(contentStr)
                });
                if (!res.ok) throw new Error('上传失败 HTTP ' + res.status);
                return res.json();
            }

            // 非 ASCII 文件名：两步法
            const tempPath = '/OHAOAI.upload.tmp.json'; // ASCII 临时文件名
            // 1) 先上传到临时路径
            const upRes = await fetch('https://content.dropboxapi.com/2/files/upload', {
                method: 'POST',
                headers: {
                    'Authorization': 'Bearer ' + token,
                    'Content-Type': 'application/octet-stream',
                    'Dropbox-API-Arg': JSON.stringify({
                        path: tempPath,
                        mode: 'overwrite',
                        mute: true,
                        autorename: false
                    })
                },
                body: new TextEncoder().encode(contentStr)
            });
            if (!upRes.ok) throw new Error('上传临时文件失败 HTTP ' + upRes.status);

            // 2) 若目标已存在，先删除（避免 move 冲突）
            try {
                await fetch('https://api.dropboxapi.com/2/files/delete_v2', {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Bearer ' + token,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ path: target })
                });
            } catch (_) { /* 忽略删除失败 */ }

            // 3) 将临时文件移动到目标路径（JSON 请求体可含非 ASCII）
            const mvRes = await fetch('https://api.dropboxapi.com/2/files/move_v2', {
                method: 'POST',
                headers: {
                    'Authorization': 'Bearer ' + token,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ from_path: tempPath, to_path: target, autorename: false })
            });
            if (!mvRes.ok) {
                let msg = 'HTTP ' + mvRes.status;
                try { const j = await mvRes.json(); msg += ' ' + (j.error_summary || JSON.stringify(j)); } catch(_) {}
                throw new Error('移动到目标文件失败：' + msg);
            }
            return mvRes.json();
        }
        async function downloadFromDropbox(filename) {
            const { token } = getDropboxConfig();
            if (!token) throw new Error('未配置 Dropbox Access Token');
            const isAscii = (s) => { try { return /^[\x00-\x7F]+$/.test(s); } catch(_) { return true; } };
            if (!isAscii(filename)) {
                // 非 ASCII：改用临时链接方式获取文件
                const metaRes = await fetch('https://api.dropboxapi.com/2/files/get_temporary_link', {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Bearer ' + token,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ path: filename.startsWith('/') ? filename : '/' + filename })
                });
                if (!metaRes.ok) {
                    let msg = 'HTTP ' + metaRes.status;
                    try { const j = await metaRes.json(); msg += ' ' + (j.error_summary || JSON.stringify(j)); } catch(_) {}
                    throw new Error('获取临时链接失败：' + msg);
                }
                const j = await metaRes.json();
                const link = j && j.link;
                if (!link) throw new Error('未获取到临时下载链接');
                const fileRes = await fetch(link);
                if (!fileRes.ok) throw new Error('下载失败 HTTP ' + fileRes.status);
                return fileRes.text();
            }
            // ASCII：走标准 content 下载接口
            const res = await fetch('https://content.dropboxapi.com/2/files/download', {
                method: 'POST',
                headers: {
                    'Authorization': 'Bearer ' + token,
                    'Dropbox-API-Arg': JSON.stringify({
                        path: filename.startsWith('/') ? filename : '/' + filename
                    })
                }
            });
            if (!res.ok) throw new Error('下载失败 HTTP ' + res.status);
            return res.text();
        }

        // S3 (腾讯云 COS) 上传函数 - 使用官方 SDK
        async function uploadToS3(filename, contentStr) {
            const { secretId, secretKey, region, bucket } = getS3Config();
            if (!secretId || !secretKey || !region || !bucket) {
                throw new Error('未配置 S3 信息');
            }

            // 初始化 COS 客户端 - 使用永久密钥方式
            const cos = new COS({
                SecretId: secretId,
                SecretKey: secretKey
            });

            // 构造上传路径：Prompt Studio/filename
            const key = `Prompt Studio/${filename}`;

            return new Promise((resolve, reject) => {
                cos.putObject({
                    Bucket: bucket,
                    Region: region,
                    Key: key,
                    Body: contentStr,
                    ContentType: 'application/json'
                }, function (err, data) {
                    if (err) {
                        reject(new Error(`S3 上传失败：${err.message || err}`));
                    } else {
                        resolve(data);
                    }
                });
            });
        }



        // S3 (腾讯云 COS) 下载函数 - 使用官方 SDK
        async function downloadFromS3(filename) {
            const { secretId, secretKey, region, bucket } = getS3Config();
            if (!secretId || !secretKey || !region || !bucket) {
                throw new Error('未配置 S3 信息');
            }

            // 初始化 COS 客户端 - 使用永久密钥方式
            const cos = new COS({
                SecretId: secretId,
                SecretKey: secretKey
            });

            // 构造下载路径：Prompt Studio/filename
            const key = `Prompt Studio/${filename}`;

            return new Promise((resolve, reject) => {
                cos.getObject({
                    Bucket: bucket,
                    Region: region,
                    Key: key
                }, function (err, data) {
                    if (err) {
                        reject(new Error(`S3 下载失败：${err.message || err}`));
                    } else {
                        resolve(data.Body);
                    }
                });
            });
        }

        function downloadJson() {
            // 同时导出"常用提示词"和"提示词历史"
            const exportObj = {
                common: commonData || {},
                history: (function(){ try { const raw = localStorage.getItem('ops_prompt_history'); const arr = raw ? JSON.parse(raw) : []; return Array.isArray(arr) ? arr : []; } catch(e){ return []; } })(),
                menus: (function(){ try { const raw = localStorage.getItem('ops_ctx_menu_items'); const arr = raw ? JSON.parse(raw) : []; return Array.isArray(arr) ? arr : []; } catch(e){ return []; } })()
            };
            const dataStr = JSON.stringify(exportObj, null, 2);
            const useCloud = isCloudEnabled();
            const provider = getSyncProvider();

            if (useCloud) {
                const filename = getCloudSelectedFilename();
                if (provider === 's3') {
                    const s3Config = getS3Config();
                    if (!s3Config.secretId || !s3Config.secretKey || !s3Config.region || !s3Config.bucket) {
                        showInfo('未配置 S3 信息，请在同步配置中填写。', '提示');
                        return;
                    }
                    uploadToS3(filename, dataStr)
                        .then(() => showInfo('已上传到 S3: ' + filename, '上传成功'))
                        .catch(err => showInfo('S3 上传失败：' + (err?.message || err), '上传失败'));
                } else {
                    const { token } = getDropboxConfig();
                    if (!token) { showInfo('未登录 Dropbox，请先在同步配置中完成登录。', '提示'); return; }
                    uploadToDropbox(filename, dataStr)
                        .then(() => showInfo('已上传到 Dropbox: ' + filename, '上传成功'))
                        .catch(err => showInfo('Dropbox 上传失败：' + (err?.message || err), '上传失败'));
                }
                return;
            }
            // 本地下载
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'OHAO AI Prompt Studio.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        async function importJsonText(text) {
            const data = JSON.parse(text);
            if (!data || typeof data !== 'object') throw new Error('无效JSON');

            // 兼容三种结构：
            // 1) 纯旧版：{ 分类: [数组] }
            // 2) 新版封装：{ common: {...}, history: [...] }
            // 3) 分组版：{ 分类: { groups: { 子类: [数组] } } }
            let nextCommon = {};
            let nextHistory = [];
            let nextMenus = Array.isArray(data?.menus) ? data.menus : null;

            function importCategoryValue(val) {
                if (Array.isArray(val)) {
                    return val.map(x => ({
                        text: (x?.text || '').trim(),
                        lang_zh: (x?.lang_zh || '').trim() || (x?.text || '').trim(),
                        pinned: !!x?.pinned
                    })).filter(x => x.text);
                }
                if (isGroupedCategory(val)) {
                    const out = { groups: {} };
                    const g = val.groups || {};
                    Object.keys(g).forEach(sub => {
                        out.groups[sub] = (Array.isArray(g[sub]) ? g[sub] : []).map(x => ({
                            text: (x?.text || '').trim(),
                            lang_zh: (x?.lang_zh || '').trim() || (x?.text || '').trim(),
                            pinned: !!x?.pinned
                        })).filter(x => x.text);
                    });
                    return out;
                }
                return [];
            }

            if (data.common && typeof data.common === 'object') {
                const src = data.common || {};
                Object.keys(src).forEach(k => {
                    nextCommon[k] = importCategoryValue(src[k]);
                });
                if (Array.isArray(data.history)) {
                    nextHistory = data.history
                        .map(x => ({ ts: Number(x?.ts) || Date.now(), text: String(x?.text || '').trim() }))
                        .filter(x => x.text);
                }
            } else {
                Object.keys(data).forEach(k => {
                    nextCommon[k] = importCategoryValue(data[k]);
                });
            }

            commonData = nextCommon;
            saveCommonData();
            if (nextHistory.length) {
                try { localStorage.setItem('ops_prompt_history', JSON.stringify(nextHistory)); } catch(e) {}
            }
            if (Array.isArray(nextMenus)) {
                try { localStorage.setItem('ops_ctx_menu_items', JSON.stringify(nextMenus)); } catch(e) {}
            }
            renderSidebar();
            showInfo('JSON 导入完成' + (nextHistory.length ? '（含历史）' : ''), '导入成功');
        }

        async function importJsonFile(file) {
            try {
                const text = await file.text();
                await importJsonText(text);
                // 提示成功可选
            } catch (e) {
                showInfo('导入失败：' + (e?.message || e), '导入失败');
            }
        }

        async function importFromDropbox() {
            try {
                const filename = getDropboxSelectedFilename();
                const text = await downloadFromDropbox(filename);
                await importJsonText(text);
                showInfo('已从 Dropbox 导入 ' + filename, '导入成功');
            } catch (e) {
                showInfo('从 Dropbox 下载失败：' + (e?.message || e), '下载失败');
            }
        }

        async function importFromS3() {
            try {
                const filename = getS3SelectedFilename();
                const text = await downloadFromS3(filename);
                await importJsonText(text);
                showInfo('已从 S3 导入 ' + filename, '导入成功');
            } catch (e) {
                showInfo('从 S3 下载失败：' + (e?.message || e), '下载失败');
            }
        }

        async function importFromCloud() {
            const provider = getSyncProvider();
            if (provider === 's3') {
                const s3Config = getS3Config();
                if (!s3Config.secretId || !s3Config.secretKey || !s3Config.region || !s3Config.bucket) {
                    showInfo('未配置 S3 信息，请在同步配置中填写。', '提示');
                    return;
                }
                await importFromS3();
            } else {
                const { token } = getDropboxConfig();
                if (!token) {
                    showInfo('未登录 Dropbox，请先在同步配置中完成登录。', '提示');
                    return;
                }
                await importFromDropbox();
            }
        }

        // 首次打开提示：导入默认测试数据（仅提示一次）
        const ONBOARD_KEY = 'ops_onboard_done';
        async function maybePromptDefaultImport() {
            try {
                const done = localStorage.getItem(ONBOARD_KEY) === '1';
                const hasData = commonData && Object.keys(commonData).length > 0;
                if (done || hasData) return;
            } catch (_) {
                // 若 localStorage 不可用，直接跳过
                return;
            }
            try {
                const ok = await showConfirm(
                    `是否导入默认测试数据？`,
                    '导入默认数据'
                );
                // 无论选择与否，都写入一次性标记，下次不再提醒
                try { localStorage.setItem(ONBOARD_KEY, '1'); } catch(_) {}
                if (!ok) return;

                // 从同目录读取默认测试数据
                const res = await fetch('OHAO AI Prompt Studio.json');
                if (!res.ok) throw new Error('HTTP ' + res.status);
                const text = await res.text();
                await importJsonText(text);
            } catch (err) {
                showInfo('导入默认数据失败：' + (err?.message || err), '导入失败');
            }
        }

        // 导出 #prompt-tags-container 为图片并下载
        async function ensureHtml2Canvas() {
            if (window.html2canvas) return window.html2canvas;
            await new Promise((resolve, reject) => {
                const s = document.createElement('script');
                s.src = 'https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js';
                s.onload = () => resolve();
                s.onerror = () => reject(new Error('加载 html2canvas 失败'));
                document.head.appendChild(s);
            });
            return window.html2canvas;
        }
        async function renderPromptTagsToCanvas() {
            const el = document.getElementById('prompt-tags-container');
            if (!el) throw new Error('未找到提示词区域');
            const html2canvas = await ensureHtml2Canvas();
            const prev = {
                background: el.style.background,
                backgroundColor: el.style.backgroundColor,
                border: el.style.border,
                boxShadow: el.style.boxShadow
            };
            el.style.background = 'transparent';
            el.style.backgroundColor = 'transparent';
            el.style.border = 'none';
            el.style.boxShadow = 'none';
            const scale = Math.max(2, (window.devicePixelRatio || 1) * 2);
            try {
                return await html2canvas(el, {
                    backgroundColor: null,
                    scale,
                    useCORS: true
                });
            } finally {
                el.style.background = prev.background;
                el.style.backgroundColor = prev.backgroundColor;
                el.style.border = prev.border;
                el.style.boxShadow = prev.boxShadow;
            }
        }

        async function exportPromptTagsImage() {
            try {
                const canvas = await renderPromptTagsToCanvas();
                const dataUrl = canvas.toDataURL('image/png');
                const a = document.createElement('a');
                a.href = dataUrl;
                a.download = "Prompt Studio.png";
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            } catch (e) {
                showInfo('生成图片失败：' + (e?.message || e), '失败');
            }
        }

        async function composeTagsImageOntoSelectedImage() {
            try {
                const canvas = await renderPromptTagsToCanvas();
                const tagsBlob = await new Promise((resolve) => canvas.toBlob(resolve, 'image/png'));
                if (!tagsBlob) throw new Error('生成提示词图片失败');
                const baseFile = await pickBaseImageFile();
                if (!baseFile) return;
                const composedBlob = await composeImages(baseFile, tagsBlob);
                await offerComposedImageDownload(composedBlob);
            } catch (e) {
                showInfo('合成失败：' + (e?.message || e), '失败');
            }
        }

        async function pickBaseImageFile() {
            return new Promise((resolve) => {
                let input = document.getElementById('compose-image-file-input');
                if (!input) {
                    input = document.createElement('input');
                    input.type = 'file';
                    input.id = 'compose-image-file-input';
                    input.accept = 'image/*';
                    input.style.display = 'none';
                    document.body.appendChild(input);
                }
                const handler = () => {
                    input.removeEventListener('change', handler);
                    const file = input.files && input.files[0];
                    input.value = '';
                    resolve(file || null);
                };
                input.addEventListener('change', handler);
                input.click();
            });
        }

        async function composeImages(baseFile, overlayBlob) {
            const [baseImage, overlayImage] = await Promise.all([
                loadImageFromFile(baseFile),
                loadImageFromBlob(overlayBlob)
            ]);

            const composedCanvas = document.createElement('canvas');
            composedCanvas.width = baseImage.width;
            composedCanvas.height = baseImage.height;
            const ctx = composedCanvas.getContext('2d');
            if (!ctx) throw new Error('无法创建画布');
            ctx.drawImage(baseImage, 0, 0);

            const overlaySize = calculateOverlaySizeAndPosition(baseImage, overlayImage);
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(
                overlayImage,
                overlaySize.x,
                overlaySize.y,
                overlaySize.width,
                overlaySize.height
            );

            return await new Promise((resolve, reject) => {
                composedCanvas.toBlob((blob) => {
                    if (!blob) reject(new Error('导出合成图片失败'));
                    else resolve(blob);
                }, 'image/png');
            });
        }

        function calculateOverlaySizeAndPosition(baseImage, overlayImage) {
            const MIN_OVERLAY_WIDTH = 512;
            const isLandscape = baseImage.width > baseImage.height;
            const maxWidth = baseImage.width;
            const maxHeight = baseImage.height;

            let targetWidth;
            if (isLandscape) {
                const halfWidth = baseImage.width / 2;
                const preferredWidth = Math.min(MIN_OVERLAY_WIDTH, maxWidth);
                targetWidth = Math.max(halfWidth, preferredWidth);
            } else {
                targetWidth = maxWidth;
            }

            let scale = targetWidth / overlayImage.width;
            let targetHeight = overlayImage.height * scale;

            if (targetHeight > maxHeight) {
                const heightScale = maxHeight / targetHeight;
                targetHeight = maxHeight;
                targetWidth = targetWidth * heightScale;
                scale *= heightScale;
            }

            return {
                width: targetWidth,
                height: targetHeight,
                x: 0,
                y: maxHeight - targetHeight
            };
        }

        function loadImageFromFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    if (typeof reader.result !== 'string') {
                        reject(new Error('读取图片失败'));
                        return;
                    }
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = () => reject(new Error('载入图片失败'));
                    img.src = reader.result;
                };
                reader.onerror = () => reject(new Error('读取图片失败'));
                reader.readAsDataURL(file);
            });
        }

        function loadImageFromBlob(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    if (typeof reader.result !== 'string') {
                        reject(new Error('读取图片失败'));
                        return;
                    }
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = () => reject(new Error('载入图片失败'));
                    img.src = reader.result;
                };
                reader.onerror = () => reject(new Error('读取图片失败'));
                reader.readAsDataURL(blob);
            });
        }

        async function offerComposedImageDownload(blob) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'Prompt Studio 合成图.png';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function setupUIEvents() {
            document.getElementById('add-category-btn')?.addEventListener('click', addCategory);
            document.getElementById('add-tag-btn')?.addEventListener('click', addTagToCurrent);
            document.getElementById('export-tags-image-btn')?.addEventListener('click', exportPromptTagsImage);
            document.getElementById('compose-tags-image-btn')?.addEventListener('click', composeTagsImageOntoSelectedImage);
            document.getElementById('download-json-btn')?.addEventListener('click', downloadJson);
            document.getElementById('reset-all-btn')?.addEventListener('click', resetAll);
            document.getElementById('random-pick-btn')?.addEventListener('click', randomPickAll);
            document.getElementById('import-json-btn')?.addEventListener('click', () => {
                const useCloud = isCloudEnabled();
                if (useCloud) {
                    importFromCloud();
                } else {
                    document.getElementById('json-file-input')?.click();
                }
            });
            document.getElementById('sync-config-btn')?.addEventListener('click', openSyncModal);
            document.getElementById('json-file-input')?.addEventListener('change', (e) => {
                const file = e.target.files && e.target.files[0];
                if (file) importJsonFile(file);
                e.target.value = '';
            });

            // 新增：存储与查看
            document.getElementById('save-prompt-btn')?.addEventListener('click', savePromptSnapshot);
            document.getElementById('view-history-btn')?.addEventListener('click', openHistoryModal);
        }

        function openSyncModal() {
            const wrap = document.getElementById('modal-sync');
            const providerBtns = document.querySelectorAll('#sync-provider-buttons .btn-toggle');
            const dropboxConfig = document.getElementById('sync-dropbox-config');
            const s3Config = document.getElementById('sync-s3-config');
            const dropboxFooter = document.getElementById('sync-footer-dropbox');
            const s3Footer = document.getElementById('sync-footer-s3');
            const closeBtn = document.getElementById('modal-sync-close');
            const cloudEnabledEl = document.getElementById('modal-cloud-enabled');

            // Dropbox 元素
            const keyEl = document.getElementById('modal-db-key');
            const secEl = document.getElementById('modal-db-secret');
            const refreshEl = document.getElementById('modal-db-refresh');
            const dbSaveBtn = document.getElementById('modal-db-save');
            const dbCancelBtn = document.getElementById('modal-db-cancel');
            const dbAuthBtn = document.getElementById('modal-db-authorize');
            const dbLoginBtn = document.getElementById('modal-db-login');

            // S3 元素
            const s3SecretIdEl = document.getElementById('modal-s3-secret-id');
            const s3SecretKeyEl = document.getElementById('modal-s3-secret-key');
            const s3RegionEl = document.getElementById('modal-s3-region');
            const s3BucketEl = document.getElementById('modal-s3-bucket');
            const s3SaveBtn = document.getElementById('modal-s3-save');
            const s3CancelBtn = document.getElementById('modal-s3-cancel');

            // 当前选中的服务
            let currentProvider = getSyncProvider();

            function switchProvider(provider) {
                currentProvider = provider;
                setSyncProvider(provider);
                providerBtns.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.provider === provider);
                });
                const fileRowLabel = document.querySelector('#modal-db-file-row-label');
                const fileRowContent = document.querySelector('#modal-db-file-row-content');
                if (provider === 'dropbox') {
                    dropboxConfig.style.display = 'block';
                    s3Config.style.display = 'none';
                    dropboxFooter.classList.remove('hidden');
                    s3Footer.classList.add('hidden');
                    if (fileRowLabel) fileRowLabel.style.display = 'flex';
                    if (fileRowContent) fileRowContent.style.display = 'flex';
                } else {
                    dropboxConfig.style.display = 'none';
                    s3Config.style.display = 'block';
                    dropboxFooter.classList.add('hidden');
                    s3Footer.classList.remove('hidden');
                    if (fileRowLabel) fileRowLabel.style.display = 'none';
                    if (fileRowContent) fileRowContent.style.display = 'none';
                }
            }

            // 初始化全局云端开关
            if (cloudEnabledEl) {
                const enabled = localStorage.getItem('ops_cloud_enabled') === '1';
                cloudEnabledEl.checked = enabled;
            }

            // 初始化 Dropbox 数据
            const dbCfg = getDropboxConfig();
            if (keyEl && keyEl.closest('.modal-row')) keyEl.closest('.modal-row').style.display = 'none';
            if (secEl && secEl.closest('.modal-row')) secEl.closest('.modal-row').style.display = 'none';
            refreshEl.value = dbCfg.refresh || '';

            // 初始化 S3 数据
            const s3Cfg = getS3Config();
            if (s3SecretIdEl) s3SecretIdEl.value = s3Cfg.secretId || '';
            if (s3SecretKeyEl) s3SecretKeyEl.value = s3Cfg.secretKey || '';
            if (s3RegionEl) s3RegionEl.value = s3Cfg.region || '';
            if (s3BucketEl) s3BucketEl.value = s3Cfg.bucket || '';

            // 切换到当前 provider
            switchProvider(currentProvider);

            show(wrap);

            // 动态插入 Dropbox 的"选择JSON文件"与"刷新列表"
            const bodyEl = wrap.querySelector('.modal-body');
            let fileRowLabel = wrap.querySelector('#modal-db-file-row-label');
            let fileRowContent = wrap.querySelector('#modal-db-file-row-content');
            let fileSel = wrap.querySelector('#modal-db-file');
            let fileRefreshBtn = wrap.querySelector('#modal-db-refresh-list');
            if (!fileRowLabel && !fileRowContent && bodyEl) {
                // 标签行
                fileRowLabel = document.createElement('div');
                fileRowLabel.className = 'modal-row';
                fileRowLabel.id = 'modal-db-file-row-label';
                const label = document.createElement('label');
                label.textContent = '选择JSON文件（Dropbox 应用目录）';
                fileRowLabel.appendChild(label);
                bodyEl.appendChild(fileRowLabel);

                // 内容行
                fileRowContent = document.createElement('div');
                fileRowContent.className = 'modal-row';
                fileRowContent.id = 'modal-db-file-row-content';
                const rowInner = document.createElement('div');
                rowInner.style.display = 'flex';
                rowInner.style.gap = '8px';
                rowInner.style.width = '100%';
                fileSel = document.createElement('select');
                fileSel.className = 'modal-input';
                fileSel.id = 'modal-db-file';
                fileSel.style.flex = '1';
                fileRefreshBtn = document.createElement('button');
                fileRefreshBtn.className = 'btn btn-outline';
                fileRefreshBtn.id = 'modal-db-refresh-list';
                fileRefreshBtn.textContent = '刷新';
                rowInner.appendChild(fileSel);
                rowInner.appendChild(fileRefreshBtn);
                fileRowContent.appendChild(rowInner);
                bodyEl.appendChild(fileRowContent);
            }
            // 根据当前 provider 设置文件选择行的显示状态
            if (fileRowLabel) {
                fileRowLabel.style.display = currentProvider === 'dropbox' ? 'flex' : 'none';
            }
            if (fileRowContent) {
                fileRowContent.style.display = currentProvider === 'dropbox' ? 'flex' : 'none';
            }
            // 预填文件选择
            if (fileSel) {
                let preSel = getDropboxSelectedFilename();
                // 清理可能的错误前缀
                if (preSel.includes('/Prompt Studio/')) {
                    const parts = preSel.split('/Prompt Studio/');
                    preSel = parts[parts.length - 1];
                }
                // 移除多余的路径分隔符
                preSel = preSel.replace(/^\/+/, '').replace(/\/+$/, '');
                // 确保有 / 前缀
                preSel = '/' + preSel;
                fileSel.innerHTML = '';
                const opt = document.createElement('option');
                opt.value = preSel;
                opt.textContent = preSel;
                fileSel.appendChild(opt);
                fileSel.value = preSel;
            }

            async function listDropboxJsonFiles(token) {
                const res = await fetch('https://api.dropboxapi.com/2/files/list_folder', {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Bearer ' + token,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ path: '', recursive: false })
                });
                if (!res.ok) {
                    let msg = 'HTTP ' + res.status;
                    try { const j = await res.json(); msg += ' ' + (j.error_summary || JSON.stringify(j)); } catch(_) {}
                    throw new Error(msg);
                }
                const j = await res.json();
                const entries = Array.isArray(j?.entries) ? j.entries : [];
                const files = entries
                    .filter(e => e['.tag'] === 'file' && typeof e.name === 'string' && e.name.toLowerCase().endsWith('.json'))
                    .map(e => '/' + e.name);
                return files;
            }

            async function exchangeAccessTokenWithRefresh(key, secret, refreshToken) {
                const basic = btoa(`${key}:${secret}`);
                const body = new URLSearchParams({
                    grant_type: 'refresh_token',
                    refresh_token: refreshToken
                }).toString();
                const res = await fetch('https://api.dropboxapi.com/oauth2/token', {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Basic ' + basic,
                        'Content-Type': 'application/x-www-form-urlencoded'
                    },
                    body
                });
                if (!res.ok) {
                    let msg = 'HTTP ' + res.status;
                    try { const j = await res.json(); msg += ' ' + (j.error_description || JSON.stringify(j)); } catch(_) {}
                    throw new Error(msg);
                }
                return res.json();
            }

            const onAuthorize = () => {
                const key = getDropboxConfig().key;
                const redirect = encodeURIComponent('https://localhost/');
                // 生成 state 以便后端校验（此处仅传递，不在前端校验）
                const state = Math.random().toString(36).slice(2);
                const url = `https://www.dropbox.com/oauth2/authorize?response_type=code&client_id=${encodeURIComponent(key)}&redirect_uri=${redirect}&token_access_type=offline&state=${encodeURIComponent(state)}`;
                // 以居中小窗打开授权页
                const w = 600, h = 700;
                const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;
                const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;
                const width = window.innerWidth || document.documentElement.clientWidth || screen.width;
                const height = window.innerHeight || document.documentElement.clientHeight || screen.height;
                const left = dualScreenLeft + (width - w) / 2;
                const top = dualScreenTop + (height - h) / 2;
                const features = `scrollbars=yes,resizable=yes,width=${w},height=${h},top=${Math.max(0, top)},left=${Math.max(0, left)}`;
                const win = window.open(url, 'dropbox_auth_popup', features);
                if (!win) {
                    showInfo('弹窗被浏览器拦截，请允许弹窗或改用新标签页方式。', '提示');
                    window.open(url, '_blank', 'noopener,noreferrer');
                    return;
                }
                // 提示用户在弹窗中完成登录与授权
                showInfo('已打开 Dropbox 授权窗口，请在弹窗内登录并同意授权。授权完成后 Dropbox 将回跳至 https://localhost/，请在你的后端用回调换取 Refresh Token，然后回到此处点击"登录"。', '授权提示');
            };

            const onLogin = async () => {
                const key = getDropboxConfig().key;
                const sec = getDropboxConfig().secret;
                let inputVal = refreshEl.value.trim();
                if (!inputVal) { showInfo('请粘贴 Refresh Token 或 回调URL/code', '提示'); refreshEl.focus(); return; }

                // 工具：从可能的完整URL或query片段中提取 code
                function extractCode(str) {
                    try {
                        if (/^https?:\/\//i.test(str)) {
                            const u = new URL(str);
                            return u.searchParams.get('code') || '';
                        }
                        // 若是 query 片段或包含 code= 的字符串
                        const m = str.match(/[?&]code=([^&]+)/);
                        if (m) return decodeURIComponent(m[1]);
                        // 若是纯 code（无特殊字符且长度较短），简单判断
                        if (/^[A-Za-z0-9_-]+$/.test(str) && str.length <= 200) return str;
                    } catch (_) {}
                    return '';
                }

                async function exchangeCodeForTokens(key, secret, code) {
                    const basic = btoa(`${key}:${secret}`);
                    const body = new URLSearchParams({
                        grant_type: 'authorization_code',
                        code,
                        redirect_uri: 'https://localhost/'
                    }).toString();
                    const res = await fetch('https://api.dropboxapi.com/oauth2/token', {
                        method: 'POST',
                        headers: {
                            'Authorization': 'Basic ' + basic,
                            'Content-Type': 'application/x-www-form-urlencoded'
                        },
                        body
                    });
                    if (!res.ok) {
                        let msg = 'HTTP ' + res.status;
                        try { const j = await res.json(); msg += ' ' + (j.error_description || JSON.stringify(j)); } catch(_) {}
                        throw new Error(msg);
                    }
                    return res.json(); // 期望返回 access_token、refresh_token 等
                }

                try {
                    const maybeCode = extractCode(inputVal);
                    let refreshToken = '';
                    let accessToken = '';

                    if (maybeCode) {
                        // 先用授权码兑换 refresh_token 和 access_token
                        const data = await exchangeCodeForTokens(key, sec, maybeCode);
                        refreshToken = data.refresh_token || '';
                        accessToken = data.access_token || '';
                        if (!refreshToken) {
                            throw new Error('未返回 refresh_token，请确认授权时已请求离线权限（token_access_type=offline）且重定向URI完全一致。');
                        }
                    } else {
                        // 直接认为是 refresh_token，走 refresh 换取 access_token
                        refreshToken = inputVal;
                        const data = await exchangeAccessTokenWithRefresh(key, sec, refreshToken);
                        accessToken = data.access_token || '';
                    }

                    if (!accessToken) {
                        // 用 refresh 再换一次 access 保险
                        const data2 = await exchangeAccessTokenWithRefresh(key, sec, refreshToken);
                        accessToken = data2.access_token || '';
                    }
                    if (!accessToken) throw new Error('未获取到 access_token');

                    // 保存
                    try {
                        localStorage.setItem('ops_dbx_key', key);
                        localStorage.setItem('ops_dbx_secret', sec);
                        localStorage.setItem('ops_dbx_refresh', refreshToken);
                        localStorage.setItem('ops_dbx_token', accessToken);
                    } catch(e) {}

                    showInfo('登录成功：已保存 Refresh Token 并获取 Access Token，可立即进行 Dropbox 上传/下载。', '登录成功');
                } catch (err) {
                    showInfo('登录失败：' + (err?.message || err), '登录失败');
                }
            };

            const onDbSave = () => {
                try {
                    // 保存全局云端开关
                    if (cloudEnabledEl) {
                        localStorage.setItem('ops_cloud_enabled', cloudEnabledEl.checked ? '1' : '0');
                    }
                    localStorage.setItem('ops_dbx_refresh', refreshEl.value.trim());
                    const sel = wrap.querySelector('#modal-db-file');
                    let v = sel && (sel.value || '').trim();
                    // 清理路径，只保留纯文件名
                    if (v) {
                        // 移除 Prompt Studio/ 前缀
                        if (v.includes('/Prompt Studio/')) {
                            const parts = v.split('/Prompt Studio/');
                            v = parts[parts.length - 1];
                        }
                        // 移除多余的路径分隔符
                        v = v.replace(/^\/+/, '').replace(/\/+$/, '');
                        // 确保有 / 前缀
                        v = '/' + v;
                        localStorage.setItem('ops_dbx_filename', v);
                    }
                } catch(e) {}
                cleanup();
            };

            const onS3Save = () => {
                try {
                    // 保存全局云端开关
                    if (cloudEnabledEl) {
                        localStorage.setItem('ops_cloud_enabled', cloudEnabledEl.checked ? '1' : '0');
                    }
                    localStorage.setItem('ops_s3_secret_id', (s3SecretIdEl.value || '').trim());
                    localStorage.setItem('ops_s3_secret_key', (s3SecretKeyEl.value || '').trim());
                    localStorage.setItem('ops_s3_region', (s3RegionEl.value || '').trim());
                    localStorage.setItem('ops_s3_bucket', (s3BucketEl.value || '').trim());
                    localStorage.setItem('ops_s3_filename', 'OHAO AI Prompt Studio.json');
                } catch(e) {}
                cleanup();
            };

            const onCancel = () => cleanup();

            function cleanup() {
                closeBtn.removeEventListener('click', onCancel);
                dbCancelBtn.removeEventListener('click', onCancel);
                s3CancelBtn.removeEventListener('click', onCancel);
                dbSaveBtn.removeEventListener('click', onDbSave);
                s3SaveBtn.removeEventListener('click', onS3Save);
                dbAuthBtn.removeEventListener('click', onAuthorize);
                dbLoginBtn.removeEventListener('click', onLogin);
                providerBtns.forEach(btn => btn.removeEventListener('click', onProviderClick));
                hide(wrap);
            }

            const onProviderClick = (e) => {
                const provider = e.target.dataset.provider;
                if (provider) switchProvider(provider);
            };

            closeBtn.addEventListener('click', onCancel);
            dbCancelBtn.addEventListener('click', onCancel);
            s3CancelBtn.addEventListener('click', onCancel);
            dbSaveBtn.addEventListener('click', onDbSave);
            s3SaveBtn.addEventListener('click', onS3Save);
            dbAuthBtn.addEventListener('click', onAuthorize);
            dbLoginBtn.addEventListener('click', onLogin);
            providerBtns.forEach(btn => btn.addEventListener('click', onProviderClick));

            // 刷新文件列表按钮
            const fileRefreshBtn2 = wrap.querySelector('#modal-db-refresh-list');
            const fileSel2 = wrap.querySelector('#modal-db-file');
            if (fileRefreshBtn2) {
                fileRefreshBtn2.onclick = async () => {
                    try {
                        const { token } = getDropboxConfig();
                        if (!token) { showInfo('请先登录 Dropbox', '提示'); return; }
                        const files = await listDropboxJsonFiles(token);
                        const def = getDropboxSelectedFilename();
                        if (fileSel2) {
                            fileSel2.innerHTML = '';
                            const list = files.length ? files : [def];
                            list.forEach(name => {
                                const opt = document.createElement('option');
                                opt.value = name;
                                opt.textContent = name;
                                fileSel2.appendChild(opt);
                            });
                            fileSel2.value = def;
                        }
                    } catch (err) {
                        showInfo('获取文件列表失败：' + (err?.message || err), '失败');
                    }
                };
            }
        }

        function renderCommonTagsByCategory(catKey) {
            if (!commonTagsContainer) return;
            commonTagsContainer.innerHTML = '';

            const data = commonData?.[catKey];

            // 旧版结构：数组 => 维持原样平铺
            if (Array.isArray(data)) {
                // 为容器添加数据属性，用于拖拽
                commonTagsContainer.dataset.cat = catKey;
                commonTagsContainer.dataset.subcat = '';

                data.forEach((item, index) => {
                    const label = item?.lang_zh || item?.text || '';
                    const value = item?.text || '';
                    if (!label || !value) return;
                    const span = document.createElement('span');
                    span.className = 'common-tag' + ((item && item.pinned) ? ' pinned' : '');
                    span.dataset.cat = catKey;
                    span.dataset.index = String(index);
                    span.dataset.subcat = '';
                    span.draggable = true;
                    span.textContent = label;
                    span.title = value;
                    span.addEventListener('click', () => {
                        const cur = promptEditor.value.trim();
                        const suffix = value.trim();
                        promptEditor.value = cur ? (cur + ', ' + suffix) : suffix;
                        normalizePromptInput();
                        updateTags();
                        promptEditor.focus();
                    });
                    // 添加拖拽事件
                    span.addEventListener('dragstart', handleCommonTagDragStart);
                    span.addEventListener('dragover', handleCommonTagDragOver);
                    span.addEventListener('drop', handleCommonTagDrop);
                    span.addEventListener('dragend', handleCommonTagDragEnd);
                    commonTagsContainer.appendChild(span);
                });
                // 为容器添加 dragover 事件
                commonTagsContainer.addEventListener('dragover', onCommonContainerDragOver);
                return;
            }

            // 分组结构：{ groups: { 类别: [items] } }
            if (isGroupedCategory(data)) {
                const groups = data.groups || {};
                const order = Array.isArray(data.groupsOrder)
                    ? data.groupsOrder.filter(n => Object.prototype.hasOwnProperty.call(groups, n))
                        .concat(Object.keys(groups).filter(n => !data.groupsOrder.includes(n)))
                    : Object.keys(groups);
                order.forEach(sub => {
                    const section = document.createElement('div');
                    section.style.border = '1px solid var(--border-color)';
                    section.style.borderRadius = '8px';
                    section.style.marginBottom = '8px';
                    section.style.overflow = 'hidden';
                    section.style.width = '100%';

                    const header = document.createElement('div');
                    header.style.padding = '8px 10px';
                    header.style.background = 'var(--bg-color)';
                    header.style.display = 'flex';
                    header.style.alignItems = 'center';
                    header.style.justifyContent = 'space-between';
                    header.style.width = '100%';

                    const left = document.createElement('div');
                    left.style.display = 'flex';
                    left.style.alignItems = 'center';
                    left.style.gap = '8px';

                    const title = document.createElement('span');
                    title.textContent = sub;

                    const right = document.createElement('div');
                    right.style.display = 'flex';
                    right.style.gap = '8px';

                    const toggle = document.createElement('button');
                    toggle.className = 'btn btn-outline';
                    toggle.textContent = '折叠/展开';

                    const btnNew = document.createElement('button');
                    btnNew.className = 'btn btn-outline';
                    btnNew.textContent = '新建';

                    const btnRename = document.createElement('button');
                    btnRename.className = 'btn btn-outline';
                    btnRename.textContent = '修改名称';

                    const btnDelete = document.createElement('button');
                    btnDelete.className = 'btn btn-outline';
                    btnDelete.textContent = '删除';

                    const btnUp = document.createElement('button');
                    btnUp.className = 'btn btn-outline';
                    btnUp.textContent = '上移';

                    const btnDown = document.createElement('button');
                    btnDown.className = 'btn btn-outline';
                    btnDown.textContent = '下移';

                    const body = document.createElement('div');
                    body.style.display = getSubcatOpen(catKey, sub) ? 'flex' : 'none';
                    body.style.flexWrap = 'wrap';
                    body.style.gap = '8px';
                    body.style.padding = '10px';
                    body.style.width = '100%';
                    body.dataset.containerType = 'common-tag-group';
                    body.dataset.cat = catKey;
                    body.dataset.subcat = sub;

                    const arr = Array.isArray(groups[sub]) ? groups[sub] : [];
                    arr.forEach((item, index) => {
                        const label = item?.lang_zh || item?.text || '';
                        const value = item?.text || '';
                        if (!label || !value) return;
                        const span = document.createElement('span');
                        span.className = 'common-tag' + ((item && item.pinned) ? ' pinned' : '');
                        span.dataset.cat = catKey;
                        span.dataset.subcat = sub;
                        span.dataset.index = String(index);
                        span.draggable = true;
                        span.textContent = label;
                        span.title = value;
                        span.addEventListener('click', () => {
                            const cur = promptEditor.value.trim();
                            const suffix = value.trim();
                            promptEditor.value = cur ? (cur + ', ' + suffix) : suffix;
                            normalizePromptInput();
                            updateTags();
                            promptEditor.focus();
                        });
                        // 添加拖拽事件
                        span.addEventListener('dragstart', handleCommonTagDragStart);
                        span.addEventListener('dragover', handleCommonTagDragOver);
                        span.addEventListener('drop', handleCommonTagDrop);
                        span.addEventListener('dragend', handleCommonTagDragEnd);
                        body.appendChild(span);
                    });
                    // 为容器添加 dragover 和 drop 事件（支持在空白区域拖拽）
                    body.addEventListener('dragover', onCommonContainerDragOver);
                    body.addEventListener('drop', handleCommonTagDrop);

                    toggle.addEventListener('click', () => {
                        const next = body.style.display === 'none';
                        body.style.display = next ? 'flex' : 'none';
                        setSubcatOpen(catKey, sub, next);
                    });

                    btnNew.addEventListener('click', async () => {
                        const name = await showInputModal('新建类别', '输入名称', '');
                        const val = (name || '').trim();
                        if (!val) return;
                        ensureGrouped(catKey);
                        const catObj = commonData[catKey];
                        const g = catObj.groups || (catObj.groups = {});
                        if (!g[val]) g[val] = [];
                        if (!Array.isArray(catObj.groupsOrder)) catObj.groupsOrder = Object.keys(g);
                        if (!catObj.groupsOrder.includes(val)) catObj.groupsOrder.push(val);
                        saveCommonData();
                        renderCommonTagsByCategory(catKey);
                    });

                    btnRename.addEventListener('click', async () => {
                        const name = await showInputModal('修改类别名称', '输入新名称', sub);
                        const val = (name || '').trim();
                        if (!val || val === sub) return;
                        ensureGrouped(catKey);
                        const catObj = commonData[catKey];
                        const g = catObj.groups || {};
                        if (g[val]) { showInfo('已存在同名类别', '提示'); return; }
                        g[val] = g[sub] || [];
                        delete g[sub];
                        // 同步顺序
                        if (!Array.isArray(catObj.groupsOrder)) catObj.groupsOrder = Object.keys(g);
                        const pos = catObj.groupsOrder.indexOf(sub);
                        if (pos >= 0) catObj.groupsOrder.splice(pos, 1, val);
                        saveCommonData();
                        renderCommonTagsByCategory(catKey);
                    });

                    btnDelete.addEventListener('click', async () => {
                        const ok = await showConfirm(`确认删除类别「${sub}」？${sub==='未分组' ? '（将删除其中所有条目）' : '（其中条目将移动到"未分组"）'}`, '删除类别');
                        if (!ok) return;
                        ensureGrouped(catKey);
                        const catObj = commonData[catKey];
                        const g = catObj.groups || {};
                        if (sub === '未分组') {
                            // 删除未分组：直接删除整个未分组及其内容
                            delete g['未分组'];
                            if (Array.isArray(catObj.groupsOrder)) {
                                const i = catObj.groupsOrder.indexOf('未分组');
                                if (i >= 0) catObj.groupsOrder.splice(i, 1);
                            }
                        } else {
                            const arrOld = g[sub] || [];
                            if (arrOld.length === 0) {
                                // 空类别：直接删除，不迁移到"未分组"，不创建"未分组"
                                delete g[sub];
                                if (!Array.isArray(catObj.groupsOrder)) catObj.groupsOrder = Object.keys(g);
                                const i = catObj.groupsOrder.indexOf(sub);
                                if (i >= 0) catObj.groupsOrder.splice(i, 1);
                            } else {
                                // 非空类别：将条目迁移到"未分组"，再删除分组
                                const uf = g['未分组'] || (g['未分组'] = []);
                                arrOld.forEach(it => uf.push(it));
                                delete g[sub];
                                if (!Array.isArray(catObj.groupsOrder)) catObj.groupsOrder = Object.keys(g);
                                // 确保"未分组"在顺序中存在
                                if (!catObj.groupsOrder.includes('未分组') && g['未分组']) {
                                    catObj.groupsOrder.unshift('未分组');
                                }
                                const i = catObj.groupsOrder.indexOf(sub);
                                if (i >= 0) catObj.groupsOrder.splice(i, 1);
                            }
                        }
                        saveCommonData();
                        renderCommonTagsByCategory(catKey);
                    });

                    left.appendChild(title);
                    right.appendChild(toggle);

                    right.appendChild(btnRename);
                    right.appendChild(btnDelete);
                    right.appendChild(btnUp);
                    right.appendChild(btnDown);
                    header.appendChild(left);
                    header.appendChild(right);
                    section.appendChild(header);
                    section.appendChild(body);

                    // 为 body 容器添加拖拽事件
                    body.addEventListener('dragover', onCommonContainerDragOver);

                    // 移动类别顺序
                    btnUp.addEventListener('click', () => moveSubcat(catKey, sub, 'up'));
                    btnDown.addEventListener('click', () => moveSubcat(catKey, sub, 'down'));

                    commonTagsContainer.appendChild(section);
                });
            }
        }
        
        // 依据英文提示词查找中文描述（从 commonData 中查，支持分组）
        function findZh(enText) {
            if (!enText) return '';
            try {
                const keys = Object.keys(commonData || {});
                for (const k of keys) {
                    const v = commonData[k];
                    if (Array.isArray(v)) {
                        for (const it of v) {
                            if ((it?.text || '').trim().toLowerCase() === enText.trim().toLowerCase()) {
                                return (it?.lang_zh || '').trim();
                            }
                        }
                    } else if (isGroupedCategory(v)) {
                        const groups = v.groups || {};
                        for (const g of Object.keys(groups)) {
                            const arr = groups[g] || [];
                            for (const it of arr) {
                                if ((it?.text || '').trim().toLowerCase() === enText.trim().toLowerCase()) {
                                    return (it?.lang_zh || '').trim();
                                }
                            }
                        }
                    }
                }
            } catch(_) {}
            return '';
        }

        function normalizePromptInput(options = {}) {
            if (!promptEditor) return;
            const raw = promptEditor.value;
            if (!raw) return;
            const segments = raw.split(/[,，]/);
            const normalized = [];
            let changed = false;
            segments.forEach(segment => {
                const trimmed = segment.trim();
                if (!trimmed) return;
                const parsed = parseWeightedTag(trimmed);
                const en = findEn(parsed.base);
                if (en) {
                    const formatted = formatWeightedTag(en, parsed.weight);
                    normalized.push(formatted);
                    if (formatted !== trimmed) changed = true;
                } else {
                    const formatted = formatWeightedTag(parsed.base, parsed.weight);
                    normalized.push(formatted);
                    if (formatted !== trimmed) changed = true;
                }
            });
            if (!changed) return;
            const nextValue = normalized.join(', ');
            promptEditor.value = nextValue;
            if (options.restoreCaret) {
                try {
                    const pos = nextValue.length;
                    promptEditor.setSelectionRange(pos, pos);
                } catch (_) {}
            }
        }

        // 令牌数量统计（按逗号/中文逗号分割，忽略空项与尾部多余逗号）
        function updateTokenCounter() {
            try {
                const val = (promptEditor.value || '').trim();
                // 分割并过滤空白
                const parts = val.split(/[,，]/).map(s => s.trim()).filter(Boolean);
                const count = parts.length;
                const el = document.getElementById('token-counter');
                if (el) el.textContent = 'Tokens: ' + count + '/75';
            } catch (_) {}
        }

        // 维护：被置灰的标签集合与上一次渲染的标签顺序
        window.__disabledTagSet = window.__disabledTagSet || new Set();
        window.__lastRenderList = window.__lastRenderList || [];

        // 初始化标签（支持点击置灰/恢复，保持原位置不变）
        function updateTags() {
            normalizePromptInput();
            const text = promptEditor.value;
            const active = text.split(/[,，]/)
                .map(s => s.trim())
                .filter(Boolean);

            const normalizedActive = active.map(tag => {
                const parsed = parseWeightedTag(tag);
                const key = parsed.base.toLowerCase();
                const storedWeight = weightStateMap.get(key);
                if (Number.isFinite(storedWeight)) {
                    parsed.weight = storedWeight;
                }
                const normalizedTag = formatWeightedTag(parsed.base, parsed.weight);
                weightStateMap.set(key, parsed.weight);
                return normalizedTag;
            });

            const normalizedUniqueSet = new Set(normalizedActive);

            // 若首次渲染，用输入框的顺序初始化
            if (!Array.isArray(window.__lastRenderList) || window.__lastRenderList.length === 0) {
                window.__lastRenderList = normalizedActive.slice();
            } else {
                // 1) 从顺序表移除已不存在且未被置灰的项
                window.__lastRenderList = window.__lastRenderList.filter(t => normalizedUniqueSet.has(t) || window.__disabledTagSet.has(t));
                // 2) 将新出现（用户手动输入）的激活项追加到末尾
                normalizedActive.forEach(t => {
                    if (!window.__lastRenderList.includes(t)) window.__lastRenderList.push(t);
                });
            }

            // 渲染列表严格按照顺序表，但仅展示：激活项或置灰项
            const renderList = window.__lastRenderList.slice();

            tagsContainer.innerHTML = '';

            renderList.forEach((tag, index) => {
                let parsedTag = parseWeightedTag(tag);
                const baseText = parsedTag.base;
                const baseKey = baseText.toLowerCase();
                const storedWeight = weightStateMap.get(baseKey);
                if (Number.isFinite(storedWeight)) {
                    parsedTag = { ...parsedTag, weight: storedWeight };
                }
                let currentWeight = parsedTag.weight;
                let currentTag = formatWeightedTag(baseText, currentWeight);

                if (currentTag !== tag) {
                    const listIndex = window.__lastRenderList.indexOf(tag);
                    if (listIndex >= 0) {
                        window.__lastRenderList[listIndex] = currentTag;
                    }
                    tag = currentTag;
                }

                weightStateMap.set(baseKey, currentWeight);

                const zh = findZh(baseText) || '';
                const isInactive = window.__disabledTagSet.has(tag);
                const tagElement = document.createElement('div');
                tagElement.className = 'prompt-tag' + (isInactive ? ' inactive' : '');
                tagElement.draggable = true;
                tagElement.setAttribute('data-index', index);
                tagElement.setAttribute('data-base', baseText);
                tagElement.setAttribute('data-weight', String(currentWeight));

                const deleteBtn = document.createElement('span');
                deleteBtn.className = 'delete-tag';
                deleteBtn.setAttribute('data-role', 'del');
                deleteBtn.textContent = '×';

                const enSegment = document.createElement('span');
                enSegment.className = 'seg-en';
                enSegment.textContent = currentTag;

                const zhSegment = zh ? (() => {
                    const span = document.createElement('span');
                    span.className = 'seg-zh';
                    span.textContent = zh;
                    return span;
                })() : null;

                const weightPanel = document.createElement('div');
                weightPanel.className = 'weight-adjust';
                weightPanel.setAttribute('data-role', 'weight-panel');
                const btnDecrease = document.createElement('button');
                btnDecrease.className = 'weight-btn';
                btnDecrease.setAttribute('data-role', 'decrease');
                btnDecrease.title = '权重-';
                btnDecrease.textContent = '−';
                const weightLabelEl = document.createElement('span');
                weightLabelEl.className = 'weight-value';
                weightLabelEl.setAttribute('data-role', 'weight-label');
                weightLabelEl.textContent = (Math.round(currentWeight * 100) / 100).toFixed(2);
                const btnIncrease = document.createElement('button');
                btnIncrease.className = 'weight-btn';
                btnIncrease.setAttribute('data-role', 'increase');
                btnIncrease.title = '权重+';
                btnIncrease.textContent = '+';

                weightPanel.appendChild(btnDecrease);
                weightPanel.appendChild(weightLabelEl);
                weightPanel.appendChild(btnIncrease);

                tagElement.appendChild(deleteBtn);
                tagElement.appendChild(enSegment);
                if (zhSegment) tagElement.appendChild(zhSegment);
                tagElement.appendChild(weightPanel);

                const updateWeightView = () => {
                    weightLabelEl.textContent = (Math.round(currentWeight * 100) / 100).toFixed(2);
                    enSegment.textContent = currentTag;
                    tagElement.setAttribute('data-weight', String(currentWeight));
                };

                const applyWeightVisibility = () => {
                    const enabled = window.__weightControlsEnabled;
                    tagElement.classList.toggle('weight-disabled', !enabled);
                    weightPanel.style.display = enabled ? 'inline-flex' : 'none';
                };
                applyWeightVisibility();

                tagElement.addEventListener('click', (e) => {
                    if (e.target && (e.target.closest('[data-role="del"]') || e.target.closest('[data-role="weight-panel"]'))) return;
                    const wasInactive = window.__disabledTagSet.has(currentTag);
                    if (wasInactive) {
                        window.__disabledTagSet.delete(currentTag);
                        const orderedActive = (window.__lastRenderList || []).filter(t => !window.__disabledTagSet.has(t));
                        promptEditor.value = orderedActive.join(', ');
                        normalizePromptInput();
                    } else {
                        window.__disabledTagSet.add(currentTag);
                        const parts = (promptEditor.value || '').split(/[,，]/)
                            .map(s => formatWeightedTag(parseWeightedTag(s).base, parseWeightedTag(s).weight))
                            .filter(Boolean);
                        const pos = parts.indexOf(currentTag);
                        if (pos >= 0) {
                            parts.splice(pos, 1);
                        }
                        promptEditor.value = parts.join(', ');
                        normalizePromptInput();
                    }
                    updateTags();
                });

                const applyWeightChange = (deltaSteps) => {
                    const previousTag = currentTag;
                    const nextWeight = computeNextWeight(currentWeight, deltaSteps);
                    if (nextWeight === currentWeight) return;

                    currentWeight = nextWeight;
                    currentTag = formatWeightedTag(baseText, currentWeight);
                    weightStateMap.set(baseKey, currentWeight);
                    updateWeightView();

                    if (Array.isArray(window.__lastRenderList)) {
                        const idx = window.__lastRenderList.indexOf(previousTag);
                        if (idx >= 0) {
                            window.__lastRenderList.splice(idx, 1, currentTag);
                        }
                    }

                    if (window.__disabledTagSet.has(previousTag)) {
                        window.__disabledTagSet.delete(previousTag);
                        window.__disabledTagSet.add(currentTag);
                    }

                    let parts = (promptEditor.value || '').split(/[,，]/)
                        .map(s => formatWeightedTag(parseWeightedTag(s).base, parseWeightedTag(s).weight))
                        .filter(Boolean);
                    const textIdx = parts.indexOf(previousTag);
                    if (textIdx >= 0) {
                        parts[textIdx] = currentTag;
                        promptEditor.value = parts.join(', ');
                    }

                    normalizePromptInput();
                    updateTokenCounter();
                };

                btnDecrease.addEventListener('click', (e) => {
                    e.stopPropagation();
                    applyWeightChange(-1);
                });
                btnIncrease.addEventListener('click', (e) => {
                    e.stopPropagation();
                    applyWeightChange(1);
                });

                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    removeWeightedTag(currentTag);
                });

                tagElement.addEventListener('dragstart', handleDragStart);
                tagElement.addEventListener('dragover', handleDragOver);
                tagElement.addEventListener('drop', handleDrop);
                tagElement.addEventListener('dragend', handleDragEnd);

                tagsContainer.appendChild(tagElement);
            });

            // 同步更新计数（按输入框里激活的项）
            updateTokenCounter();
        }
        
        // 拖拽功能
        let draggedItem = null;
        let placeholderEl = null;
        
        function handleDragStart(e) {
            draggedItem = this;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.innerHTML);
        }
        
        function handleDragOver(e) {
            // 统一交给容器级处理，确保空白区域也可放置
            return onContainerDragOver(e);
        }
        
        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();

            // 当前渲染顺序（包含置灰项），以它为准进行重排
            const list = Array.isArray(window.__lastRenderList) ? window.__lastRenderList.slice() : [];
            if (!draggedItem || !list.length) { updateTags(); return false; }

            const fromIndex = parseInt(draggedItem.getAttribute('data-index'), 10);

            // 计算目标索引：占位条（placeholderEl）之前的 .prompt-tag 数量
            let toIndex = fromIndex;
            const children = Array.from(tagsContainer.children);
            if (placeholderEl && tagsContainer.contains(placeholderEl)) {
                let countBefore = 0;
                let hit = false;
                for (const el of children) {
                    if (el === placeholderEl) { hit = true; break; }
                    if (el.classList && el.classList.contains('prompt-tag')) countBefore++;
                }
                toIndex = hit ? countBefore : countBefore; // 若占位在末尾，countBefore 即为末尾索引
            } else {
                // 兜底：以当前目标元素位置估算
                let countBefore = 0;
                for (const el of children) {
                    if (el === this) break;
                    if (el.classList && el.classList.contains('prompt-tag')) countBefore++;
                }
                toIndex = countBefore;
            }

            if (!Number.isNaN(fromIndex) && !Number.isNaN(toIndex) && fromIndex !== toIndex) {
                const [moved] = list.splice(fromIndex, 1);
                // 防御：约束范围
                const safeTo = Math.max(0, Math.min(toIndex, list.length));
                list.splice(safeTo, 0, moved);
                window.__lastRenderList = list;

                // 仅用"激活项"（排除置灰项）写回文本
                const disabledSet = window.__disabledTagSet || new Set();
                const orderedActive = list.filter(t => !disabledSet.has(t));
                promptEditor.value = orderedActive.join(', ');
                normalizePromptInput();
            }

            updateTags();
            return false;
        }
        
        function handleDragEnd(e) {
            this.classList.remove('dragging');
            document.querySelectorAll('.prompt-tag').forEach(tag => {
                tag.classList.remove('dragging');
            });
            // 清理占位条
            if (placeholderEl && placeholderEl.parentNode) {
                placeholderEl.parentNode.removeChild(placeholderEl);
            }
            placeholderEl = null;
        }

        // 容器级拖拽：允许在空白区域放置，并精确计算插入索引（支持多行）
        function getInsertIndexByPoint(x, y) {
            const items = Array.from(tagsContainer.querySelectorAll('.prompt-tag'));
            if (!items.length) return 0;
            const TOL = 8; // 行判定的垂直容差

            // 1) 先尝试找到与鼠标 Y 同行（含容差）的所有元素
            const sameRow = items.filter(el => {
                const r = el.getBoundingClientRect();
                return y >= r.top - TOL && y <= r.bottom + TOL;
            });

            if (sameRow.length) {
                // 在该行内按 X 决定插入到哪个元素之前
                for (let i = 0; i < sameRow.length; i++) {
                    const r = sameRow[i].getBoundingClientRect();
                    const mid = r.left + r.width / 2;
                    if (x < mid) return items.indexOf(sameRow[i]);
                }
                // 若都在所有元素中点右侧，插入到同行最后一个之后
                return items.indexOf(sameRow[sameRow.length - 1]) + 1;
            }

            // 2) 若没有同行元素，选择垂直距离最近的一行中的一个锚点元素
            let anchor = items[items.length - 1];
            let minDist = Infinity;
            items.forEach(el => {
                const r = el.getBoundingClientRect();
                const cy = r.top + r.height / 2;
                const d = Math.abs(y - cy);
                if (d < minDist) { minDist = d; anchor = el; }
            });
            const r = anchor.getBoundingClientRect();
            const mid = r.left + r.width / 2;
            const baseIdx = items.indexOf(anchor);
            return x < mid ? baseIdx : baseIdx + 1;
        }

        function onContainerDragOver(e) {
            if (!draggedItem) return false;
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            if (!placeholderEl) {
                placeholderEl = document.createElement('div');
                placeholderEl.className = 'tag-placeholder';
            }
            const idx = getInsertIndexByPoint(e.clientX, e.clientY);
            const items = Array.from(tagsContainer.querySelectorAll('.prompt-tag'));
            if (idx >= items.length) {
                if (placeholderEl.parentNode !== tagsContainer || placeholderEl.nextElementSibling !== null) {
                    tagsContainer.appendChild(placeholderEl);
                }
            } else {
                const ref = items[idx];
                if (ref.previousSibling !== placeholderEl) {
                    tagsContainer.insertBefore(placeholderEl, ref);
                }
            }
            return false;
        }

        function onContainerDrop(e) {
            if (!draggedItem) return false;
            e.preventDefault();
            e.stopPropagation();

            const list = Array.isArray(window.__lastRenderList) ? window.__lastRenderList.slice() : [];
            if (!list.length) { updateTags(); return false; }

            const fromIndex = parseInt(draggedItem.getAttribute('data-index'), 10);
            let toIndex = getInsertIndexByPoint(e.clientX, e.clientY);

            if (!Number.isNaN(fromIndex) && !Number.isNaN(toIndex) && fromIndex !== toIndex) {
                const [moved] = list.splice(fromIndex, 1);
                // 拖起位置在目标之前时，移除后目标索引左移一位
                if (fromIndex < toIndex) toIndex -= 1;
                const safeTo = Math.max(0, Math.min(toIndex, list.length));
                list.splice(safeTo, 0, moved);
                window.__lastRenderList = list;

                const disabledSet = window.__disabledTagSet || new Set();
                const orderedActive = list.filter(t => !disabledSet.has(t));
                promptEditor.value = orderedActive.join(', ');
                normalizePromptInput();
            }

            // 清理占位条
            if (placeholderEl && placeholderEl.parentNode) {
                placeholderEl.parentNode.removeChild(placeholderEl);
            }
            placeholderEl = null;

            updateTags();
            return false;
        }

        // 绑定容器级事件（确保空白区域可放置）
        if (tagsContainer) {
            tagsContainer.addEventListener('dragover', onContainerDragOver);
            tagsContainer.addEventListener('drop', onContainerDrop);
        }

        // ========== common-tags 拖拽排序功能 ==========
        let draggedCommonTag = null;
        let commonPlaceholderEl = null;
        let commonDragSourceContainer = null;

        function handleCommonTagDragStart(e) {
            draggedCommonTag = this;
            this.classList.add('dragging');
            commonDragSourceContainer = this.closest('[data-container-type]') || this.parentElement;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.innerHTML);
        }

        function handleCommonTagDragOver(e) {
            return onCommonContainerDragOver(e);
        }

        function handleCommonTagDrop(e) {
            e.preventDefault();
            e.stopPropagation();

            if (!draggedCommonTag) return false;

            const targetContainer = e.target.closest('[data-container-type]') || e.target.closest('.common-tags') || e.target.parentElement;

            if (!targetContainer) return false;

            const cat = draggedCommonTag.dataset.cat;
            const fromSubcat = draggedCommonTag.dataset.subcat || '';
            const fromIndex = parseInt(draggedCommonTag.dataset.index, 10);

            const toSubcat = targetContainer.dataset.subcat || '';

            // 直接根据鼠标位置计算目标索引（与 prompt-tags 完全一致）
            let toIndex = getCommonInsertIndexByPoint(e.clientX, e.clientY, targetContainer);

            if (!Number.isNaN(fromIndex) && !Number.isNaN(toIndex)) {
                if (cat && (fromSubcat !== toSubcat || targetContainer !== commonDragSourceContainer)) {
                    // 跨容器移动
                    moveCommonTagTo(cat, fromSubcat, fromIndex, toSubcat, toIndex);
                } else if (fromIndex !== toIndex) {
                    // 同容器内排序
                    reorderCommonTags(targetContainer, fromIndex, toIndex);
                }
            }

            cleanupCommonDrag();
            return false;
        }

        function handleCommonTagDragEnd(e) {
            this.classList.remove('dragging');
            document.querySelectorAll('.common-tag').forEach(tag => {
                tag.classList.remove('dragging');
            });
            cleanupCommonDrag();
        }

        function cleanupCommonDrag() {
            if (commonPlaceholderEl && commonPlaceholderEl.parentNode) {
                commonPlaceholderEl.parentNode.removeChild(commonPlaceholderEl);
            }
            commonPlaceholderEl = null;
            draggedCommonTag = null;
            commonDragSourceContainer = null;
        }

        function getCommonInsertIndexByPoint(x, y, container) {
            const items = Array.from(container.querySelectorAll('.common-tag'));
            if (!items.length) return 0;
            const TOL = 8;

            const sameRow = items.filter(el => {
                const r = el.getBoundingClientRect();
                return y >= r.top - TOL && y <= r.bottom + TOL;
            });

            if (sameRow.length) {
                for (let i = 0; i < sameRow.length; i++) {
                    const r = sameRow[i].getBoundingClientRect();
                    const mid = r.left + r.width / 2;
                    if (x < mid) return items.indexOf(sameRow[i]);
                }
                return items.indexOf(sameRow[sameRow.length - 1]) + 1;
            }

            let anchor = items[items.length - 1];
            let minDist = Infinity;
            items.forEach(el => {
                const r = el.getBoundingClientRect();
                const cy = r.top + r.height / 2;
                const d = Math.abs(y - cy);
                if (d < minDist) { minDist = d; anchor = el; }
            });
            const r = anchor.getBoundingClientRect();
            const mid = r.left + r.width / 2;
            const baseIdx = items.indexOf(anchor);
            return x < mid ? baseIdx : baseIdx + 1;
        }

        function onCommonContainerDragOver(e) {
            if (!draggedCommonTag) return false;
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            if (!commonPlaceholderEl) {
                commonPlaceholderEl = document.createElement('div');
                commonPlaceholderEl.className = 'tag-placeholder';
            }

            const targetContainer = e.target.closest('[data-container-type]') || e.target.closest('.common-tags');
            if (!targetContainer) return false;

            const idx = getCommonInsertIndexByPoint(e.clientX, e.clientY, targetContainer);
            const items = Array.from(targetContainer.querySelectorAll('.common-tag'));

            if (idx >= items.length) {
                if (commonPlaceholderEl.parentNode !== targetContainer || commonPlaceholderEl.nextElementSibling !== null) {
                    targetContainer.appendChild(commonPlaceholderEl);
                }
            } else {
                const ref = items[idx];
                if (ref.previousSibling !== commonPlaceholderEl) {
                    targetContainer.insertBefore(commonPlaceholderEl, ref);
                }
            }
            return false;
        }

        function reorderCommonTags(container, fromIndex, toIndex) {
            const cat = container.dataset.cat;
            const subcat = container.dataset.subcat || '';

            if (!cat) return;

            const data = commonData?.[cat];
            if (!data) return;

            if (isGroupedCategory(data) && subcat) {
                const arr = data.groups?.[subcat];
                if (Array.isArray(arr)) {
                    const [moved] = arr.splice(fromIndex, 1);
                    // 防御：约束范围
                    if (fromIndex < toIndex) toIndex -= 1;
                    const safeTo = Math.max(0, Math.min(toIndex, arr.length));
                    arr.splice(safeTo, 0, moved);
                    saveCommonData();
                    renderCommonTagsByCategory(cat);
                }
            } else if (Array.isArray(data)) {
                const [moved] = data.splice(fromIndex, 1);
                // 防御：约束范围
                if (fromIndex < toIndex) toIndex -= 1;
                const safeTo = Math.max(0, Math.min(toIndex, data.length));
                data.splice(safeTo, 0, moved);
                saveCommonData();
                renderCommonTagsByCategory(cat);
            }
        }

        function moveCommonTag(cat, fromSubcat, fromIndex, targetContainer) {
            const toSubcat = targetContainer.dataset.subcat || '';

            if (!cat) return;

            const data = commonData?.[cat];
            if (!isGroupedCategory(data)) return;

            const fromArr = data.groups?.[fromSubcat];
            if (!Array.isArray(fromArr)) return;

            const [movedItem] = fromArr.splice(fromIndex, 1);

            if (!data.groups[toSubcat]) {
                data.groups[toSubcat] = [];
            }
            data.groups[toSubcat].push(movedItem);

            saveCommonData();
            renderCommonTagsByCategory(cat);
        }

        function moveCommonTagTo(cat, fromSubcat, fromIndex, toSubcat, toIndex) {
            if (!cat) return;

            const data = commonData?.[cat];
            if (!isGroupedCategory(data)) return;

            const fromArr = data.groups?.[fromSubcat];
            if (!Array.isArray(fromArr)) return;

            const [movedItem] = fromArr.splice(fromIndex, 1);

            if (!data.groups[toSubcat]) {
                data.groups[toSubcat] = [];
            }

            const toArr = data.groups[toSubcat];
            const safeTo = Math.max(0, Math.min(toIndex, toArr.length));
            toArr.splice(safeTo, 0, movedItem);

            saveCommonData();
            renderCommonTagsByCategory(cat);
        }

        // 移除标签
        function removeTag(index) {
            const tags = promptEditor.value.split(/[,，]/).map(tag => tag.trim()).filter(tag => tag.length > 0);
            tags.splice(index, 1);
            promptEditor.value = tags.join(', ');
            updateTags();
        }

        function removeWeightedTag(tag) {
            const parsed = parseWeightedTag(tag);
            const baseKey = parsed.base.toLowerCase();
            let parts = (promptEditor.value || '').split(/[,，]/)
                .map(s => formatWeightedTag(parseWeightedTag(s).base, parseWeightedTag(s).weight))
                .filter(Boolean);
            parts = parts.filter(t => t !== tag);
            promptEditor.value = parts.join(', ');
            normalizePromptInput();
            if (window.__disabledTagSet.has(tag)) window.__disabledTagSet.delete(tag);
            window.__lastRenderList = (window.__lastRenderList || []).filter(t => t !== tag);
            weightStateMap.delete(baseKey);
            updateTags();
        }
        
        // 重置提示词
        function resetPrompt() {
            promptEditor.value = '';
            normalizePromptInput();
            updateTags();
            promptEditor.focus();
        }
        
        // 复制提示词
        async function copyPrompt() {
            const text = promptEditor.value || '';
            try {
                await navigator.clipboard.writeText(text);
            } catch (e) {
                const ta = document.createElement('textarea');
                ta.value = text;
                document.body.appendChild(ta);
                ta.select();
                try { document.execCommand('copy'); } finally { document.body.removeChild(ta); }
            }
        }

        // 随机选择当前分类的标签并追加到编辑器
        function randomPickFromActive() {
            const cat = getActiveCategory();
            if (!cat) { showInfo('请先创建或选择一个分类', '提示'); return; }
            const v = commonData[cat];
            const picks = [];
            if (isGroupedCategory(v)) {
                const groups = v.groups || {};
                const groupNames = Object.keys(groups).filter(name => Array.isArray(groups[name]) && groups[name].length > 0);
                if (!groupNames.length) { showInfo('该分类下没有可用的小标签', '提示'); return; }
                const k = Math.floor(Math.random() * groupNames.length) + 1; // 1..N
                const shuffled = groupNames.slice().sort(() => Math.random() - 0.5);
                const chosen = shuffled.slice(0, k);
                chosen.forEach(name => {
                    const arr = groups[name];
                    const it = arr[Math.floor(Math.random() * arr.length)];
                    if (it && it.text) picks.push(it.text);
                });
            } else if (Array.isArray(v)) {
                if (!v.length) { showInfo('该分类下没有标签', '提示'); return; }
                const max = Math.min(4, v.length);
                const k = Math.floor(Math.random() * max) + 1; // 1..max
                const idxs = [...Array(v.length).keys()].sort(() => Math.random() - 0.5).slice(0, k);
                idxs.forEach(i => { const it = v[i]; if (it && it.text) picks.push(it.text); });
            } else {
                showInfo('该分类暂无标签', '提示'); return;
            }
            if (!picks.length) { showInfo('未选出可用标签', '提示'); return; }
            const cur = promptEditor.value.trim();
            const add = picks.join(', ');
            promptEditor.value = cur ? (cur + ', ' + add) : add;
            normalizePromptInput();
            updateTags();
            promptEditor.focus();
        }

        // 全局随机：每个大标签至少1个；若为分组结构则每个小标签至多1个
        function randomPickAll() {
            const picks = [];
            const cats = Object.keys(commonData || {});
            cats.forEach(cat => {
                const v = commonData[cat];
                if (v && typeof v === 'object' && !Array.isArray(v) && v.groups && typeof v.groups === 'object') {
                    // 分组结构：每个非空小标签取1条
                    const groups = v.groups || {};
                    Object.keys(groups).forEach(sub => {
                        const arr = Array.isArray(groups[sub]) ? groups[sub] : [];
                        if (arr.length > 0) {
                            const it = arr[Math.floor(Math.random() * arr.length)];
                            if (it && it.text) picks.push(it.text);
                        }
                    });
                } else if (Array.isArray(v)) {
                    // 非分组：该大标签取1条
                    if (v.length > 0) {
                        const it = v[Math.floor(Math.random() * v.length)];
                        if (it && it.text) picks.push(it.text);
                    }
                }
            });
            if (!picks.length) { showInfo('暂无可随机的标签', '提示'); return; }
            // 覆盖写入（先清空再写入）
            promptEditor.value = picks.join(', ');
            normalizePromptInput();
            updateTags();
            promptEditor.focus();
        }

        // 历史快照存储与查看
        const HISTORY_KEY = 'ops_prompt_history';
        function loadHistory() {
            try {
                const raw = localStorage.getItem(HISTORY_KEY);
                const arr = raw ? JSON.parse(raw) : [];
                return Array.isArray(arr) ? arr : [];
            } catch(e) { return []; }
        }
        function saveHistory(arr) {
            try { localStorage.setItem(HISTORY_KEY, JSON.stringify(arr)); } catch(e) {}
        }
        function formatDate(ts) {
            const d = new Date(ts);
            const y = d.getFullYear();
            const m = d.getMonth() + 1;
            const day = d.getDate();
            return `${y}年${m}月${day}日`;
        }
        function isToday(ts) {
            const d = new Date(ts);
            const now = new Date();
            return d.getFullYear() === now.getFullYear() && d.getMonth() === now.getMonth() && d.getDate() === now.getDate();
        }
        function savePromptSnapshot() {
            const text = (promptEditor.value || '').trim();
            if (!text) { showInfo('内容为空，无法存储', '提示'); return; }
            const arr = loadHistory();
            arr.push({ ts: Date.now(), text });
            saveHistory(arr);
            showInfo('已存储当前提示词内容', '存储成功');
        }
        function openHistoryModal() {
            const wrap = document.getElementById('modal-history');
            const list = document.getElementById('history-list');
            const btnClose = document.getElementById('modal-history-close');
            const btnClear = document.getElementById('modal-history-clear');

            // 原始数组（用于删除定位）
            const arrRaw = loadHistory();
            // 排序并携带原始索引
            const arrSorted = arrRaw.map((v, i) => ({ ...v, _idx: i })).sort((a, b) => b.ts - a.ts);

            // 分组：按日期分组
            const groups = {};
            arrSorted.forEach(it => {
                const k = formatDate(it.ts);
                if (!groups[k]) groups[k] = [];
                groups[k].push(it);
            });

            // 渲染
            list.innerHTML = '';
            const todayStr = formatDate(Date.now());
            Object.keys(groups).forEach(dateStr => {
                const items = groups[dateStr];
                const sec = document.createElement('div');
                sec.style.border = '1px solid var(--border-color)';
                sec.style.borderRadius = '8px';
                sec.style.overflow = 'hidden';

                const header = document.createElement('div');
                header.style.padding = '10px 12px';
                header.style.background = 'var(--bg-color)';
                header.style.display = 'flex';
                header.style.justifyContent = 'space-between';
                header.style.alignItems = 'center';

                const title = document.createElement('span');
                title.textContent = dateStr;

                const toggle = document.createElement('button');
                toggle.className = 'btn btn-outline';
                toggle.textContent = '折叠/展开';

                const body = document.createElement('div');
                body.style.display = (dateStr === todayStr) ? 'block' : 'none';
                body.style.padding = '10px 12px';

                items.forEach(it => {
                    const itemEl = document.createElement('div');
                    itemEl.style.borderTop = '1px dashed var(--border-color)';
                    itemEl.style.padding = '8px 0';

                    // 顶部行：时间 + 操作按钮
                    const topRow = document.createElement('div');
                    topRow.style.display = 'flex';
                    topRow.style.justifyContent = 'space-between';
                    topRow.style.alignItems = 'center';

                    const time = new Date(it.ts);
                    const timeStr = `${time.getHours().toString().padStart(2,'0')}:${time.getMinutes().toString().padStart(2,'0')}:${time.getSeconds().toString().padStart(2,'0')}`;
                    const timeEl = document.createElement('div');
                    timeEl.style.fontSize = '0.85rem';
                    timeEl.style.opacity = '.7';
                    timeEl.textContent = timeStr;

                    const ops = document.createElement('div');
                    ops.style.display = 'flex';
                    ops.style.gap = '8px';

                    // 新增：导入按钮（清空后导入到编辑区）
                    const btnImport = document.createElement('button');
                    btnImport.className = 'btn btn-outline';
                    btnImport.textContent = '导入';
                    btnImport.addEventListener('click', () => {
                        const t = it.text || '';
                        promptEditor.value = '';      // 先清空
                        promptEditor.value = t;       // 再写入
                        normalizePromptInput();
                        updateTags();
                        promptEditor.focus();
                        // 导入后关闭"提示词历史"弹窗
                        onClose();
                    });

                    const btnCopy = document.createElement('button');
                    btnCopy.className = 'btn btn-outline';
                    btnCopy.textContent = '复制';
                    btnCopy.addEventListener('click', async () => {
                        try {
                            await navigator.clipboard.writeText(it.text || '');
                            showInfo('已复制到剪贴板', '复制成功');
                        } catch (e) {
                            showInfo('复制失败，请手动选择文本复制', '复制失败');
                        }
                    });

                    const btnDel = document.createElement('button');
                    btnDel.className = 'btn btn-outline';
                    btnDel.textContent = '删除';
                    btnDel.addEventListener('click', async () => {
                        const ok = await showConfirm('确认删除该历史记录？', '删除记录');
                        if (!ok) return;
                        const idx = it._idx;
                        if (typeof idx === 'number' && idx >= 0) {
                            const arrNew = loadHistory();
                            if (idx < arrNew.length && (arrNew[idx]?.ts === it.ts) && (arrNew[idx]?.text === it.text)) {
                                arrNew.splice(idx, 1);
                            } else {
                                // 回退策略：按 ts+text 查找
                                const pos = arrNew.findIndex(x => x.ts === it.ts && x.text === it.text);
                                if (pos >= 0) arrNew.splice(pos, 1);
                            }
                            saveHistory(arrNew);
                            openHistoryModal(); // 重新渲染
                        }
                    });

                    // 顺序：导入、复制、删除
                    ops.appendChild(btnImport);
                    ops.appendChild(btnCopy);
                    ops.appendChild(btnDel);
                    topRow.appendChild(timeEl);
                    topRow.appendChild(ops);

                    // 正文
                    const contentRow = document.createElement('pre');
                    contentRow.style.whiteSpace = 'pre-wrap';
                    contentRow.style.wordBreak = 'break-word';
                    contentRow.style.margin = '6px 0 0 0';
                    contentRow.textContent = it.text || '';

                    // 中文标签行：从英文文本拆分并映射中文
                    const zhRow = document.createElement('div');
                    zhRow.style.display = 'flex';
                    zhRow.style.flexWrap = 'wrap';
                    zhRow.style.gap = '6px';
                    zhRow.style.marginTop = '8px';

                    const parts = (it.text || '').split(/[,，]/).map(s => s.trim()).filter(Boolean);
                    parts.forEach(en => {
                        const zh = findZh(en);
                        if (!zh) return;
                        const tag = document.createElement('span');
                        tag.className = 'common-tag';
                        tag.textContent = zh;
                        tag.title = en;
                        zhRow.appendChild(tag);
                    });

                    itemEl.appendChild(topRow);
                    itemEl.appendChild(contentRow);
                    itemEl.appendChild(zhRow);
                    body.appendChild(itemEl);
                });

                toggle.addEventListener('click', () => {
                    const now = body.style.display !== 'none';
                    body.style.display = now ? 'none' : 'block';
                });

                header.appendChild(title);
                header.appendChild(toggle);
                sec.appendChild(header);
                sec.appendChild(body);
                list.appendChild(sec);
            });

            // 事件
            function onKey(e) {
                if (e.key === 'Escape') onClose();
            }
            function cleanup() {
                btnClose.removeEventListener('click', onClose);
                btnClear.removeEventListener('click', onClear);
                document.removeEventListener('keydown', onKey);
                hide(wrap);
            }
            function onClose() { cleanup(); }
            async function onClear() {
                const ok = await showConfirm('确认清空全部历史快照？', '清空历史');
                if (!ok) return;
                saveHistory([]);
                openHistoryModal(); // 重新渲染
            }

            btnClose.addEventListener('click', onClose);
            btnClear.addEventListener('click', onClear);
            document.addEventListener('keydown', onKey);
            show(wrap);
        }
        
        // 模态框逻辑
        function show(el) { el.style.display = 'flex'; }
        function hide(el) { el.style.display = 'none'; }

        function openCategoryModal(oldName) {
            const wrap = document.getElementById('modal-category');
            const input = document.getElementById('modal-cat-name');
            const confirmBtn = document.getElementById('modal-cat-confirm');
            const cancelBtn = document.getElementById('modal-cat-cancel');
            const closeBtn = document.getElementById('modal-cat-close');
            input.value = oldName ? oldName : '';
            show(wrap);
            setTimeout(() => input.focus(), 0);

            const onConfirm = () => {
                const newName = (input.value || '').trim();
                if (!newName) { input.focus(); return; }
                if (oldName && newName !== oldName) {
                    // 重命名分类
                    if (commonData[newName]) {
                        showInfo('已存在同名分类', '提示');
                        return;
                    }
                    const items = commonData[oldName] || [];
                    delete commonData[oldName];
                    commonData[newName] = items;
                    saveCommonData();
                    setActiveCategory(newName);
                    renderSidebar();
                } else if (!oldName) {
                    if (!commonData[newName]) commonData[newName] = [];
                    saveCommonData();
                    setActiveCategory(newName);
                    renderSidebar();
                }
                cleanup();
            };
            const onCancel = () => cleanup();

            function cleanup() {
                confirmBtn.removeEventListener('click', onConfirm);
                cancelBtn.removeEventListener('click', onCancel);
                closeBtn.removeEventListener('click', onCancel);
                input.removeEventListener('keydown', onKey);
                hide(wrap);
            }
            function onKey(e) {
                if (e.key === 'Enter') onConfirm();
                if (e.key === 'Escape') onCancel();
            }

            confirmBtn.addEventListener('click', onConfirm);
            cancelBtn.addEventListener('click', onCancel);
            closeBtn.addEventListener('click', onCancel);
            input.addEventListener('keydown', onKey);
        }

        function openTagModal(cat, index, subcat) {
            const wrap = document.getElementById('modal-tag');
            const title = document.getElementById('modal-tag-title');
            const zh = document.getElementById('modal-tag-zh');
            const en = document.getElementById('modal-tag-en');
            const tokenInput = document.getElementById('modal-cy-token');
            const translateBtn = document.getElementById('modal-tag-translate');
            const translateMyBtn = document.getElementById('modal-tag-translate-mymemory');
            const confirmBtn = document.getElementById('modal-tag-confirm');
            const cancelBtn = document.getElementById('modal-tag-cancel');
            const closeBtn = document.getElementById('modal-tag-close');
            const subBtnsWrap = document.getElementById('modal-subcat-buttons');
            const subNewBtn = document.getElementById('modal-subcat-newbtn');
            const LAST_SUBCAT_KEY = 'ops_last_subcat_' + cat;

            const editing = typeof index === 'number';
            title.textContent = editing ? '编辑标签' : '添加标签';

            // 类别按钮渲染（默认恢复上次选择；若无记录，稍后自动选第一个）
            let selectedSub = subcat || (function(){ try { return localStorage.getItem(LAST_SUBCAT_KEY) || ''; } catch(e){ return ''; } })();
            function renderSubButtons() {
                if (!subBtnsWrap) return;
                // 清空旧按钮（保留"新建类别"按钮）
                Array.from(subBtnsWrap.querySelectorAll('button[data-subcat]')).forEach(el => el.remove());
                const v0 = commonData?.[cat];
                const names = [];
                if (isGroupedCategory(v0)) {
                    const g = v0.groups || {};
                    const order = Array.isArray(v0.groupsOrder)
                        ? v0.groupsOrder.filter(n => Object.prototype.hasOwnProperty.call(g, n))
                            .concat(Object.keys(g).filter(n => !v0.groupsOrder.includes(n)))
                        : Object.keys(g);
                    order.forEach(k => names.push(k));
                }
                // 若当前没有选中小类别，则默认选中第一个
                if (!selectedSub && names.length) {
                    selectedSub = names[0];
                    try { localStorage.setItem(LAST_SUBCAT_KEY, selectedSub); } catch(e) {}
                }
                names.forEach(name => {
                    const btn = document.createElement('button');
                    btn.className = 'btn btn-outline btn-toggle' + (selectedSub === name ? ' active' : '');
                    btn.type = 'button';
                    btn.textContent = name;
                    btn.dataset.subcat = name;
                    btn.setAttribute('aria-pressed', selectedSub === name ? 'true' : 'false');
                    btn.addEventListener('click', () => {
                        selectedSub = name;
                        try { localStorage.setItem(LAST_SUBCAT_KEY, selectedSub); } catch(e) {}
                        renderSubButtons();
                    });
                    subBtnsWrap.appendChild(btn);
                });
            }
            if (subNewBtn) {
                // 覆盖式绑定，避免重复 addEventListener 导致多次弹窗
                subNewBtn.onclick = null;
                subNewBtn.onclick = async () => {
                    const name = await showInputModal('新建类别', '输入名称', '');
                    const val = (name || '').trim();
                    if (!val) return;
                    ensureGrouped(cat);
                    const catObj = commonData[cat];
                    const g = catObj.groups;
                    if (!g[val]) g[val] = [];
                    if (!Array.isArray(catObj.groupsOrder)) catObj.groupsOrder = Object.keys(g);
                    if (!catObj.groupsOrder.includes(val)) catObj.groupsOrder.push(val);
                    selectedSub = val;
                    try { localStorage.setItem(LAST_SUBCAT_KEY, selectedSub); } catch(e) {}
                    saveCommonData();
                    renderSubButtons(); // 刷新弹窗内按钮
                    renderCommonTagsByCategory(cat); // 同步刷新主界面分组，无需关闭弹窗
                };
            }
            renderSubButtons();

            // 预填表单
            const v = commonData?.[cat];
            if (editing) {
                if (isGroupedCategory(v) && subcat) {
                    const item = ((v.groups?.[subcat]) || [])[index] || {};
                    zh.value = item.lang_zh || '';
                    en.value = item.text || '';
                } else {
                    const item = (Array.isArray(v) ? v : [])[index] || {};
                    zh.value = item.lang_zh || '';
                    en.value = item.text || '';
                }
            } else {
                zh.value = '';
                en.value = '';
            }
            // 预填 token
            try { tokenInput.value = localStorage.getItem('ops_cy_token') || ''; } catch(e) {}

            show(wrap);
            setTimeout(() => (editing ? en : zh).focus(), 0);

            // 翻译函数
            const onTranslate = async () => {
                const lang_zh = (zh.value || '').trim();
                const token = (tokenInput.value || '').trim();
                if (!lang_zh) { zh.focus(); return; }
                if (!token) { tokenInput.focus(); return; }
                try { localStorage.setItem('ops_cy_token', token); } catch(e) {}
                try {
                    const res = await fetch('https://api.interpreter.caiyunai.com/v1/translator', {
                        method: 'POST',
                        headers: {
                            'content-type': 'application/json',
                            'x-authorization': 'token ' + token
                        },
                        body: JSON.stringify({
                            source: [lang_zh],
                            trans_type: 'auto2en',
                            request_id: 'ops',
                            detect: true
                        })
                    });
                    if (!res.ok) throw new Error('HTTP ' + res.status);
                    const data = await res.json();
                    const target = Array.isArray(data?.target) ? data.target[0] : (data?.target || '');
                    if (!target) throw new Error('翻译结果为空');
                    en.value = target;
                } catch (err) {
                    showInfo('翻译失败：' + (err?.message || err), '翻译失败');
                }
            };

            // MyMemory 翻译：无需令牌，直接 GET
            const onTranslateMyMemory = async () => {
                const lang_zh = (zh.value || '').trim();
                if (!lang_zh) { zh.focus(); return; }
                try {
                    const url = 'https://api.mymemory.translated.net/get?q=' + encodeURIComponent(lang_zh) + '&langpair=zh|en';
                    const res = await fetch(url, { method: 'GET' });
                    if (!res.ok) throw new Error('HTTP ' + res.status);
                    const data = await res.json();
                    const target = (data && data.responseData && data.responseData.translatedText) ? data.responseData.translatedText : '';
                    if (!target) throw new Error('翻译结果为空');
                    en.value = target;
                } catch (err) {
                    showInfo('MyMemory 翻译失败：' + (err?.message || err), '翻译失败');
                }
            };

            const onConfirm = async () => {
                const lang_zh2 = (zh.value || '').trim();
                let text2 = (en.value || '').trim();

                // 自动翻译：若存在 Token 且英文为空，仅有中文，则先翻译再保存
                if (lang_zh2 && !text2) {
                    let token = '';
                    try { token = (tokenInput.value || '').trim() || (localStorage.getItem('ops_cy_token') || ''); } catch(e) {}
                    if (token) {
                        try {
                            // 持久化 Token
                            try { localStorage.setItem('ops_cy_token', token); } catch(e) {}
                            const res = await fetch('https://api.interpreter.caiyunai.com/v1/translator', {
                                method: 'POST',
                                headers: {
                                    'content-type': 'application/json',
                                    'x-authorization': 'token ' + token
                                },
                                body: JSON.stringify({
                                    source: [lang_zh2],
                                    trans_type: 'auto2en',
                                    request_id: 'ops',
                                    detect: true
                                })
                            });
                            if (!res.ok) throw new Error('HTTP ' + res.status);
                            const data = await res.json();
                            const target = Array.isArray(data?.target) ? data.target[0] : (data?.target || '');
                            if (target) {
                                text2 = target;
                                en.value = target;
                            }
                        } catch (err) {
                            // 翻译失败则回退到手动填写
                        }
                    }
                }

                // 支持多标签：按分号(;)或顿号(、)分割
                const zhParts = lang_zh2.split(/[;、]+/).map(s => s.trim()).filter(Boolean);
                const enParts = text2.split(/[;、]+/).map(s => s.trim()).filter(Boolean);

                // 验证至少有一个标签对
                if (zhParts.length === 0 || enParts.length === 0) {
                    zh.focus();
                    return;
                }

                const targetSub = (selectedSub || '').trim();
                const vNow = commonData?.[cat];
                const tagsToAdd = [];

                // 生成标签对（取较大值，缺失部分为空）
                const maxLength = Math.max(zhParts.length, enParts.length);
                for (let i = 0; i < maxLength; i++) {
                    tagsToAdd.push({
                        lang_zh: zhParts[i] || '',
                        text: enParts[i] || ''
                    });
                }

                if (editing) {
                    // 编辑模式：只更新单个标签，不支持批量编辑
                    const zhSingle = zhParts[0] || lang_zh2;
                    const enSingle = enParts[0] || text2;

                    if (isGroupedCategory(vNow) && subcat) {
                        const g = vNow.groups || {};
                        const fromArr = g[subcat] || [];
                        const old = fromArr[index] || {};
                        if (targetSub && targetSub !== subcat) {
                            // 移动到其他类别
                            fromArr.splice(index, 1);
                            if (!g[targetSub]) g[targetSub] = [];
                            g[targetSub].push({ text: enSingle, lang_zh: zhSingle, pinned: !!old.pinned });
                        } else {
                            // 就地更新
                            fromArr[index] = { text: enSingle, lang_zh: zhSingle, pinned: !!old.pinned };
                        }
                    } else if (isGroupedCategory(vNow) && !subcat) {
                        const g = vNow.groups || {};
                        const uf = g['未分组'] || (g['未分组'] = []);
                        const old = uf[index] || {};
                        if (targetSub && targetSub !== '未分组') {
                            uf.splice(index, 1);
                            if (!g[targetSub]) g[targetSub] = [];
                            g[targetSub].push({ text: enSingle, lang_zh: zhSingle, pinned: !!old.pinned });
                        } else {
                            uf[index] = { text: enSingle, lang_zh: zhSingle, pinned: !!old.pinned };
                        }
                    } else {
                        commonData[cat] = Array.isArray(vNow) ? vNow : [];
                        // 旧数组模式
                        if (targetSub) {
                            // 升级为分组，并把旧数组作为"未分组"
                            ensureGrouped(cat);
                            const g = commonData[cat].groups;
                            const uf = g['未分组'];
                            const old = uf[index] || {};
                            uf.splice(index, 1);
                            if (!g[targetSub]) g[targetSub] = [];
                            g[targetSub].push({ text: enSingle, lang_zh: zhSingle, pinned: !!old.pinned });
                        } else {
                            const old = commonData[cat][index] || {};
                            commonData[cat][index] = { text: enSingle, lang_zh: zhSingle, pinned: !!old.pinned };
                        }
                    }
                } else {
                    // 添加模式：支持批量添加多个标签
                    tagsToAdd.forEach(tag => {
                        // 只添加中英文都存在的标签
                        if (tag.lang_zh && tag.text) {
                            if (targetSub) {
                                ensureGrouped(cat);
                                const groups = commonData[cat].groups;
                                if (!groups[targetSub]) groups[targetSub] = [];
                                groups[targetSub].push({ text: tag.text, lang_zh: tag.lang_zh, pinned: false });
                            } else {
                                if (Array.isArray(vNow)) {
                                    vNow.push({ text: tag.text, lang_zh: tag.lang_zh, pinned: false });
                                    commonData[cat] = vNow;
                                } else if (isGroupedCategory(vNow)) {
                                    const arr = vNow.groups?.['未分组'] || (vNow.groups['未分组'] = []);
                                    arr.push({ text: tag.text, lang_zh: tag.lang_zh, pinned: false });
                                } else {
                                    commonData[cat] = [{ text: tag.text, lang_zh: tag.lang_zh, pinned: false }];
                                }
                            }
                        }
                    });
                }

                // 记录最后一次小类别选择
                try {
                    if (selectedSub) localStorage.setItem(LAST_SUBCAT_KEY, selectedSub);
                } catch(e) {}

                saveCommonData();
                renderCommonTagsByCategory(cat);
                cleanup();
            };
            const onCancel = () => cleanup();

            function cleanup() {
                translateBtn.removeEventListener('click', onTranslate);
                translateMyBtn && translateMyBtn.removeEventListener('click', onTranslateMyMemory);
                confirmBtn.removeEventListener('click', onConfirm);
                cancelBtn.removeEventListener('click', onCancel);
                closeBtn.removeEventListener('click', onCancel);
                zh.removeEventListener('keydown', onKey);
                en.removeEventListener('keydown', onKey);
                hide(wrap);
            }
            function onKey(e) {
                if (e.key === 'Enter') onConfirm();
                if (e.key === 'Escape') onCancel();
            }

            translateBtn.addEventListener('click', onTranslate);
            translateMyBtn && translateMyBtn.addEventListener('click', onTranslateMyMemory);
            confirmBtn.addEventListener('click', onConfirm);
            cancelBtn.addEventListener('click', onCancel);
            closeBtn.addEventListener('click', onCancel);
            zh.addEventListener('keydown', onKey);
            en.addEventListener('keydown', onKey);
        }

        // 通用信息提示（居中模态，仅"确定"）
        function showInfo(message, title = '提示') {
            const wrap = document.getElementById('modal-confirm');
            const titleEl = document.getElementById('modal-confirm-title');
            const msgEl = document.getElementById('modal-confirm-message');
            const okBtn = document.getElementById('modal-confirm-ok');
            const cancelBtn = document.getElementById('modal-confirm-cancel');
            const closeBtn = document.getElementById('modal-confirm-close');
            titleEl.textContent = title || '提示';
            msgEl.textContent = message || '';
            const prevDisplay = cancelBtn.style.display;
            cancelBtn.style.display = 'none';
            show(wrap);
            return new Promise((resolve) => {
                const onOk = () => cleanup();
                function onKey(e) {
                    if (e.key === 'Enter' || e.key === 'Escape') cleanup();
                }
                function cleanup() {
                    okBtn.removeEventListener('click', onOk);
                    closeBtn.removeEventListener('click', onOk);
                    document.removeEventListener('keydown', onKey);
                    cancelBtn.style.display = prevDisplay || '';
                    hide(wrap);
                    resolve();
                }
                okBtn.addEventListener('click', onOk);
                closeBtn.addEventListener('click', onOk);
                document.addEventListener('keydown', onKey);
            });
        }

        // 通用确认函数（居中模态）
        function showConfirm(message, title = '确认操作') {
            const wrap = document.getElementById('modal-confirm');
            const titleEl = document.getElementById('modal-confirm-title');
            const msgEl = document.getElementById('modal-confirm-message');
            const okBtn = document.getElementById('modal-confirm-ok');
            const cancelBtn = document.getElementById('modal-confirm-cancel');
            const closeBtn = document.getElementById('modal-confirm-close');
            titleEl.textContent = title || '确认操作';
            msgEl.textContent = message || '';
            show(wrap);
            return new Promise((resolve) => {
                const onOk = () => cleanup(true);
                const onCancel = () => cleanup(false);
                function onKey(e) {
                    if (e.key === 'Enter') cleanup(true);
                    if (e.key === 'Escape') cleanup(false);
                }
                function cleanup(result) {
                    okBtn.removeEventListener('click', onOk);
                    cancelBtn.removeEventListener('click', onCancel);
                    closeBtn.removeEventListener('click', onCancel);
                    document.removeEventListener('keydown', onKey);
                    hide(wrap);
                    resolve(!!result);
                }
                okBtn.addEventListener('click', onOk);
                cancelBtn.addEventListener('click', onCancel);
                closeBtn.addEventListener('click', onCancel);
                document.addEventListener('keydown', onKey);
            });
        }

        // 输入弹窗（居中），返回 Promise<string|null>
        function showInputModal(title = '请输入', placeholder = '', defaultValue = '') {
            return new Promise((resolve) => {
                // 创建容器
                const backdrop = document.createElement('div');
                backdrop.className = 'modal-backdrop';
                backdrop.style.zIndex = '5000'; // 确保在编辑标签弹窗之上
                const modal = document.createElement('div');
                modal.className = 'modal';

                const header = document.createElement('div');
                header.className = 'modal-header';
                const hTitle = document.createElement('span');
                hTitle.textContent = title || '请输入';
                const btnClose = document.createElement('button');
                btnClose.className = 'btn btn-outline';
                btnClose.textContent = '关闭';
                header.appendChild(hTitle);
                header.appendChild(btnClose);

                const body = document.createElement('div');
                body.className = 'modal-body';
                const row = document.createElement('div');
                row.className = 'modal-row';
                const label = document.createElement('label');
                label.textContent = placeholder || '';
                const input = document.createElement('input');
                input.className = 'modal-input';
                input.type = 'text';
                input.value = defaultValue || '';
                input.placeholder = placeholder || '';
                row.appendChild(label);
                row.appendChild(input);
                body.appendChild(row);

                const footer = document.createElement('div');
                footer.className = 'modal-footer';
                const btnCancel = document.createElement('button');
                btnCancel.className = 'btn btn-outline';
                btnCancel.textContent = '取消';
                const btnOk = document.createElement('button');
                btnOk.className = 'btn btn-primary';
                btnOk.textContent = '确定';
                footer.appendChild(btnCancel);
                footer.appendChild(btnOk);

                modal.appendChild(header);
                modal.appendChild(body);
                modal.appendChild(footer);
                backdrop.appendChild(modal);
                document.body.appendChild(backdrop);
                show(backdrop);
                setTimeout(() => input.focus(), 0);

                function cleanup(val) {
                    btnOk.removeEventListener('click', onOk);
                    btnCancel.removeEventListener('click', onCancel);
                    btnClose.removeEventListener('click', onCancel);
                    input.removeEventListener('keydown', onKey);
                    hide(backdrop);
                    document.body.removeChild(backdrop);
                    resolve(val);
                }
                function onOk() { cleanup(input.value); }
                function onCancel() { cleanup(null); }
                function onKey(e) {
                    if (e.key === 'Enter') onOk();
                    if (e.key === 'Escape') onCancel();
                }

                btnOk.addEventListener('click', onOk);
                btnCancel.addEventListener('click', onCancel);
                btnClose.addEventListener('click', onCancel);
                input.addEventListener('keydown', onKey);
            });
        }

        // 图标选择器（固定集合）
        async function showIconPicker(defaultIcon = 'fas fa-globe') {
            return new Promise((resolve) => {
                const icons = ['fas fa-images','fas fa-book','fas fa-tags','fas fa-search','fas fa-image','fas fa-globe'];
                const backdrop = document.createElement('div');
                backdrop.className = 'modal-backdrop';
                backdrop.style.zIndex = '5000'; // 确保在编辑标签弹窗之上
                const modal = document.createElement('div');
                modal.className = 'modal';

                const header = document.createElement('div');
                header.className = 'modal-header';
                const title = document.createElement('span');
                title.textContent = '选择图标';
                const btnClose = document.createElement('button');
                btnClose.className = 'btn btn-outline';
                btnClose.textContent = '关闭';
                header.appendChild(title);
                header.appendChild(btnClose);

                const body = document.createElement('div');
                body.className = 'modal-body';
                const grid = document.createElement('div');
                grid.style.display = 'grid';
                grid.style.gridTemplateColumns = 'repeat(3, 1fr)';
                grid.style.gap = '8px';

                let selected = defaultIcon || 'fas fa-globe';
                icons.forEach(ic => {
                    const btn = document.createElement('button');
                    btn.className = 'btn btn-outline btn-toggle' + (ic === selected ? ' active' : '');
                    btn.style.display = 'flex';
                    btn.style.alignItems = 'center';
                    btn.style.gap = '8px';
                    btn.setAttribute('data-icon', ic);
                    const iEl = document.createElement('i');
                    iEl.className = ic;
                    const span = document.createElement('span');
                    span.textContent = ic;
                    btn.appendChild(iEl);
                    btn.appendChild(span);
                    btn.addEventListener('click', () => {
                        selected = ic;
                        Array.from(grid.querySelectorAll('button')).forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                    });
                    grid.appendChild(btn);
                });
                body.appendChild(grid);

                const footer = document.createElement('div');
                footer.className = 'modal-footer';
                const btnCancel = document.createElement('button');
                btnCancel.className = 'btn btn-outline';
                btnCancel.textContent = '取消';
                const btnOk = document.createElement('button');
                btnOk.className = 'btn btn-primary';
                btnOk.textContent = '确定';
                footer.appendChild(btnCancel);
                footer.appendChild(btnOk);

                modal.appendChild(header);
                modal.appendChild(body);
                modal.appendChild(footer);
                backdrop.appendChild(modal);
                document.body.appendChild(backdrop);
                show(backdrop);

                function cleanup(val) {
                    hide(backdrop);
                    document.body.removeChild(backdrop);
                    resolve(val);
                }
                btnOk.addEventListener('click', () => cleanup(selected));
                btnCancel.addEventListener('click', () => cleanup(null));
                btnClose.addEventListener('click', () => cleanup(null));
            });
        }

        // 右键菜单逻辑（委托）
        const ctxMenu = document.getElementById('context-menu');
        const ctxList = document.getElementById('context-menu-list');

        function hideContextMenu() {
            ctxMenu.style.display = 'none';
            ctxList.innerHTML = '';
        }
        function showContextMenu(x, y, items) {
            ctxList.innerHTML = '';
            items.forEach(({label, action, icon}) => {
                const div = document.createElement('div');
                div.className = 'item';
                if (icon) {
                    const iEl = document.createElement('i');
                    iEl.className = icon;
                    iEl.style.marginRight = '8px';
                    div.appendChild(iEl);
                    const span = document.createElement('span');
                    span.textContent = label;
                    div.appendChild(span);
                } else {
                    div.textContent = label;
                }
                div.addEventListener('click', () => {
                    hideContextMenu();
                    action();
                });
                ctxList.appendChild(div);
            });
            ctxMenu.style.display = 'block';
            const vw = window.innerWidth, vh = window.innerHeight;
            const rect = { w: 180, h: 40 * items.length };
            const px = Math.min(x, vw - rect.w - 8);
            const py = Math.min(y, vh - rect.h - 8);
            ctxMenu.style.left = px + 'px';
            ctxMenu.style.top = py + 'px';
        }

        document.addEventListener('click', hideContextMenu, { passive: true });
        window.addEventListener('scroll', hideContextMenu, { passive: true });
        window.addEventListener('resize', hideContextMenu, { passive: true });

        document.addEventListener('contextmenu', (e) => {
            const catCard = e.target.closest('.prompt-card');
            const promptTagEl = e.target.closest('.prompt-tag');
            const weightPanelEl = e.target.closest('[data-role="weight-panel"]');
            if (weightPanelEl) return; // 内联按钮保持默认行为
            const tagEl = e.target.closest('.common-tag');
            if (catCard) {
                e.preventDefault();
                const cat = catCard.getAttribute('data-cat') || '';
                if (!cat) return;
                showContextMenu(e.clientX, e.clientY, [
                    { label: '编辑名称', icon: 'fas fa-pen', action: () => openCategoryModal(cat) },
                    { label: '删除', icon: 'fas fa-trash', action: async () => {
                        const ok = await showConfirm(`确认删除分类「${cat}」及其所有标签？`, '删除分类');
                        if (!ok) return;
                        delete commonData[cat];
                        saveCommonData();
                        const keys = Object.keys(commonData);
                        setActiveCategory(keys[0] || '');
                        renderSidebar();
                    } }
                ]);
            } else if (promptTagEl) {
                e.preventDefault();
                const segEn = promptTagEl.querySelector('.seg-en');
                const currentTag = segEn ? (segEn.textContent || '').trim() : '';
                if (!currentTag) return;
                showContextMenu(e.clientX, e.clientY, [
                    { label: '权重+', icon: 'fas fa-plus', action: () => adjustTagWeightBySteps(currentTag, +1) },
                    { label: '权重-', icon: 'fas fa-minus', action: () => adjustTagWeightBySteps(currentTag, -1) },
                    { label: '删除', icon: 'fas fa-trash', action: () => removeWeightedTag(currentTag) }
                ]);
                return;
            }

            if (tagEl) {
                e.preventDefault();
                const cat = tagEl.getAttribute('data-cat') || getActiveCategory();
                const idx = parseInt(tagEl.getAttribute('data-index') || '-1', 10);
                const sub = tagEl.getAttribute('data-subcat') || '';
                if (!cat || idx < 0) return;

                let it = null, isPinned = false;
                const v = commonData[cat];
                if (Array.isArray(v)) {
                    it = v[idx];
                } else if (isGroupedCategory(v)) {
                    it = (v.groups?.[sub] || [])[idx];
                }
                if (!it) return;
                isPinned = !!it.pinned;

                // 组装右键菜单：固定项 + 自定义项 + 删除
                const menuItems = [
                    { label: isPinned ? '取消置顶' : '置顶', icon: 'fas fa-thumbtack', action: () => pinTag(cat, sub, idx, !isPinned) },
                    { label: '编辑标签', icon: 'fas fa-pen', action: () => openTagModal(cat, idx, sub) }
                ];

                // 自定义外链项（出现在"删除"上方）
                try {
                    const customMenus = (typeof getCtxMenus === 'function') ? getCtxMenus() : [];
                    if (Array.isArray(customMenus) && customMenus.length) {
                        const en = (it && it.text) ? String(it.text).trim() : '';
                        const zh = (it && it.lang_zh) ? String(it.lang_zh).trim() : '';
                        customMenus.forEach(m => {
                            const label = (m && m.name) ? String(m.name) : '链接';
                            const icon = (m && m.icon) ? String(m.icon) : 'fas fa-globe';
                            const tpl = (m && m.url) ? String(m.url) : '';
                            menuItems.push({
                                label,
                                icon,
                                action: () => {
                                    const url = (typeof buildUrlFromTemplate === 'function') ? buildUrlFromTemplate(tpl, en, zh) : '';
                                    if (!url) { showInfo('链接模板为空', '提示'); return; }
                                    window.open(url, '_blank');
                                }
                            });
                        });
                    }
                } catch(_) {}

                // 删除放在最后
                menuItems.push({
                    label: '删除',
                    icon: 'fas fa-trash',
                    action: async () => {
                        const v2 = commonData[cat];
                        let it2 = null;
                        if (Array.isArray(v2)) {
                            it2 = v2[idx];
                            if (!it2) return;
                            const ok = await showConfirm(`确认删除标签「${it2.lang_zh || it2.text}」？`, '删除标签');
                            if (!ok) return;
                            v2.splice(idx, 1);
                        } else if (isGroupedCategory(v2)) {
                            const arr = v2.groups?.[sub] || [];
                            it2 = arr[idx];
                            if (!it2) return;
                            const ok = await showConfirm(`确认删除标签「${it2.lang_zh || it2.text}」？`, '删除标签');
                            if (!ok) return;
                            arr.splice(idx, 1);
                        }
                        saveCommonData();
                        renderCommonTagsByCategory(cat);
                    }
                });

                showContextMenu(e.clientX, e.clientY, menuItems);
            } else {
                hideContextMenu();
            }
        });

        // 置顶/取消置顶（支持分组）
        function pinTag(cat, subcat, index, shouldPin) {
            const v = commonData[cat];
            if (Array.isArray(v)) {
                if (!v[index]) return;
                const [it] = v.splice(index, 1);
                it.pinned = !!shouldPin;
                if (shouldPin) v.unshift(it);
                else v.splice(Math.min(index, v.length), 0, it);
                commonData[cat] = v;
            } else if (isGroupedCategory(v)) {
                const arr = v.groups?.[subcat] || [];
                if (!arr[index]) return;
                const [it] = arr.splice(index, 1);
                it.pinned = !!shouldPin;
                if (shouldPin) arr.unshift(it);
                else arr.splice(Math.min(index, arr.length), 0, it);
            }
            saveCommonData();
            renderCommonTagsByCategory(cat);
        }

        // 上移/下移 类别分组顺序（以显式顺序数组 groupsOrder 控制渲染顺序）
        function moveSubcat(catKey, sub, direction) {
            const v = commonData[catKey];
            if (!isGroupedCategory(v)) { return; }
            const g = v.groups || {};
            // 基于现有顺序或键集合构造 order
            const baseOrder = Array.isArray(v.groupsOrder)
                ? v.groupsOrder.filter(n => Object.prototype.hasOwnProperty.call(g, n))
                    .concat(Object.keys(g).filter(n => !v.groupsOrder.includes(n)))
                : Object.keys(g);
            const idx = baseOrder.indexOf(sub);
            if (idx === -1) return;
            const target = direction === 'up' ? idx - 1 : idx + 1;
            if (target < 0 || target >= baseOrder.length) return;

            const newOrder = baseOrder.slice();
            newOrder.splice(idx, 1);
            newOrder.splice(target, 0, sub);

            // 生成全新 groups，保证插入顺序一致
            const reordered = {};
            for (const k of newOrder) {
                reordered[k] = Array.isArray(g[k]) ? g[k].slice() : (g[k] || []);
            }
            // 回写：同时写入 groups 与 groupsOrder
            commonData[catKey] = { groups: reordered, groupsOrder: newOrder };
            saveCommonData();
            renderCommonTagsByCategory(catKey);
        }

        // 兼容函数：若需要外部调用，可通过 key 切换分类
        function loadPrompt(catKey) {
            document.querySelectorAll('.prompt-card').forEach(card => card.classList.remove('active'));
            // 不强制设置 active，这里仅切换标签
            renderCommonTagsByCategory(catKey);
        }
        
        // 监听编辑器内容变化
        promptEditor.addEventListener('input', () => {
            normalizePromptInput({ restoreCaret: true });
            updateTags();
        });

        // 重置：清空所有分类、类别与历史
        async function resetAll() {
            const ok = await showConfirm('确认清空所有分类、类别与历史记录？此操作不可恢复。', '重置数据');
            if (!ok) return;
            // 清空数据
            commonData = {};
            saveCommonData();
            try {
                localStorage.removeItem('ops_prompt_history');
                localStorage.removeItem('ops_active_cat');
                // 保留 Dropbox 配置与文件选择
            } catch(e) {}
            resetPrompt();
            renderSidebar();
            showInfo('已清空所有标签与分类', '完成');
        }

        // 搜索提示词模态框
        function openSearchTagsModal() {
            const wrap = document.getElementById('modal-search-tags');
            const searchInput = document.getElementById('search-input');
            const searchResults = document.getElementById('search-results');
            const closeBtn = document.getElementById('modal-search-close');
            const clearBtn = document.getElementById('modal-search-clear');

            searchInput.value = '';
            searchResults.innerHTML = '<div style="opacity:0.6;font-size:0.9rem;">输入关键词后，下方将显示匹配的提示词</div>';

            // 搜索所有提示词
            function searchTags(keyword) {
                const results = [];
                const lowerKeyword = keyword.toLowerCase();

                for (const cat in commonData) {
                    const data = commonData[cat];

                    // 判断是数组格式还是分组格式
                    if (Array.isArray(data)) {
                        // 数组格式（旧版），类别为"未分组"
                        data.forEach(tag => {
                            const zh = (tag.lang_zh || '').trim();
                            const en = (tag.text || '').trim();
                            const zhMatch = zh && zh.toLowerCase().includes(lowerKeyword);
                            const enMatch = en && en.toLowerCase().includes(lowerKeyword);

                            if (zhMatch || enMatch) {
                                results.push({
                                    zh: zh,
                                    en: en,
                                    category: cat,
                                    subcategory: '未分组'
                                });
                            }
                        });
                    } else if (data.groups) {
                        // 分组格式（新版）
                        for (const sub in data.groups) {
                            const tags = data.groups[sub];
                            tags.forEach(tag => {
                                const zh = (tag.lang_zh || '').trim();
                                const en = (tag.text || '').trim();
                                const zhMatch = zh && zh.toLowerCase().includes(lowerKeyword);
                                const enMatch = en && en.toLowerCase().includes(lowerKeyword);

                                if (zhMatch || enMatch) {
                                    results.push({
                                        zh: zh,
                                        en: en,
                                        category: cat,
                                        subcategory: sub
                                    });
                                }
                            });
                        }
                    }
                }

                return results;
            }

            // 渲染搜索结果
            function renderSearchResults(results) {
                if (results.length === 0) {
                    searchResults.innerHTML = '<div style="opacity:0.6;font-size:0.9rem;">未找到匹配的提示词</div>';
                    return;
                }

                searchResults.innerHTML = '';
                results.forEach((result, index) => {
                    const row = document.createElement('div');
                    row.style.border = '1px solid var(--border-color)';
                    row.style.borderRadius = '8px';
                    row.style.padding = '12px';
                    row.style.cursor = 'pointer';
                    row.style.transition = 'all 0.2s ease';

                    const title = document.createElement('div');
                    title.style.fontWeight = '600';
                    title.style.color = 'var(--primary-color)';
                    title.style.marginBottom = '4px';
                    title.textContent = result.zh || result.en || '未命名';

                    const en = document.createElement('div');
                    en.style.fontSize = '0.9rem';
                    en.style.opacity = '0.85';
                    en.style.marginBottom = '4px';
                    en.textContent = result.en || '';

                    const cat = document.createElement('div');
                    cat.style.fontSize = '0.8rem';
                    cat.style.opacity = '0.6';
                    cat.textContent = `分类: ${result.category} | 类别: ${result.subcategory}`;

                    row.appendChild(title);
                    if (result.en) row.appendChild(en);
                    row.appendChild(cat);

                    row.addEventListener('click', () => {
                        const textToInsert = result.en || result.zh;

                        // 插入到提示词编辑器
                        const currentText = promptEditor.value || '';
                        const separator = currentText.trim() ? ', ' : '';
                        promptEditor.value = currentText + separator + textToInsert;

                        // 触发输入事件以更新标签显示
                        promptEditor.dispatchEvent(new Event('input'));

                        // 创建临时提示元素
                        const toast = document.createElement('div');
                        toast.style.position = 'fixed';
                        toast.style.top = '50%';
                        toast.style.left = '50%';
                        toast.style.transform = 'translate(-50%, -50%)';
                        toast.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';
                        toast.style.color = 'white';
                        toast.style.padding = '16px 32px';
                        toast.style.borderRadius = '8px';
                        toast.style.zIndex = '10000';
                        toast.style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)';
                        toast.style.fontSize = '1rem';
                        toast.textContent = `已插入: ${textToInsert}`;

                        document.body.appendChild(toast);
                        setTimeout(() => {
                            document.body.removeChild(toast);
                        }, 1000);
                    });

                    // 右键菜单
                    row.addEventListener('contextmenu', (e) => {
                        e.preventDefault();

                        // 创建右键菜单
                        const ctxMenu = document.createElement('div');
                        ctxMenu.className = 'context-menu';
                        ctxMenu.style.display = 'block';
                        ctxMenu.style.left = e.pageX + 'px';
                        ctxMenu.style.top = e.pageY + 'px';
                        ctxMenu.style.zIndex = '4000';

                        const editBtn = document.createElement('div');
                        editBtn.className = 'item';
                        editBtn.innerHTML = '<i class="fas fa-edit"></i> 编辑标签';
                        editBtn.addEventListener('click', () => {
                            ctxMenu.remove();

                            // 找到标签在原数据中的索引
                            const category = result.category;
                            const subcategory = result.subcategory;
                            let tagIndex = -1;

                            if (commonData[category]) {
                                const data = commonData[category];
                                if (Array.isArray(data)) {
                                    // 数组格式
                                    tagIndex = data.findIndex(t =>
                                        (t.lang_zh || '').trim() === (result.zh || '').trim() ||
                                        (t.text || '').trim() === (result.en || '').trim()
                                    );
                                    if (tagIndex >= 0) {
                                        openTagModal(category, tagIndex, '');
                                    }
                                } else if (data.groups && data.groups[subcategory]) {
                                    // 分组格式
                                    const tags = data.groups[subcategory];
                                    tagIndex = tags.findIndex(t =>
                                        (t.lang_zh || '').trim() === (result.zh || '').trim() ||
                                        (t.text || '').trim() === (result.en || '').trim()
                                    );
                                    if (tagIndex >= 0) {
                                        openTagModal(category, tagIndex, subcategory);
                                    }
                                }
                            }
                        });

                        ctxMenu.appendChild(editBtn);
                        document.body.appendChild(ctxMenu);

                        // 点击其他地方关闭菜单
                        const closeCtxMenu = () => {
                            ctxMenu.remove();
                            document.removeEventListener('click', closeCtxMenu);
                        };
                        setTimeout(() => {
                            document.addEventListener('click', closeCtxMenu);
                        }, 0);
                    });

                    row.addEventListener('mouseenter', () => {
                        row.style.backgroundColor = 'var(--primary-color)';
                        title.style.color = 'white';
                        en.style.color = 'rgba(255,255,255,0.9)';
                        cat.style.color = 'rgba(255,255,255,0.7)';
                    });

                    row.addEventListener('mouseleave', () => {
                        row.style.backgroundColor = '';
                        title.style.color = 'var(--primary-color)';
                        en.style.color = '';
                        cat.style.color = '';
                    });

                    searchResults.appendChild(row);
                });
            }

            // 搜索输入监听
            searchInput.addEventListener('input', (e) => {
                const keyword = e.target.value.trim();
                if (!keyword) {
                    searchResults.innerHTML = '<div style="opacity:0.6;font-size:0.9rem;">输入关键词后，下方将显示匹配的提示词</div>';
                    return;
                }

                const results = searchTags(keyword);
                renderSearchResults(results);
            });

            // 清空按钮
            clearBtn.addEventListener('click', () => {
                searchInput.value = '';
                searchResults.innerHTML = '<div style="opacity:0.6;font-size:0.9rem;">输入关键词后，下方将显示匹配的提示词</div>';
                searchInput.focus();
            });

            // 关闭按钮
            closeBtn.addEventListener('click', () => {
                hide(wrap);
                searchInput.removeEventListener('input', arguments.callee);
            });

            // ESC键关闭
            const onEscape = (e) => {
                if (e.key === 'Escape') {
                    document.removeEventListener('keydown', onEscape);
                    hide(wrap);
                }
            };
            document.addEventListener('keydown', onEscape);

            show(wrap);
            setTimeout(() => searchInput.focus(), 100);
        }

        // 绑定搜索按钮事件
        document.getElementById('search-tags-btn')?.addEventListener('click', openSearchTagsModal);

        // 初始化
        updateTags();
        loadCommonTagsFromStorage();
        setupUIEvents();
        // 启用侧栏拖拽容器事件
        if (sidebarList) {
            sidebarList.addEventListener('dragover', onSidebarDragOver);
            sidebarList.addEventListener('drop', onSidebarDrop);
        }
        // 首次打开提示：若无数据则询问是否导入默认测试数据
        maybePromptDefaultImport();
        document.getElementById('settings-toggle')?.addEventListener('click', openCtxMenuModal);
        updateTokenCounter();
    </script>
</body>
</html>